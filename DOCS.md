# Overview

---

## These are work-in-progress API docs. <br/> To start learning Jazz, see [Getting Started](./README.md#getting-started)

---

## Core packages

### `jazz-react` → [API](#jazz-react)
- **Build React apps with Jazz & CoJSON**
- Wraps `jazz-browser` ([API](#jazz-browser)) & includes `jazz-storage-indexeddb` for local storage

### `cojson` → [API](#cojson)
- **Implements collaborative values (CoValues), permissions & how to sync them**
- Provides a high-level API with **queries for fetching and editing nested CoValues**
- Provides a low-level API that lets you work with individual CoValues

### Feature-specific Extensions

#### `jazz-browser-media-images` → [API](#jazz-browser-media-images)

- Convert images from browser `File`s / `Blob`s into CoJSON `ImageDefinition`s with multi-resolution `BinaryCoStreams` &mdash; and progressively stream them back as `BlobURL`s you can use in `img` or `srcset`
## Supporting packages

#### `jazz-autosub` → [API](#jazz-autosub)
- **Automatically subscribe to nested CoValues** (e.g. `CoMap`s, `CoList`s, `CoStream`s) and **resolve references** to them

### Binaries

#### `cojson-simple-sync`
- A simple sync & storage peer you can run locally with `npx cojson-simple-sync`
- Uses `cojson-storage-sqlite` for storage

### Auth providers

#### `jazz-react-auth-local`
- **Stores user secrets locally using browser passkeys** (TouchID / FaceID / Security Keys)
- Wraps `jazz-browser-auth-local`, letting you define the Auth UI as a React Component

### Storage providers

#### `cojson-storage-sqlite`
- Stores CoValues and their transactions in a local SQLite database

#### `cojson-storage-indexeddb`
- Stores CoValues and their transactions in the browser's IndexedDB

<!-- AUTOGENERATED DOCS AFTER THIS POINT -->
# jazz-react

## `WithJazz(props)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function WithJazz(props: {
  auth: ReactAuthHook,
  children: ReactNode,
  syncAddress?: string,
  migration?: AccountMigration,
  apiKey?: string,
}): Element
```
Top-level component that provides Jazz context to your whole app, so you can use Jazz hooks in your components.



### Parameters:

| name | description |
| ----: | ---- |
| `props.auth` | An auth provider (renders login/sign-up UI if not logged in) - see available providers in the [Documentation](../../../DOCS.md#auth-providers) |
| `props.syncAddress?` | The address of the upstream syncing peer. Defaults to `wss://sync.jazz.tool` (Jazz Global Mesh). If not set explicitly, it can also be temporarily overwritten by setting the `sync` query parameter in the URL, like `https://your-app.example.net?sync=ws://localhost:4200`. |
| `props.migration?` | TODO: document |
| `props.apiKey?` | TODO: document |

##### Example:

How to use `WithJazz` with the `jazz-react-auth-local` auth provider:

```typescript
import { WithJazz } from "jazz-react";
import { LocalAuth } from "jazz-react-auth-local";

ReactDOM.createRoot(document.getElementById("root")!).render(
   <React.StrictMode>
      <WithJazz auth={LocalAuth({ appName: "My App" })}>
         <App />
     </WithJazz>
  </React.StrictMode>
);
```





----

## `useJazz()`

<sup>(function in `jazz-react`)</sup>

```typescript
export function useJazz<P extends Profile<ProfileShape, ProfileMeta>, R extends CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, Meta extends AccountMeta>(): {
  me: ResolvedAccount<Account<P, R, Meta>>,
  localNode: LocalNode,
  logOut: () => void,
}
```
Hook that exposes the Jazz context provided by `<WithJazz/>`, most importantly `me`, the account of
the current in user (which you can use access the account's `root` or `profile`,
and to create `Group`s as the current user, in which you can then create `CoValue`s).

Also provides a `logOut` function, which invokes the log-out logic of the Auth Provider passed to `<WithJazz/>`.



undefined



----

## `useAutoSub(id?)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function useAutoSub<T extends CoValue>(id: CoID<T>): Resolved<T> | undefined
```
Hook that subscribes to all updates of a given `CoValue` (identified by its `CoID`) and that automatically resolves references to nested `CoValue`s, loading and subscribing to them as well.

See `Resolved<T>` in `jazz-autosub` to see which fields and methods are available on the returned object.



### Parameters:

| name | description |
| ----: | ---- |
| `id?` | The `CoID` of the `CoValue` to subscribe to. Can be undefined (in which case the hook returns undefined). |





----

## `useSyncedValue(id?)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function useSyncedValue<T extends CoValue>(id: CoID<T>): undefined | T
```
Lower-level hook that loads and subscribes to updates of a single `CoValue` (identified by its `CoID`).

References to nested `CoValue`s are not automatically resolved, they are returned as `CoID`s.



### Parameters:

| name | description |
| ----: | ---- |
| `id?` | The `CoID` of the `CoValue` to subscribe to. Can be undefined (in which case the hook returns undefined). |





----

## `useBinaryStream(streamID?, allowUnfinished?)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function useBinaryStream<C extends BinaryCoStream<{
  type: "binary",
}>>(streamID: CoID<C>, allowUnfinished: boolean): {
  blob: Blob,
  blobURL: string,
} | undefined
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `streamID?` | TODO: document  |
| `allowUnfinished?` | TODO: document  |





----

## `useAcceptInvite(onInvite)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function useAcceptInvite<C extends CoValue>(onInvite: (valueID: CoID<C>, valueHint: string) => void): void
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |






----

## `createInviteLink(value, role, {baseURL?, valueHint?}?)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function createInviteLink<C extends CoValue>(value: C | Resolved<C>, role: "reader" | "writer" | "admin", {
  baseURL?: string,
  valueHint?: string,
}): string
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `role` | TODO: document  |
| `__namedParameters.baseURL?` | TODO: document |
| `__namedParameters.valueHint?` | TODO: document |





----

## `parseInviteLink(inviteURL)`

<sup>(function in `jazz-react`)</sup>

```typescript
export function parseInviteLink<C extends CoValue>(inviteURL: string): {
  valueID: CoID<C>,
  inviteSecret: InviteSecret,
  valueHint?: string,
} | undefined
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `inviteURL` | TODO: document  |





----

## `DemoAuth({appName, appHostname?, Component?})`

<sup>(function in `jazz-react`)</sup>

```typescript
export function DemoAuth({
  appName: string,
  appHostname?: string,
  Component?: DemoAuthComponent,
}): ReactAuthHook
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `__namedParameters.appName` | TODO: document |
| `__namedParameters.appHostname?` | TODO: document |
| `__namedParameters.Component?` | TODO: document |





----

## `ResolvedAccount`

<sup>(class in `jazz-react`)</sup>

```typescript
export class ResolvedAccount<A extends Account> extends ResolvedGroup<A> {...}
```
TODO: document

### `ResolvedAccount`: Constructors

<details>
<summary><b><code>new ResolvedAccount</code></b>(account, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  constructor<A extends Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>>(
    account: A,
    autoSubContext: AutoSubContext
  ): ResolvedAccount<A> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Methods

<details>
<summary><b><code>.createGroup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createGroup(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.acceptInvite(groupOrOwnedValueID, inviteSecret)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  acceptInvite<T extends CoValue>(
    groupOrOwnedValueID: CoID<T>,
    inviteSecret: `inviteSecret_z${string}`
  ): Promise<void> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `groupOrOwnedValueID` | TODO: document  |
| `inviteSecret` | TODO: document  |

</details>



<details>
<summary><b><code>.addMember(accountID, role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  removeMember(
    accountID: AccountID
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Properties

<details>
<summary><b><code>.isMe</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  isMe: boolean

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  id: CoID<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  meta: ResolvedGroupMeta<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  profile: ValueOrResolvedRef<A["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  root: ValueOrResolvedRef<A["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `ResolvedCoList`

<sup>(class in `jazz-react`)</sup>

```typescript
export class ResolvedCoList<L extends CoList> extends Array<ValueOrResolvedRef<L["_item"]>> {...}
```
TODO: document

### `ResolvedCoList`: Constructors

<br/>

### `ResolvedCoList`: Methods







<details>
<summary><b><code>.append(item, after?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  append(
    item: L["_item"],
    after?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `after?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.prepend(item, before?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  prepend(
    item: L["_item"],
    before?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `before?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(at, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  delete(
    at: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `at` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mutate(
    mutator: (mutable: MutableCoList<L["_item"], L["headerMeta"]>) => void
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>























<details>
<summary><b><code>.toString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toString(): string {...}

}
```
Returns a string representation of an array.



undefined</details>



<details>
<summary><b><code>.toLocaleString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toLocaleString(): string {...}

}
```
Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.



undefined</details>



<details>
<summary><b><code>.join(separator?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  join(
    separator?: string
  ): string {...}

}
```
Adds all the elements of an array into a string, separated by the specified separator string.



### Parameters:

| name | description |
| ----: | ---- |
| `separator?` | A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma. |

</details>



<details>
<summary><b><code>.slice(start?, end?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  slice(
    start?: number,
    end?: number
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns a copy of a section of an array.
For both start and end, a negative index can be used to indicate an offset from the end of the array.
For example, -2 refers to the second to last element of the array.



### Parameters:

| name | description |
| ----: | ---- |
| `start?` | The beginning index of the specified portion of the array.
If start is undefined, then the slice begins at index 0. |
| `end?` | The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.
If end is undefined, then the slice extends to the end of the array. |

</details>



<details>
<summary><b><code>.indexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  indexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the first occurrence of a value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0. |

</details>



<details>
<summary><b><code>.lastIndexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  lastIndexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): COMPLEX_TYPE_predicate {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.some(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  some(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether the specified callback function returns true for any element of an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.forEach(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  forEach(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => void,
    thisArg?: any
  ): void {...}

}
```
Performs the specified action for each element in an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.map(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  map<U>(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    thisArg?: any
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array, and returns an array that contains the results.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): S[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.reduce(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  find<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the first element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  find(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the first element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.entries()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  entries(): IterableIterator<[number, ValueOrResolvedRef<L["_item"]>]> {...}

}
```
Returns an iterable of key, value pairs for every entry in the array



undefined</details>



<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  keys(): IterableIterator<number> {...}

}
```
Returns an iterable of keys in the array



undefined</details>



<details>
<summary><b><code>.values()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  values(): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Returns an iterable of values in the array



undefined</details>



<details>
<summary><b><code>.includes(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  includes(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): boolean {...}

}
```
Determines whether an array includes a certain element, returning true or false as appropriate.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The element to search for. |
| `fromIndex?` | The position in this array at which to begin searching for searchElement. |

</details>



<details>
<summary><b><code>.flatMap(callback, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flatMap<U, This>(
    callback: (this: This, value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U | readonly U[],
    thisArg?: This
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array. Then, flattens the result into
a new array.
This is identical to a map followed by flat with depth 1.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callback function. If
thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.flat(this, depth?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flat<A, D extends number>(
    this: A,
    depth?: D
  ): FlatArray<A, D>[] {...}

}
```
Returns a new array with all sub-array elements concatenated into it recursively up to the
specified depth.



### Parameters:

| name | description |
| ----: | ---- |
| `this` | TODO: document  |
| `depth?` | The maximum recursion depth |

</details>



<details>
<summary><b><code>.at(index)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  at(
    index: number
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
Returns the item located at the specified index.



### Parameters:

| name | description |
| ----: | ---- |
| `index` | The zero-based index of the desired code unit. A negative index will count back from the last item. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLast<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the last element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  findLast(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findLastIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLastIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the last element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.[iterator]()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [iterator](): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Iterator



undefined</details>

<br/>

### `ResolvedCoList`: Properties

<details>
<summary><b><code>ResolvedCoList.[species]</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  [species]: ArrayConstructor

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  id: CoID<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  coValueType: "colist"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  meta: ResolvedCoListMeta<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.mapDeferred</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mapDeferred: (mapper: (item: {
    loaded: boolean,
    id: L["_item"] extends CoID<CoValue> ? any[any] : never,
    value((): ValueOrResolvedRef<L["_item"]>,
  }, idx: number) => O) => O[]

}
```
TODO: document

</details>



<details>
<summary><b><code>.length</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  length: number

}
```
Gets or sets the length of the array. This is a number one higher than the highest index in the array.



</details>



<details>
<summary><b><code>.[unscopables]</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [unscopables]: {
    length?: boolean,
    toString?: ,
    toLocaleString?: ,
    pop?: ,
    push?: ,
    concat?: ,
    join?: ,
    reverse?: ,
    shift?: ,
    slice?: ,
    sort?: ,
    splice?: ,
    unshift?: ,
    indexOf?: ,
    lastIndexOf?: ,
    every?: ,
    some?: ,
    forEach?: ,
    map?: ,
    filter?: ,
    reduce?: ,
    reduceRight?: ,
    find?: ,
    findIndex?: ,
    fill?: ,
    copyWithin?: ,
    entries?: ,
    keys?: ,
    values?: ,
    includes?: ,
    flatMap?: ,
    flat?: ,
    at?: ,
    findLast?: ,
    findLastIndex?: ,
    [iterator]?: ,
    [unscopables]?: boolean,
  }

}
```
Is an object whose properties have the value 'true'
when they will be absent when used in a 'with' statement.



</details>



----

## `ResolvedCoMapBase`

<sup>(class in `jazz-react`)</sup>

```typescript
export class ResolvedCoMapBase<M extends CoMap> {...}
```
TODO: document

### `ResolvedCoMapBase`: Constructors

<br/>

### `ResolvedCoMapBase`: Methods



<details>
<summary><b><code>.get(key)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  get<K extends string>(
    key: K
  ): ResolvedCoMap<M>[K] {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.set(key, value, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set<K extends string>(
    key: K,
    value: M["_shape"][K],
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set(
    kv: {
      [K in string]: M["_shape"][K]
    },
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  delete(
    key: keyof M["_shape"] & string,
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  mutate(
    mutator: (mutable: MutableCoMap<M["_shape"], M["headerMeta"]>) => void
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoMapBase`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  id: CoID<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  coValueType: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  meta: ResolvedCoMapMeta<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.as</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  as: (extension: AutoSubExtension<M, O>) => undefined | O

}
```
TODO: document

</details>



----

## `ResolvedCoStream`

<sup>(class in `jazz-react`)</sup>

```typescript
export class ResolvedCoStream<S extends CoStream> {...}
```
TODO: document

### `ResolvedCoStream`: Constructors

<br/>

### `ResolvedCoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  push(
    item: S["_item"],
    privacy?: "private" | "trusting"
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  mutate(
    mutator: (mutable: MutableCoStream<S["_item"], S["headerMeta"]>) => void
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoStream`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  id: CoID<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  coValueType: "costream"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  meta: ResolvedCoStreamMeta<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.perAccount</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perAccount: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.perSession</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perSession: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.me</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  me: ResolvedCoStreamEntry<S["_item"]>

}
```
TODO: document

</details>



----

## `ResolvedGroup`

<sup>(class in `jazz-react`)</sup>

```typescript
export class ResolvedGroup<G extends Group> {...}
```
TODO: document

### `ResolvedGroup`: Constructors

<details>
<summary><b><code>new ResolvedGroup</code></b>(group, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  constructor<G extends Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>>(
    group: G,
    autoSubContext: AutoSubContext
  ): ResolvedGroup<G> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `group` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Methods

<details>
<summary><b><code>.addMember(accountID, role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  removeMember(
    accountID: AccountID
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  id: CoID<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  meta: ResolvedGroupMeta<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  profile: ValueOrResolvedRef<G["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  root: ValueOrResolvedRef<G["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `ReactAuthHook`

<sup>(type alias in `jazz-react`)</sup>

```typescript
export type ReactAuthHook = () => {
  auth: AuthProvider,
  AuthUI: React.ReactNode,
  logOut?: () => void,
}
```
TODO: doc generator not implemented yet 2097152

----

## `Resolved`

<sup>(type alias in `jazz-react`)</sup>

```typescript
export type Resolved<T extends CoValue> = T extends CoMap
  ? T extends Account ? ResolvedAccount<T> : T extends Group ? ResolvedGroup<T> : ResolvedCoMap<T>
  : T extends CoList
    ? ResolvedCoList<T>
    : T extends CoStream
      ? T["headerMeta"] extends {
        type: "binary",
      } ? never : ResolvedCoStream<T>
      : ResolvedAccount | ResolvedGroup | ResolvedCoMap<CoMap> | ResolvedCoList<CoList> | ResolvedCoStream<CoStream>
```
TODO: doc generator not implemented yet 2097152

----

## `ResolvedCoMap`

<sup>(type alias in `jazz-react`)</sup>

```typescript
export type ResolvedCoMap<M extends CoMap> = {
  [K in keyof M["_shape"] & string]: ValueOrResolvedRef<M["_shape"][K]>
} & ResolvedCoMapBase<M>
```
TODO: doc generator not implemented yet 2097152


# cojson

## `LocalNode`

<sup>(class in `cojson`)</sup>

```typescript
export class LocalNode {...}
```
A `LocalNode` represents a local view of a set of loaded `CoValue`s, from the perspective of a particular account (or primitive cryptographic agent).

A `LocalNode` can have peers that it syncs to, for example some form of local persistence, or a sync server, such as `sync.jazz.tools` (Jazz Global Mesh).



##### Example:

You typically get hold of a `LocalNode` using `jazz-react`'s `useJazz()`:

```typescript
const { localNode } = useJazz();
```

### `LocalNode`:  Node Creation

<details>
<summary><b><code>LocalNode.withNewlyCreatedAccount({name, migration?, initialAgentSecret?})</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  withNewlyCreatedAccount<P extends Profile<ProfileShape, ProfileMeta>, R extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, Meta extends AccountMeta>(
    __namedParameters: {
      name: string,
      migration?: AccountMigration<P, R, Meta>,
      initialAgentSecret?: AgentSecret,
    }
  ): {
    node: LocalNode,
    accountID: AccountID,
    accountSecret: AgentSecret,
    sessionID: SessionID,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `__namedParameters.name` | TODO: document |
| `__namedParameters.migration?` | TODO: document |
| `__namedParameters.initialAgentSecret?` | TODO: document |

</details>



<details>
<summary><b><code>LocalNode.withLoadedAccount({accountID, accountSecret, sessionID, peersToLoadFrom, migration?})</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  withLoadedAccount<P extends Profile<ProfileShape, ProfileMeta>, R extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, Meta extends AccountMeta>(
    __namedParameters: {
      accountID: AccountID,
      accountSecret: AgentSecret,
      sessionID: SessionID,
      peersToLoadFrom: Peer[],
      migration?: AccountMigration<P, R, Meta>,
    }
  ): Promise<LocalNode> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `__namedParameters.accountID` | TODO: document |
| `__namedParameters.accountSecret` | TODO: document |
| `__namedParameters.sessionID` | TODO: document |
| `__namedParameters.peersToLoadFrom` | TODO: document |
| `__namedParameters.migration?` | TODO: document |

</details>

<br/>

### `LocalNode`:  Low-level

<details>
<summary><b><code>new LocalNode</code></b>(account, currentSessionID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  constructor(
    account: GeneralizedControlledAccount,
    currentSessionID: SessionID
  ): LocalNode {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |
| `currentSessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.account</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  account: GeneralizedControlledAccount

}
```
TODO: document

</details>



<details>
<summary><b><code>.currentSessionID</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  currentSessionID: SessionID

}
```
TODO: document

</details>



<details>
<summary><b><code>.syncManager</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  syncManager: SyncManager

}
```
TODO: document

</details>



<details>
<summary><b><code>.load(id, onProgress?)</code></b>  </summary>

```typescript
class LocalNode {

  load<T extends CoValue>(
    id: CoID<T>,
    onProgress?: (progress: number) => void
  ): Promise<"unavailable" | T> {...}

}
```
Loads a CoValue's content, syncing from peers as necessary and resolving the returned
promise once a first version has been loaded. See `coValue.subscribe()` and `node.useTelepathicData()`
for listening to subsequent updates to the CoValue.



### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |


</details>



<details>
<summary><b><code>.subscribe(id, callback)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  subscribe<T extends CoValue>(
    id: CoID<T>,
    callback: (update: "unavailable" | T) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |


</details>

<br/>

### `LocalNode`: Other







<details>
<summary><b><code>.acceptInvite(groupOrOwnedValueID, inviteSecret)</code></b>  </summary>

```typescript
class LocalNode {

  acceptInvite<T extends CoValue>(
    groupOrOwnedValueID: CoID<T>,
    inviteSecret: InviteSecret
  ): Promise<void> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |
| `groupOrOwnedValueID` | TODO: document  |
| `inviteSecret` | TODO: document  |

</details>











<details>
<summary><b><code>.resolveAccountAgentAsync(id, expectation?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class LocalNode {

  resolveAccountAgentAsync(
    id: AgentID | AccountID,
    expectation?: string
  ): Promise<AgentID> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |
| `expectation?` | TODO: document  |

</details>



<details>
<summary><b><code>.createGroup()</code></b>  </summary>

```typescript
class LocalNode {

  createGroup(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```




undefined</details>





----

## `Group`

<sup>(class in `cojson`)</sup>

```typescript
export class Group<P extends Profile, R extends CoMap, Meta extends JsonObject | null> extends CoMap<GroupShape<P, R>, Meta> {...}
```
A `Group` is a scope for permissions of its members (`"reader" | "writer" | "admin"`), applying to objects owned by that group.

 A `Group` object exposes methods for permission management and allows you to create new CoValues owned by that group.

 (Internally, a `Group` is also just a `CoMap`, mapping member accounts to roles and containing some
 state management for making cryptographic keys available to current members)



##### Example:

You typically get a group from a CoValue that you already have loaded:

 ```typescript
 const group = coMap.group;
 ```

##### Example:

Or, you can create a new group with a `LocalNode`:

 ```typescript
 const localNode.createGroup();
 ```

### `Group`:  Reading

<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  keys<K extends Object>(): K[] {...}

}
```
Get all keys currently in the map.



undefined</details>



<details>
<summary><b><code>.get(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  get<K extends Object>(
    key: K
  ): undefined | GroupShape<P, R>[K] {...}

}
```
Returns the current value for the given key.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.asObject()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  asObject(): {
    everyone: undefined | Role,
    profile: undefined | null | CoID<P>,
    root: undefined | null | CoID<R>,
    readKey: undefined | `key_z${string}`,
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  toJSON(): {
    everyone: undefined | Role,
    profile: undefined | null | CoID<P>,
    root: undefined | null | CoID<R>,
    readKey: undefined | `key_z${string}`,
  } {...}

}
```
TODO: document

undefined</details>

<br/>

### `Group`:  Role reading

<details>
<summary><b><code>.roleOf(accountID)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  roleOf(
    accountID: AccountID
  ): undefined | Role {...}

}
```
Returns the current role of a given account.



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.myRole()</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  myRole(): undefined | Role {...}

}
```
Returns the role of the current account in the group.



undefined</details>

<br/>

### `Group`:  Editing

<details>
<summary><b><code>.set(key, value, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  set<K extends Object>(
    key: K,
    value: GroupShape<P, R>[K],
    privacy?: "private" | "trusting"
  ): Group<P, R, Meta> {...}

}
```
Returns a new version of this CoMap with a new value for the given key.

If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  set(
    kv: {
      everyone: undefined | Role,
      profile: undefined | null | CoID<P>,
      root: undefined | null | CoID<R>,
      readKey: undefined | `key_z${string}`,
    },
    privacy?: "private" | "trusting"
  ): Group<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv.everyone` | TODO: document |
| `kv.profile` | TODO: document |
| `kv.root` | TODO: document |
| `kv.readKey` | TODO: document |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  delete(
    key: Object,
    privacy?: "private" | "trusting" = "private"
  ): Group<P, R, Meta> {...}

}
```
Returns a new version of this CoMap with the given key deleted (setting it to undefined).

If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  mutate(
    mutator: (mutable: MutableCoMap<GroupShape<P, R>, Meta>) => void
  ): Group<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Group`:  Role changing

<details>
<summary><b><code>.addMember(accountID, role)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): Group<P, R, Meta> {...}

}
```
Directly grants a new member a role in the group. The current account must be an
admin to be able to do so. Throws otherwise.



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  removeMember(
    accountID: AccountID
  ): Group<P, R, Meta> {...}

}
```
Strips the specified member of all roles (preventing future writes in
 the group and owned values) and rotates the read encryption key for that group
(preventing reads of new content in the group and owned values)



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): InviteSecret {...}

}
```
Creates an invite for new members to indirectly join the group,
allowing them to grant themselves the specified role with the InviteSecret
(a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.



### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>

<br/>

### `Group`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  subscribe(
    listener: (coMap: Group<P, R, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Group`:  Value creation

<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: M["_shape"],
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
Creates a new `CoMap` within this group, with the specified specialized
`CoMap` type `M` and optional static metadata.



### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b>  </summary>

```typescript
class Group<P, R, Meta> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
Creates a new `CoList` within this group, with the specified specialized
`CoList` type `L` and optional static metadata.



### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `Group`:  Time travel

<details>
<summary><b><code>.atTime(time)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  atTime(
    time: number
  ): Group<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>

<br/>

### `Group`:  Edit history

<details>
<summary><b><code>.nthEditAt(key, n)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  nthEditAt<K extends Object>(
    key: K,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastEditAt(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  lastEditAt<K extends Object>(
    key: K
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.editsAt(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  editsAt<K extends Object>(
    key: K
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>

<br/>

### `Group`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  id: CoID<Group<P, R, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  type: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._shape</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Group<P, R, Meta> {

  _shape: GroupShape<P, R>

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `Group`: Other











<details>
<summary><b><code>.edit(mutator)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Group<P, R, Meta> {

  edit(
    mutator: (mutable: MutableCoMap<GroupShape<P, R>, Meta>) => void
  ): Group<P, R, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>









----

## `CoMap`

<sup>(class in `cojson`)</sup>

```typescript
export class CoMap<Shape extends {
  [key: string]: JsonValue | undefined }, Meta extends JsonObject | null> extends CoMapView<Shape, Meta> implements CoValue {...}
```
A collaborative map with precise shape `Shape` and optional static metadata `Meta`



### `CoMap`:  Reading

<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class CoMap<Shape, Meta> {

  keys<K extends string>(): K[] {...}

}
```
Get all keys currently in the map.



undefined</details>



<details>
<summary><b><code>.get(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class CoMap<Shape, Meta> {

  get<K extends string>(
    key: K
  ): undefined | Shape[K] {...}

}
```
Returns the current value for the given key.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.asObject()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  asObject(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  toJSON(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>

<br/>

### `CoMap`:  Editing

<details>
<summary><b><code>.set(key, value, privacy?)</code></b>  </summary>

```typescript
class CoMap<Shape, Meta> {

  set<K extends string>(
    key: K,
    value: Shape[K],
    privacy?: "private" | "trusting"
  ): CoMap<Shape, Meta> {...}

}
```
Returns a new version of this CoMap with a new value for the given key.

If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  set(
    kv: {
      [K in string]: Shape[K]
    },
    privacy?: "private" | "trusting"
  ): CoMap<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b>  </summary>

```typescript
class CoMap<Shape, Meta> {

  delete(
    key: keyof Shape & string,
    privacy?: "private" | "trusting" = "private"
  ): CoMap<Shape, Meta> {...}

}
```
Returns a new version of this CoMap with the given key deleted (setting it to undefined).

If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  mutate(
    mutator: (mutable: MutableCoMap<Shape, Meta>) => void
  ): CoMap<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoMap`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  subscribe(
    listener: (coMap: CoMap<Shape, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoMap`:  Time travel

<details>
<summary><b><code>.atTime(time)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  atTime(
    time: number
  ): CoMap<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>

<br/>

### `CoMap`:  Edit history

<details>
<summary><b><code>.nthEditAt(key, n)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  nthEditAt<K extends string>(
    key: K,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastEditAt(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  lastEditAt<K extends string>(
    key: K
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.editsAt(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  editsAt<K extends string>(
    key: K
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>

<br/>

### `CoMap`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  id: CoID<CoMap<Shape, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  type: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._shape</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoMap<Shape, Meta> {

  _shape: Shape

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class CoMap<Shape, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class CoMap<Shape, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `CoMap`: Other



<details>
<summary><b><code>.edit(mutator)</code></b>  </summary>

```typescript
class CoMap<Shape, Meta> {

  edit(
    mutator: (mutable: MutableCoMap<Shape, Meta>) => void
  ): CoMap<Shape, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>









----

## `MutableCoMap`

<sup>(class in `cojson`)</sup>

```typescript
export class MutableCoMap<Shape extends {
  [key: string]: JsonValue | undefined }, Meta extends JsonObject | null> extends CoMapView<Shape, Meta> implements CoValue {...}
```
TODO: document

### `MutableCoMap`:  Reading

<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  keys<K extends string>(): K[] {...}

}
```
Get all keys currently in the map.



undefined</details>



<details>
<summary><b><code>.get(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  get<K extends string>(
    key: K
  ): undefined | Shape[K] {...}

}
```
Returns the current value for the given key.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.asObject()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  asObject(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  toJSON(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>

<br/>

### `MutableCoMap`:  Mutation

<details>
<summary><b><code>.set(key, value, privacy?)</code></b>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  set<K extends string>(
    key: K,
    value: Shape[K],
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
Sets a new value for the given key.

If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  delete(
    key: keyof Shape & string,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
Deletes the value for the given key (setting it to undefined).

If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>

<br/>

### `MutableCoMap`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  subscribe(
    listener: (coMap: MutableCoMap<Shape, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `MutableCoMap`:  Time travel

<details>
<summary><b><code>.atTime(time)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  atTime(
    time: number
  ): MutableCoMap<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>

<br/>

### `MutableCoMap`:  Edit history

<details>
<summary><b><code>.nthEditAt(key, n)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  nthEditAt<K extends string>(
    key: K,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastEditAt(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  lastEditAt<K extends string>(
    key: K
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.editsAt(key)</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  editsAt<K extends string>(
    key: K
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>

<br/>

### `MutableCoMap`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  id: CoID<MutableCoMap<Shape, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  type: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._shape</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoMap<Shape, Meta> {

  _shape: Shape

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoMapView</code></sup></sub>  </summary>

```typescript
class MutableCoMap<Shape, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `MutableCoMap`: Other









----

## `CoList`

<sup>(class in `cojson`)</sup>

```typescript
export class CoList<Item extends JsonValue, Meta extends JsonObject | null> extends CoListView<Item, Meta> implements CoValue {...}
```
TODO: document

### `CoList`:  Reading

<details>
<summary><b><code>.get(idx)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  get(
    idx: number
  ): undefined | Item {...}

}
```
Get the item currently at `idx`.



### Parameters:

| name | description |
| ----: | ---- |
| `idx` | TODO: document  |

</details>



<details>
<summary><b><code>.asArray()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  asArray(): Item[] {...}

}
```
Returns the current items in the CoList as an array.



undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  toJSON(): Item[] {...}

}
```
Returns the current items in the CoList as an array. (alias of `asArray`)



undefined</details>

<br/>

### `CoList`:  Editing

<details>
<summary><b><code>.append(item, after?, privacy?)</code></b>  </summary>

```typescript
class CoList<Item, Meta> {

  append(
    item: Item,
    after?: number,
    privacy?: "private" | "trusting" = "private"
  ): CoList<Item, Meta> {...}

}
```
Returns a new version of this CoList with `item` appended after the item currently at index `after`.

If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `after?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.prepend(item, before?, privacy?)</code></b>  </summary>

```typescript
class CoList<Item, Meta> {

  prepend(
    item: Item,
    before?: number,
    privacy?: "private" | "trusting" = "private"
  ): CoList<Item, Meta> {...}

}
```
Returns a new version of this CoList with `item` prepended before the item currently at index `before`.

If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `before?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(at, privacy?)</code></b>  </summary>

```typescript
class CoList<Item, Meta> {

  delete(
    at: number,
    privacy?: "private" | "trusting" = "private"
  ): CoList<Item, Meta> {...}

}
```
Returns a new version of this CoList with the item at index `at` deleted from the list.

If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `at` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  mutate(
    mutator: (mutable: MutableCoList<Item, Meta>) => void
  ): CoList<Item, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoList`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  subscribe(
    listener: (coList: CoList<Item, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoList`:  Time travel

<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  atTime(
    _time: number
  ): CoList<Item, Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>

<br/>

### `CoList`:  Edit history

<details>
<summary><b><code>.editAt(idx)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  editAt(
    idx: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `idx` | TODO: document  |

</details>



<details>
<summary><b><code>.deletionEdits()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  deletionEdits(): {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
  }[] {...}

}
```
TODO: document

undefined</details>

<br/>

### `CoList`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  id: CoID<CoList<Item, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  type: "colist"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoList<Item, Meta> {

  _item: Item

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class CoList<Item, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `CoList`: Other



<details>
<summary><b><code>.edit(mutator)</code></b>  </summary>

```typescript
class CoList<Item, Meta> {

  edit(
    mutator: (mutable: MutableCoList<Item, Meta>) => void
  ): CoList<Item, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>

















----

## `MutableCoList`

<sup>(class in `cojson`)</sup>

```typescript
export class MutableCoList<Item extends JsonValue, Meta extends JsonObject | null> extends CoListView<Item, Meta> implements CoValue {...}
```
TODO: document

### `MutableCoList`:  Reading

<details>
<summary><b><code>.get(idx)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  get(
    idx: number
  ): undefined | Item {...}

}
```
Get the item currently at `idx`.



### Parameters:

| name | description |
| ----: | ---- |
| `idx` | TODO: document  |

</details>



<details>
<summary><b><code>.asArray()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  asArray(): Item[] {...}

}
```
Returns the current items in the CoList as an array.



undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  toJSON(): Item[] {...}

}
```
Returns the current items in the CoList as an array. (alias of `asArray`)



undefined</details>

<br/>

### `MutableCoList`:  Mutating

<details>
<summary><b><code>.append(item, after?, privacy?)</code></b>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  append(
    item: Item,
    after?: number,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
Appends `item` after the item currently at index `after`.

If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `after?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.prepend(item, before?, privacy?)</code></b>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  prepend(
    item: Item,
    before?: number,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
Prepends `item` before the item currently at index `before`.

If `privacy` is `"private"` **(default)**, `item` is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `item` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.

*



### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `before?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(at, privacy?)</code></b>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  delete(
    at: number,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
Deletes the item at index `at` from the list.

If `privacy` is `"private"` **(default)**, the fact of this deletion is encrypted in the transaction, only readable by other members of the group this `CoList` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, the fact of this deletion is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.

*



### Parameters:

| name | description |
| ----: | ---- |
| `at` | TODO: document  |
| `privacy?` | TODO: document  |

</details>

<br/>

### `MutableCoList`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  subscribe(
    listener: (coList: MutableCoList<Item, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `MutableCoList`:  Time travel

<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  atTime(
    _time: number
  ): MutableCoList<Item, Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>

<br/>

### `MutableCoList`:  Edit history

<details>
<summary><b><code>.editAt(idx)</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  editAt(
    idx: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `idx` | TODO: document  |

</details>



<details>
<summary><b><code>.deletionEdits()</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  deletionEdits(): {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
  }[] {...}

}
```
TODO: document

undefined</details>

<br/>

### `MutableCoList`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  id: CoID<MutableCoList<Item, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  type: "colist"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoList<Item, Meta> {

  _item: Item

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoListView</code></sup></sub>  </summary>

```typescript
class MutableCoList<Item, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `MutableCoList`: Other

















----

## `CoStream`

<sup>(class in `cojson`)</sup>

```typescript
export class CoStream<Item extends JsonValue, Meta extends JsonObject | null> extends CoStreamView<Item, Meta> implements CoValue {...}
```
TODO: document

### `CoStream`: Accessors

<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `CoStream`: Constructors

<details>
<summary><b><code>new CoStream</code></b>(core)</code></b> <sub><sup>from <code>CoStreamView<Item, Meta></code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  constructor<Item extends JsonValue, Meta extends null | JsonObject>(
    core: CoValueCore
  ): CoStream<Item, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `core` | TODO: document  |

</details>

<br/>

### `CoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  push(
    item: Item,
    privacy?: "private" | "trusting" = "private"
  ): CoStream<Item, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  mutate(
    mutator: (mutable: MutableCoStream<Item, Meta>) => void
  ): CoStream<Item, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.edit(mutator)</code></b>  </summary>

```typescript
class CoStream<Item, Meta> {

  edit(
    mutator: (mutable: MutableCoStream<Item, Meta>) => void
  ): CoStream<Item, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  atTime(
    _time: number
  ): CoStream<Item, Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>





<details>
<summary><b><code>.getSingleStream()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  getSingleStream(): undefined | Item[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.sessions()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  sessions(): SessionID[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.accounts()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  accounts(): Set<AccountID> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.nthItemIn(sessionID, n)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  nthItemIn(
    sessionID: SessionID,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemIn(sessionID)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  lastItemIn(
    sessionID: SessionID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsIn(sessionID)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  itemsIn(
    sessionID: SessionID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemBy(account)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  lastItemBy(
    account: AgentID | AccountID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsBy(account)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  itemsBy(
    account: AgentID | AccountID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
    in: SessionID,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  toJSON(): {
    [key: SessionID]: Item[] } {...}

}
```
Returns an immutable JSON presentation of this `CoValue`



undefined</details>



<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  subscribe(
    listener: (coStream: CoStream<Item, Meta>) => void
  ): () => void {...}

}
```
Lets you subscribe to future updates to this CoValue (whether made locally or by other users).

Takes a listener function that will be called with the current state for each update.

Returns an unsubscribe function.

Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`.



### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoStream`: Properties

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  id: CoID<CoStream<Item, Meta>>

}
```
The `CoValue`'s (precisely typed) `CoID`



</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class CoStream<Item, Meta> {

  type: "costream"

}
```
Specifies which kind of `CoValue` this is



</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>.items</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  items: {
    [key: SessionID]: CoStreamItem<Item>[] }

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoStream<Item, Meta> {

  _item: Item

}
```
TODO: document

</details>



----

## `MutableCoStream`

<sup>(class in `cojson`)</sup>

```typescript
export class MutableCoStream<Item extends JsonValue, Meta extends JsonObject | null> extends CoStreamView<Item, Meta> implements CoValue {...}
```
TODO: document

### `MutableCoStream`: Accessors

<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `MutableCoStream`: Constructors

<details>
<summary><b><code>new MutableCoStream</code></b>(core)</code></b> <sub><sup>from <code>CoStreamView<Item, Meta></code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  constructor<Item extends JsonValue, Meta extends null | JsonObject>(
    core: CoValueCore
  ): MutableCoStream<Item, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `core` | TODO: document  |

</details>

<br/>

### `MutableCoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  push(
    item: Item,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  atTime(
    _time: number
  ): MutableCoStream<Item, Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>





<details>
<summary><b><code>.getSingleStream()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  getSingleStream(): undefined | Item[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.sessions()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  sessions(): SessionID[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.accounts()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  accounts(): Set<AccountID> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.nthItemIn(sessionID, n)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  nthItemIn(
    sessionID: SessionID,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemIn(sessionID)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  lastItemIn(
    sessionID: SessionID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsIn(sessionID)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  itemsIn(
    sessionID: SessionID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemBy(account)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  lastItemBy(
    account: AgentID | AccountID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsBy(account)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  itemsBy(
    account: AgentID | AccountID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: Item,
    in: SessionID,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  toJSON(): {
    [key: SessionID]: Item[] } {...}

}
```
Returns an immutable JSON presentation of this `CoValue`



undefined</details>



<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  subscribe(
    listener: (coStream: MutableCoStream<Item, Meta>) => void
  ): () => void {...}

}
```
Lets you subscribe to future updates to this CoValue (whether made locally or by other users).

Takes a listener function that will be called with the current state for each update.

Returns an unsubscribe function.

Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`.



### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `MutableCoStream`: Properties

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  id: CoID<MutableCoStream<Item, Meta>>

}
```
The `CoValue`'s (precisely typed) `CoID`



</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  </summary>

```typescript
class MutableCoStream<Item, Meta> {

  type: "costream"

}
```
Specifies which kind of `CoValue` this is



</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>.items</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  items: {
    [key: SessionID]: CoStreamItem<Item>[] }

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>CoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableCoStream<Item, Meta> {

  _item: Item

}
```
TODO: document

</details>



----

## `BinaryCoStream`

<sup>(class in `cojson`)</sup>

```typescript
export class BinaryCoStream<Meta extends BinaryCoStreamMeta> extends BinaryCoStreamView<Meta> implements CoValue {...}
```
TODO: document

### `BinaryCoStream`: Accessors

<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `BinaryCoStream`: Constructors

<details>
<summary><b><code>new BinaryCoStream</code></b>(core)</code></b> <sub><sup>from <code>BinaryCoStreamView<Meta></code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  constructor<Meta extends BinaryCoStreamMeta>(
    core: CoValueCore
  ): BinaryCoStream<Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `core` | TODO: document  |

</details>

<br/>

### `BinaryCoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  </summary>

```typescript
class BinaryCoStream<Meta> {

  push(
    item: BinaryStreamItem,
    privacy?: "private" | "trusting"
  ): BinaryCoStream<Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.push(item, privacy, returnNewStream)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  push(
    item: BinaryStreamItem,
    privacy: "private" | "trusting",
    returnNewStream: true
  ): BinaryCoStream<Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy` | TODO: document  |
| `returnNewStream` | TODO: document  |

</details>



<details>
<summary><b><code>.push(item, privacy, returnNewStream)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  push(
    item: BinaryStreamItem,
    privacy: "private" | "trusting",
    returnNewStream: false
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy` | TODO: document  |
| `returnNewStream` | TODO: document  |

</details>



<details>
<summary><b><code>.startBinaryStream(settings, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  startBinaryStream(
    settings: BinaryStreamInfo,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `settings` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.pushBinaryStreamChunk(chunk, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  pushBinaryStreamChunk(
    chunk: Uint8Array,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `chunk` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.endBinaryStream(privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  endBinaryStream(
    privacy?: "private" | "trusting" = "private"
  ): BinaryCoStream<Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  mutate(
    mutator: (mutable: MutableBinaryCoStream<Meta>) => void
  ): BinaryCoStream<Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.edit(mutator)</code></b>  </summary>

```typescript
class BinaryCoStream<Meta> {

  edit(
    mutator: (mutable: MutableBinaryCoStream<Meta>) => void
  ): BinaryCoStream<Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.getBinaryChunks(allowUnfinished?)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  getBinaryChunks(
    allowUnfinished?: boolean
  ): undefined | (BinaryStreamInfo & {
    chunks: Uint8Array[],
    finished: boolean,
  }) {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `allowUnfinished?` | TODO: document  |

</details>



<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  atTime(
    _time: number
  ): BinaryCoStream<Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>





<details>
<summary><b><code>.getSingleStream()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  getSingleStream(): undefined | BinaryStreamItem[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.sessions()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  sessions(): SessionID[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.accounts()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  accounts(): Set<AccountID> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.nthItemIn(sessionID, n)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  nthItemIn(
    sessionID: SessionID,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemIn(sessionID)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  lastItemIn(
    sessionID: SessionID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsIn(sessionID)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  itemsIn(
    sessionID: SessionID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemBy(account)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  lastItemBy(
    account: AgentID | AccountID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsBy(account)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  itemsBy(
    account: AgentID | AccountID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
    in: SessionID,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  toJSON(): {
    [key: SessionID]: Item[] } {...}

}
```
Returns an immutable JSON presentation of this `CoValue`



undefined</details>



<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  subscribe(
    listener: (coStream: BinaryCoStream<Meta>) => void
  ): () => void {...}

}
```
Lets you subscribe to future updates to this CoValue (whether made locally or by other users).

Takes a listener function that will be called with the current state for each update.

Returns an unsubscribe function.

Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`.



### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `BinaryCoStream`: Properties

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  id: CoID<BinaryCoStream<Meta>>

}
```
The `CoValue`'s (precisely typed) `CoID`



</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class BinaryCoStream<Meta> {

  type: "costream"

}
```
Specifies which kind of `CoValue` this is



</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>.items</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  items: {
    [key: SessionID]: CoStreamItem<Item>[] }

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BinaryCoStream<Meta> {

  _item: BinaryStreamItem

}
```
TODO: document

</details>



----

## `MutableBinaryCoStream`

<sup>(class in `cojson`)</sup>

```typescript
export class MutableBinaryCoStream<Meta extends BinaryCoStreamMeta> extends BinaryCoStreamView<Meta> implements CoValue {...}
```
TODO: document

### `MutableBinaryCoStream`: Accessors

<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `MutableBinaryCoStream`: Constructors

<details>
<summary><b><code>new MutableBinaryCoStream</code></b>(core)</code></b> <sub><sup>from <code>BinaryCoStreamView<Meta></code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  constructor<Meta extends BinaryCoStreamMeta>(
    core: CoValueCore
  ): MutableBinaryCoStream<Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `core` | TODO: document  |

</details>

<br/>

### `MutableBinaryCoStream`: Methods



<details>
<summary><b><code>.startBinaryStream(settings, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  startBinaryStream(
    settings: BinaryStreamInfo,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `settings` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.pushBinaryStreamChunk(chunk, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  pushBinaryStreamChunk(
    chunk: Uint8Array,
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `chunk` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.endBinaryStream(privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  endBinaryStream(
    privacy?: "private" | "trusting" = "private"
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.getBinaryChunks(allowUnfinished?)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  getBinaryChunks(
    allowUnfinished?: boolean
  ): undefined | (BinaryStreamInfo & {
    chunks: Uint8Array[],
    finished: boolean,
  }) {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `allowUnfinished?` | TODO: document  |

</details>



<details>
<summary><b><code>.atTime(_time)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  atTime(
    _time: number
  ): MutableBinaryCoStream<Meta> {...}

}
```
Not yet implemented



### Parameters:

| name | description |
| ----: | ---- |
| `_time` | TODO: document  |

</details>





<details>
<summary><b><code>.getSingleStream()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  getSingleStream(): undefined | BinaryStreamItem[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.sessions()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  sessions(): SessionID[] {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.accounts()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  accounts(): Set<AccountID> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.nthItemIn(sessionID, n)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  nthItemIn(
    sessionID: SessionID,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemIn(sessionID)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  lastItemIn(
    sessionID: SessionID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsIn(sessionID)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  itemsIn(
    sessionID: SessionID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.lastItemBy(account)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  lastItemBy(
    account: AgentID | AccountID
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.itemsBy(account)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  itemsBy(
    account: AgentID | AccountID
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value: BinaryStreamItem,
    in: SessionID,
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |

</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  toJSON(): {
    [key: SessionID]: Item[] } {...}

}
```
Returns an immutable JSON presentation of this `CoValue`



undefined</details>



<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  subscribe(
    listener: (coStream: MutableBinaryCoStream<Meta>) => void
  ): () => void {...}

}
```
Lets you subscribe to future updates to this CoValue (whether made locally or by other users).

Takes a listener function that will be called with the current state for each update.

Returns an unsubscribe function.

Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`.



### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `MutableBinaryCoStream`: Properties

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  id: CoID<MutableBinaryCoStream<Meta>>

}
```
The `CoValue`'s (precisely typed) `CoID`



</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  </summary>

```typescript
class MutableBinaryCoStream<Meta> {

  type: "costream"

}
```
Specifies which kind of `CoValue` this is



</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>.items</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  items: {
    [key: SessionID]: CoStreamItem<Item>[] }

}
```
TODO: document

</details>



<details>
<summary><b><code>._item</code></b> <sub><sup>from <code>BinaryCoStreamView</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class MutableBinaryCoStream<Meta> {

  _item: BinaryStreamItem

}
```
TODO: document

</details>



----

## `Account`

<sup>(class in `cojson`)</sup>

```typescript
export class Account<P extends Profile, R extends CoMap, Meta extends AccountMeta> extends Group<P, R, Meta> {...}
```
A `Group` is a scope for permissions of its members (`"reader" | "writer" | "admin"`), applying to objects owned by that group.

 A `Group` object exposes methods for permission management and allows you to create new CoValues owned by that group.

 (Internally, a `Group` is also just a `CoMap`, mapping member accounts to roles and containing some
 state management for making cryptographic keys available to current members)



##### Example:

You typically get a group from a CoValue that you already have loaded:

 ```typescript
 const group = coMap.group;
 ```

##### Example:

Or, you can create a new group with a `LocalNode`:

 ```typescript
 const localNode.createGroup();
 ```

### `Account`:  Reading

<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  keys<K extends Object>(): K[] {...}

}
```
Get all keys currently in the map.



undefined</details>



<details>
<summary><b><code>.get(key)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  get<K extends Object>(
    key: K
  ): undefined | GroupShape<P, R>[K] {...}

}
```
Returns the current value for the given key.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.asObject()</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  asObject(): {
    everyone: undefined | Role,
    profile: undefined | null | CoID<P>,
    root: undefined | null | CoID<R>,
    readKey: undefined | `key_z${string}`,
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  toJSON(): {
    everyone: undefined | Role,
    profile: undefined | null | CoID<P>,
    root: undefined | null | CoID<R>,
    readKey: undefined | `key_z${string}`,
  } {...}

}
```
TODO: document

undefined</details>

<br/>

### `Account`:  Role reading

<details>
<summary><b><code>.roleOf(accountID)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  roleOf(
    accountID: AccountID
  ): undefined | Role {...}

}
```
Returns the current role of a given account.



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.myRole()</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  myRole(): undefined | Role {...}

}
```
Returns the role of the current account in the group.



undefined</details>

<br/>

### `Account`:  Editing

<details>
<summary><b><code>.set(key, value, privacy?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  set<K extends Object>(
    key: K,
    value: GroupShape<P, R>[K],
    privacy?: "private" | "trusting"
  ): Account<P, R, Meta> {...}

}
```
Returns a new version of this CoMap with a new value for the given key.

If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  set(
    kv: {
      everyone: undefined | Role,
      profile: undefined | null | CoID<P>,
      root: undefined | null | CoID<R>,
      readKey: undefined | `key_z${string}`,
    },
    privacy?: "private" | "trusting"
  ): Account<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv.everyone` | TODO: document |
| `kv.profile` | TODO: document |
| `kv.root` | TODO: document |
| `kv.readKey` | TODO: document |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  delete(
    key: Object,
    privacy?: "private" | "trusting" = "private"
  ): Account<P, R, Meta> {...}

}
```
Returns a new version of this CoMap with the given key deleted (setting it to undefined).

If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  mutate(
    mutator: (mutable: MutableCoMap<GroupShape<P, R>, Meta>) => void
  ): Account<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Account`:  Role changing

<details>
<summary><b><code>.addMember(accountID, role)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): Account<P, R, Meta> {...}

}
```
Directly grants a new member a role in the group. The current account must be an
admin to be able to do so. Throws otherwise.



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  removeMember(
    accountID: AccountID
  ): Account<P, R, Meta> {...}

}
```
Strips the specified member of all roles (preventing future writes in
 the group and owned values) and rotates the read encryption key for that group
(preventing reads of new content in the group and owned values)



### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): InviteSecret {...}

}
```
Creates an invite for new members to indirectly join the group,
allowing them to grant themselves the specified role with the InviteSecret
(a string starting with "inviteSecret_") - use `LocalNode.acceptInvite()` for this purpose.



### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>

<br/>

### `Account`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  subscribe(
    listener: (coMap: Account<P, R, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Account`:  Value creation

<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: M["_shape"],
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
Creates a new `CoMap` within this group, with the specified specialized
`CoMap` type `M` and optional static metadata.



### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
Creates a new `CoList` within this group, with the specified specialized
`CoList` type `L` and optional static metadata.



### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `Account`:  Time travel

<details>
<summary><b><code>.atTime(time)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  atTime(
    time: number
  ): Account<P, R, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>

<br/>

### `Account`:  Edit history

<details>
<summary><b><code>.nthEditAt(key, n)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  nthEditAt<K extends Object>(
    key: K,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastEditAt(key)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  lastEditAt<K extends Object>(
    key: K
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.editsAt(key)</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  editsAt<K extends Object>(
    key: K
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: GroupShape<P, R>[K],
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>

<br/>

### `Account`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  id: CoID<Account<P, R, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  type: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._shape</code></b> <sub><sup>from <code>Group</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  _shape: GroupShape<P, R>

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `Account`: Other



<details>
<summary><b><code>.getCurrentAgentID()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Account<P, R, Meta> {

  getCurrentAgentID(): AgentID {...}

}
```
TODO: document

undefined</details>











<details>
<summary><b><code>.edit(mutator)</code></b> <sub><sup>from <code>Group</code></sup></sub>  </summary>

```typescript
class Account<P, R, Meta> {

  edit(
    mutator: (mutable: MutableCoMap<GroupShape<P, R>, Meta>) => void
  ): Account<P, R, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>









----

## `Profile`

<sup>(class in `cojson`)</sup>

```typescript
export class Profile<Shape extends ProfileShape, Meta extends ProfileMeta> extends CoMap<Shape, Meta> {...}
```
A collaborative map with precise shape `Shape` and optional static metadata `Meta`



### `Profile`:  Reading

<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  keys<K extends string>(): K[] {...}

}
```
Get all keys currently in the map.



undefined</details>



<details>
<summary><b><code>.get(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  get<K extends string>(
    key: K
  ): undefined | Shape[K] {...}

}
```
Returns the current value for the given key.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.asObject()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  asObject(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.toJSON()</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  toJSON(): {
    [K in string]: Shape[K]
  } {...}

}
```
TODO: document

undefined</details>

<br/>

### `Profile`:  Editing

<details>
<summary><b><code>.set(key, value, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  set<K extends string>(
    key: K,
    value: Shape[K],
    privacy?: "private" | "trusting"
  ): Profile<Shape, Meta> {...}

}
```
Returns a new version of this CoMap with a new value for the given key.

If `privacy` is `"private"` **(default)**, both `key` and `value` are encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, both `key` and `value` are stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  set(
    kv: {
      [K in string]: Shape[K]
    },
    privacy?: "private" | "trusting"
  ): Profile<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  delete(
    key: keyof Shape & string,
    privacy?: "private" | "trusting" = "private"
  ): Profile<Shape, Meta> {...}

}
```
Returns a new version of this CoMap with the given key deleted (setting it to undefined).

If `privacy` is `"private"` **(default)**, `key` is encrypted in the transaction, only readable by other members of the group this `CoMap` belongs to. Not even sync servers can see the content in plaintext.

If `privacy` is `"trusting"`, `key` is stored in plaintext in the transaction, visible to everyone who gets a hold of it, including sync servers.



### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  mutate(
    mutator: (mutable: MutableCoMap<Shape, Meta>) => void
  ): Profile<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Profile`:  Subscription

<details>
<summary><b><code>.subscribe(listener)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  subscribe(
    listener: (coMap: Profile<Shape, Meta>) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `Profile`:  Time travel

<details>
<summary><b><code>.atTime(time)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  atTime(
    time: number
  ): Profile<Shape, Meta> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>

<br/>

### `Profile`:  Edit history

<details>
<summary><b><code>.nthEditAt(key, n)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  nthEditAt<K extends string>(
    key: K,
    n: number
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `n` | TODO: document  |

</details>



<details>
<summary><b><code>.lastEditAt(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  lastEditAt<K extends string>(
    key: K
  ): undefined | {
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.editsAt(key)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  editsAt<K extends string>(
    key: K
  ): Generator<{
    by: AgentID | AccountID,
    tx: TransactionID,
    at: Date,
    value?: Shape[K],
  }, void, unknown> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>

<br/>

### `Profile`:  Meta

<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  id: CoID<Profile<Shape, Meta>>

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  type: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.core</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>._shape</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class Profile<Shape, Meta> {

  _shape: Shape

}
```
TODO: document

</details>



<details>
<summary><b><code>.headerMeta</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  get headerMeta(): Meta {...}

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  get group(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>

<br/>

### `Profile`: Other



<details>
<summary><b><code>.edit(mutator)</code></b> <sub><sup>from <code>CoMap</code></sup></sub>  </summary>

```typescript
class Profile<Shape, Meta> {

  edit(
    mutator: (mutable: MutableCoMap<Shape, Meta>) => void
  ): Profile<Shape, Meta> {...}

}
```




### Parameters:

| name | description |
| ----: | ---- |


</details>









----

## `CoValueCore`

<sup>(class in `cojson`)</sup>

```typescript
export class CoValueCore {...}
```
TODO: document

### `CoValueCore`: Accessors

<details>
<summary><b><code>.sessionLogs</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  get sessionLogs(): Map<SessionID, SessionLog> {...}

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  get meta(): JsonValue {...}

}
```
TODO: document

</details>

<br/>

### `CoValueCore`: Constructors

<details>
<summary><b><code>new CoValueCore</code></b>(header, node, internalInitSessions?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  constructor(
    header: CoValueHeader,
    node: LocalNode,
    internalInitSessions?: Map<SessionID, SessionLog> = ...
  ): CoValueCore {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `header` | TODO: document  |
| `node` | TODO: document  |
| `internalInitSessions?` | TODO: document  |

</details>

<br/>

### `CoValueCore`: Methods

<details>
<summary><b><code>.testWithDifferentAccount(account, currentSessionID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  testWithDifferentAccount(
    account: GeneralizedControlledAccount,
    currentSessionID: SessionID
  ): CoValueCore {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |
| `currentSessionID` | TODO: document  |

</details>



<details>
<summary><b><code>.knownState()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  knownState(): CoValueKnownState {...}

}
```
TODO: document

undefined</details>





<details>
<summary><b><code>.nextTransactionID()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  nextTransactionID(): TransactionID {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.tryAddTransactions(sessionID, newTransactions, givenExpectedNewHash, newSignature)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  tryAddTransactions(
    sessionID: SessionID,
    newTransactions: Transaction[],
    givenExpectedNewHash: undefined | `hash_z${string}`,
    newSignature: `signature_z${string}`
  ): boolean {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `newTransactions` | TODO: document  |
| `givenExpectedNewHash` | TODO: document  |
| `newSignature` | TODO: document  |

</details>



<details>
<summary><b><code>.tryAddTransactionsAsync(sessionID, newTransactions, givenExpectedNewHash, newSignature)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  tryAddTransactionsAsync(
    sessionID: SessionID,
    newTransactions: Transaction[],
    givenExpectedNewHash: undefined | `hash_z${string}`,
    newSignature: `signature_z${string}`
  ): Promise<boolean> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `newTransactions` | TODO: document  |
| `givenExpectedNewHash` | TODO: document  |
| `newSignature` | TODO: document  |

</details>



<details>
<summary><b><code>.doAddTransactions(sessionID, newTransactions, newSignature, expectedNewHash, newStreamingHash)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  doAddTransactions(
    sessionID: SessionID,
    newTransactions: Transaction[],
    newSignature: `signature_z${string}`,
    expectedNewHash: `hash_z${string}`,
    newStreamingHash: StreamingHash
  ): void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `newTransactions` | TODO: document  |
| `newSignature` | TODO: document  |
| `expectedNewHash` | TODO: document  |
| `newStreamingHash` | TODO: document  |

</details>



<details>
<summary><b><code>.subscribe(listener)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  subscribe(
    listener: (content: CoValue) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.expectedNewHashAfter(sessionID, newTransactions)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  expectedNewHashAfter(
    sessionID: SessionID,
    newTransactions: Transaction[]
  ): {
    expectedNewHash: `hash_z${string}`,
    newStreamingHash: StreamingHash,
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `newTransactions` | TODO: document  |

</details>



<details>
<summary><b><code>.expectedNewHashAfterAsync(sessionID, newTransactions)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  expectedNewHashAfterAsync(
    sessionID: SessionID,
    newTransactions: Transaction[]
  ): Promise<{
    expectedNewHash: `hash_z${string}`,
    newStreamingHash: StreamingHash,
  }> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `sessionID` | TODO: document  |
| `newTransactions` | TODO: document  |

</details>



<details>
<summary><b><code>.makeTransaction(changes, privacy)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  makeTransaction(
    changes: JsonValue[],
    privacy: "private" | "trusting"
  ): boolean {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `changes` | TODO: document  |
| `privacy` | TODO: document  |

</details>



<details>
<summary><b><code>.getCurrentContent(options?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getCurrentContent(
    options?: {
      ignorePrivateTransactions: true,
    }
  ): CoValue {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `options.ignorePrivateTransactions` | TODO: document |

</details>



<details>
<summary><b><code>.getValidSortedTransactions(options?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getValidSortedTransactions(
    options?: {
      ignorePrivateTransactions: true,
    }
  ): DecryptedTransaction[] {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `options.ignorePrivateTransactions` | TODO: document |

</details>



<details>
<summary><b><code>.getCurrentReadKey()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getCurrentReadKey(): {
    secret: undefined | `keySecret_z${string}`,
    id: `key_z${string}`,
  } {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.getReadKey(keyID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getReadKey(
    keyID: `key_z${string}`
  ): undefined | `keySecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `keyID` | TODO: document  |

</details>



<details>
<summary><b><code>.getUncachedReadKey(keyID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getUncachedReadKey(
    keyID: `key_z${string}`
  ): undefined | `keySecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `keyID` | TODO: document  |

</details>



<details>
<summary><b><code>.getGroup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getGroup(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.getTx(txID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getTx(
    txID: TransactionID
  ): undefined | Transaction {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `txID` | TODO: document  |

</details>



<details>
<summary><b><code>.newContentSince(knownState)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  newContentSince(
    knownState: undefined | CoValueKnownState
  ): undefined | NewContentMessage[] {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `knownState` | TODO: document  |

</details>



<details>
<summary><b><code>.getDependedOnCoValues()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  getDependedOnCoValues(): `co_z${string}`[] {...}

}
```
TODO: document

undefined</details>



<br/>

### `CoValueCore`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  id: `co_z${string}`

}
```
TODO: document

</details>



<details>
<summary><b><code>.node</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  node: LocalNode

}
```
TODO: document

</details>



<details>
<summary><b><code>.header</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  header: CoValueHeader

}
```
TODO: document

</details>



<details>
<summary><b><code>._sessionLogs</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _sessionLogs: Map<SessionID, SessionLog>

}
```
TODO: document

</details>



<details>
<summary><b><code>.listeners</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  listeners: Set<(content: CoValue) => void>

}
```
TODO: document

</details>



<details>
<summary><b><code>._decryptionCache</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _decryptionCache: {
    [key: Encrypted<JsonValue[], JsonValue>]: JsonValue[] | undefined }

}
```
TODO: document

</details>



<details>
<summary><b><code>._cachedContent</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _cachedContent: CoValue

}
```
TODO: document

</details>



<details>
<summary><b><code>.currentlyAsyncApplyingTxDone</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  currentlyAsyncApplyingTxDone: Promise<void>

}
```
TODO: document

</details>



<details>
<summary><b><code>._cachedKnownState</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _cachedKnownState: CoValueKnownState

}
```
TODO: document

</details>



<details>
<summary><b><code>._cachedDependentOn</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _cachedDependentOn: `co_z${string}`[]

}
```
TODO: document

</details>



<details>
<summary><b><code>._cachedNewContentSinceEmpty</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class CoValueCore {

  _cachedNewContentSinceEmpty: NewContentMessage[]

}
```
TODO: document

</details>



----

## `Media`

<sup>(namespace in `cojson`)</sup>

```typescript
export namespace Media {...}
```
TODO: document

### `Media`: Type Aliases

<details>
<summary><b><code>Media.ImageDefinition</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
namespace Media {

  ImageDefinition: CoMap<{  originalSize: [number, number],
    placeholderDataURL?: string,
    [res: `${number}x${number}`]: BinaryCoStream["id"] }>

}
```
TODO: document

</details>



----

## `CoValue`

<sup>(interface in `cojson`)</sup>

```typescript
export interface CoValue {...}
```
TODO: document

### `CoValue`: Methods

<details>
<summary><b><code>.toJSON()</code></b>  </summary>

```typescript
interface CoValue {

  toJSON(): JsonValue {...}

}
```
Returns an immutable JSON presentation of this `CoValue`



undefined</details>



<details>
<summary><b><code>.atTime(time)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface CoValue {

  atTime(
    time: number
  ): CoValue {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `time` | TODO: document  |

</details>



<details>
<summary><b><code>.subscribe(listener)</code></b>  </summary>

```typescript
interface CoValue {

  subscribe(
    listener: (coValue: CoValue) => void
  ): () => void {...}

}
```
Lets you subscribe to future updates to this CoValue (whether made locally or by other users).

Takes a listener function that will be called with the current state for each update.

Returns an unsubscribe function.

Used internally by `useTelepathicData()` for reactive updates on changes to a `CoValue`.



### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `CoValue`: Properties

<details>
<summary><b><code>.id</code></b>  </summary>

```typescript
interface CoValue {

  id: CoID<CoValue>

}
```
The `CoValue`'s (precisely typed) `CoID`



</details>



<details>
<summary><b><code>.core</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface CoValue {

  core: CoValueCore

}
```
TODO: document

</details>



<details>
<summary><b><code>.type</code></b>  </summary>

```typescript
interface CoValue {

  type: string

}
```
Specifies which kind of `CoValue` this is



</details>



<details>
<summary><b><code>.headerMeta</code></b>  </summary>

```typescript
interface CoValue {

  headerMeta: null | JsonObject

}
```
The `CoValue`'s (precisely typed) static metadata



</details>



<details>
<summary><b><code>.group</code></b>  </summary>

```typescript
interface CoValue {

  group: Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>

}
```
The `Group` this `CoValue` belongs to (determining permissions)



</details>



----

## `Peer`

<sup>(interface in `cojson`)</sup>

```typescript
export interface Peer {...}
```
TODO: document

### `Peer`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  id: string

}
```
TODO: document

</details>



<details>
<summary><b><code>.incoming</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  incoming: ReadableStream<SyncMessage>

}
```
TODO: document

</details>



<details>
<summary><b><code>.outgoing</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  outgoing: WritableStream<SyncMessage>

}
```
TODO: document

</details>



<details>
<summary><b><code>.role</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  role: "peer" | "server" | "client"

}
```
TODO: document

</details>



<details>
<summary><b><code>.delayOnError</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  delayOnError: number

}
```
TODO: document

</details>



<details>
<summary><b><code>.priority</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface Peer {

  priority: number

}
```
TODO: document

</details>



----

## `Value`

<sup>(type alias in `cojson`)</sup>

```typescript
export type Value = JsonValue | AnyCoValue
```
TODO: doc generator not implemented yet 2097152

----

## `Role`

<sup>(type alias in `cojson`)</sup>

```typescript
export type Role = "reader" | "writer" | "admin" | "revoked" | "adminInvite" | "writerInvite" | "readerInvite"
```
TODO: doc generator not implemented yet 2097152

----

## `Everyone`

<sup>(type alias in `cojson`)</sup>

```typescript
export type Everyone = "everyone"
```
TODO: doc generator not implemented yet 2097152

----

## `CoID`

<sup>(type alias in `cojson`)</sup>

```typescript
export type CoID<T extends CoValue> = RawCoID & {
  __type: T,
}
```
TODO: doc generator not implemented yet 2097152

----

## `AnyCoValue`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AnyCoValue = CoMap | Group | Account | Profile | CoList | CoStream | BinaryCoStream
```
TODO: doc generator not implemented yet 2097152

----

## `AccountID`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AccountID = CoID<Account>
```
TODO: doc generator not implemented yet 2097152

----

## `AccountMeta`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AccountMeta = {
  type: "account",
}
```
TODO: doc generator not implemented yet 2097152

----

## `AccountMigration`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AccountMigration<P extends Profile, R extends CoMap, Meta extends AccountMeta> = (account: ControlledAccount<P, R, Meta>, profile: P) => void
```
TODO: doc generator not implemented yet 2097152

----

## `ProfileMeta`

<sup>(type alias in `cojson`)</sup>

```typescript
export type ProfileMeta = {
  type: "profile",
}
```
TODO: doc generator not implemented yet 2097152

----

## `SessionID`

<sup>(type alias in `cojson`)</sup>

```typescript
export type SessionID = SessionID
```
TODO: doc generator not implemented yet 2097152

----

## `JsonValue`

<sup>(type alias in `cojson`)</sup>

```typescript
export type JsonValue = JsonAtom | JsonArray | JsonObject | RawCoID
```
TODO: doc generator not implemented yet 2097152

----

## `BinaryStreamInfo`

<sup>(type alias in `cojson`)</sup>

```typescript
export type BinaryStreamInfo = {
  mimeType: string,
  fileName?: string,
  totalSizeBytes?: number,
}
```
TODO: doc generator not implemented yet 2097152

----

## `BinaryCoStreamMeta`

<sup>(type alias in `cojson`)</sup>

```typescript
export type BinaryCoStreamMeta = JsonObject & {
  type: "binary",
}
```
TODO: doc generator not implemented yet 2097152

----

## `AgentID`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AgentID = AgentID
```
TODO: doc generator not implemented yet 2097152

----

## `AgentSecret`

<sup>(type alias in `cojson`)</sup>

```typescript
export type AgentSecret = AgentSecret
```
TODO: doc generator not implemented yet 2097152

----

## `InviteSecret`

<sup>(type alias in `cojson`)</sup>

```typescript
export type InviteSecret = InviteSecret
```
TODO: doc generator not implemented yet 2097152

----

## `SyncMessage`

<sup>(type alias in `cojson`)</sup>

```typescript
export type SyncMessage = LoadMessage | KnownStateMessage | NewContentMessage | DoneMessage
```
TODO: doc generator not implemented yet 2097152

----

## `EVERYONE`

<sup>(variable in `cojson`)</sup>

```typescript
export  EVERYONE
```
TODO: doc generator not implemented yet 32

----

## `cojsonReady`

<sup>(variable in `cojson`)</sup>

```typescript
export  cojsonReady
```
TODO: doc generator not implemented yet 32

----

## `MAX_RECOMMENDED_TX_SIZE`

<sup>(variable in `cojson`)</sup>

```typescript
export  MAX_RECOMMENDED_TX_SIZE
```
TODO: doc generator not implemented yet 32


# jazz-browser

## `createBrowserNode({auth, syncAddress?, reconnectionTimeout?, migration?})`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function createBrowserNode({
  auth: AuthProvider,
  syncAddress?: string,
  reconnectionTimeout?: number,
  migration?: AccountMigration,
}): Promise<BrowserNodeHandle>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `__namedParameters.auth` | TODO: document |
| `__namedParameters.syncAddress?` | TODO: document |
| `__namedParameters.reconnectionTimeout?` | TODO: document |
| `__namedParameters.migration?` | TODO: document |





----

## `createInviteLink(value, role, {baseURL?, valueHint?}?)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function createInviteLink<C extends CoValue>(value: C | Resolved<C>, role: "reader" | "writer" | "admin", {
  baseURL?: string,
  valueHint?: string,
}): string
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `role` | TODO: document  |
| `__namedParameters.baseURL?` | TODO: document |
| `__namedParameters.valueHint?` | TODO: document |





----

## `parseInviteLink(inviteURL)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function parseInviteLink<C extends CoValue>(inviteURL: string): {
  valueID: CoID<C>,
  inviteSecret: InviteSecret,
  valueHint?: string,
} | undefined
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `inviteURL` | TODO: document  |





----

## `consumeInviteLinkFromWindowLocation(node)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function consumeInviteLinkFromWindowLocation<C extends CoValue>(node: LocalNode): Promise<{
  valueID: CoID<C>,
  inviteSecret: string,
} | undefined>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `node` | TODO: document  |





----

## `createBinaryStreamFromBlob(blob, inGroup, meta?, onProgress?)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function createBinaryStreamFromBlob<C extends BinaryCoStream<BinaryCoStreamMeta>>(blob: Blob | File, inGroup: Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> | ResolvedGroup<Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>>, meta: C["headerMeta"], onProgress: (progress: number) => void): Promise<C>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `blob` | TODO: document  |
| `inGroup` | TODO: document  |
| `meta?` | TODO: document  |






----

## `readBlobFromBinaryStream(streamId, node, allowUnfinished?, onProgress?)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function readBlobFromBinaryStream<C extends BinaryCoStream<BinaryCoStreamMeta>>(streamId: CoID<C>, node: LocalNode, allowUnfinished: boolean, onProgress: (progress: number) => void): Promise<Blob | undefined>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `streamId` | TODO: document  |
| `node` | TODO: document  |
| `allowUnfinished?` | TODO: document  |






----

## `autoSub(id, node, callback)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function autoSub<C extends CoValue>(id: undefined | CoID<C>, node: LocalNode, callback: (resolved: undefined | Resolved<C>) => void): () => void
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |
| `node` | TODO: document  |






----

## `autoSubResolution(id, drillDown, node)`

<sup>(function in `jazz-browser`)</sup>

```typescript
export function autoSubResolution<A extends Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>, O extends ResolvedAccount<Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>> | ResolvedGroup<Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>> | ResolvedCoMap<CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>> | ResolvedCoList<CoList<JsonValue, null | JsonObject>> | ResolvedCoStream<CoStream<JsonValue, null | JsonObject>>>(id: "me", drillDown: (root: ResolvedAccount<A>) => undefined | O, node: LocalNode): Promise<O>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |

| `node` | TODO: document  |





----

## `BrowserDemoAuth`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class BrowserDemoAuth implements AuthProvider {...}
```
TODO: document

### `BrowserDemoAuth`: Constructors

<details>
<summary><b><code>new BrowserDemoAuth</code></b>(driver, appName)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BrowserDemoAuth {

  constructor(
    driver: BrowserDemoAuthDriver,
    appName: string
  ): BrowserDemoAuth {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `driver` | TODO: document  |
| `appName` | TODO: document  |

</details>

<br/>

### `BrowserDemoAuth`: Methods

<details>
<summary><b><code>.createNode(getSessionFor, initialPeers, migration?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BrowserDemoAuth {

  createNode(
    getSessionFor: SessionProvider,
    initialPeers: Peer[],
    migration?: AccountMigration
  ): Promise<LocalNode> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `getSessionFor` | TODO: document  |
| `initialPeers` | TODO: document  |
| `migration?` | TODO: document  |

</details>

<br/>

### `BrowserDemoAuth`: Properties

<details>
<summary><b><code>.driver</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BrowserDemoAuth {

  driver: BrowserDemoAuthDriver

}
```
TODO: document

</details>



<details>
<summary><b><code>.appName</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class BrowserDemoAuth {

  appName: string

}
```
TODO: document

</details>



----

## `ResolvedCoStream`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class ResolvedCoStream<S extends CoStream> {...}
```
TODO: document

### `ResolvedCoStream`: Constructors

<br/>

### `ResolvedCoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  push(
    item: S["_item"],
    privacy?: "private" | "trusting"
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  mutate(
    mutator: (mutable: MutableCoStream<S["_item"], S["headerMeta"]>) => void
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoStream`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  id: CoID<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  coValueType: "costream"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  meta: ResolvedCoStreamMeta<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.perAccount</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perAccount: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.perSession</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perSession: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.me</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  me: ResolvedCoStreamEntry<S["_item"]>

}
```
TODO: document

</details>



----

## `ResolvedCoList`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class ResolvedCoList<L extends CoList> extends Array<ValueOrResolvedRef<L["_item"]>> {...}
```
TODO: document

### `ResolvedCoList`: Constructors

<br/>

### `ResolvedCoList`: Methods







<details>
<summary><b><code>.append(item, after?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  append(
    item: L["_item"],
    after?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `after?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.prepend(item, before?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  prepend(
    item: L["_item"],
    before?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `before?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(at, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  delete(
    at: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `at` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mutate(
    mutator: (mutable: MutableCoList<L["_item"], L["headerMeta"]>) => void
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>























<details>
<summary><b><code>.toString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toString(): string {...}

}
```
Returns a string representation of an array.



undefined</details>



<details>
<summary><b><code>.toLocaleString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toLocaleString(): string {...}

}
```
Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.



undefined</details>



<details>
<summary><b><code>.join(separator?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  join(
    separator?: string
  ): string {...}

}
```
Adds all the elements of an array into a string, separated by the specified separator string.



### Parameters:

| name | description |
| ----: | ---- |
| `separator?` | A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma. |

</details>



<details>
<summary><b><code>.slice(start?, end?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  slice(
    start?: number,
    end?: number
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns a copy of a section of an array.
For both start and end, a negative index can be used to indicate an offset from the end of the array.
For example, -2 refers to the second to last element of the array.



### Parameters:

| name | description |
| ----: | ---- |
| `start?` | The beginning index of the specified portion of the array.
If start is undefined, then the slice begins at index 0. |
| `end?` | The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.
If end is undefined, then the slice extends to the end of the array. |

</details>



<details>
<summary><b><code>.indexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  indexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the first occurrence of a value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0. |

</details>



<details>
<summary><b><code>.lastIndexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  lastIndexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): COMPLEX_TYPE_predicate {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.some(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  some(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether the specified callback function returns true for any element of an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.forEach(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  forEach(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => void,
    thisArg?: any
  ): void {...}

}
```
Performs the specified action for each element in an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.map(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  map<U>(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    thisArg?: any
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array, and returns an array that contains the results.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): S[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.reduce(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  find<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the first element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  find(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the first element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.entries()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  entries(): IterableIterator<[number, ValueOrResolvedRef<L["_item"]>]> {...}

}
```
Returns an iterable of key, value pairs for every entry in the array



undefined</details>



<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  keys(): IterableIterator<number> {...}

}
```
Returns an iterable of keys in the array



undefined</details>



<details>
<summary><b><code>.values()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  values(): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Returns an iterable of values in the array



undefined</details>



<details>
<summary><b><code>.includes(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  includes(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): boolean {...}

}
```
Determines whether an array includes a certain element, returning true or false as appropriate.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The element to search for. |
| `fromIndex?` | The position in this array at which to begin searching for searchElement. |

</details>



<details>
<summary><b><code>.flatMap(callback, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flatMap<U, This>(
    callback: (this: This, value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U | readonly U[],
    thisArg?: This
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array. Then, flattens the result into
a new array.
This is identical to a map followed by flat with depth 1.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callback function. If
thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.flat(this, depth?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flat<A, D extends number>(
    this: A,
    depth?: D
  ): FlatArray<A, D>[] {...}

}
```
Returns a new array with all sub-array elements concatenated into it recursively up to the
specified depth.



### Parameters:

| name | description |
| ----: | ---- |
| `this` | TODO: document  |
| `depth?` | The maximum recursion depth |

</details>



<details>
<summary><b><code>.at(index)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  at(
    index: number
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
Returns the item located at the specified index.



### Parameters:

| name | description |
| ----: | ---- |
| `index` | The zero-based index of the desired code unit. A negative index will count back from the last item. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLast<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the last element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  findLast(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findLastIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLastIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the last element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.[iterator]()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [iterator](): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Iterator



undefined</details>

<br/>

### `ResolvedCoList`: Properties

<details>
<summary><b><code>ResolvedCoList.[species]</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  [species]: ArrayConstructor

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  id: CoID<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  coValueType: "colist"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  meta: ResolvedCoListMeta<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.mapDeferred</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mapDeferred: (mapper: (item: {
    loaded: boolean,
    id: L["_item"] extends CoID<CoValue> ? any[any] : never,
    value((): ValueOrResolvedRef<L["_item"]>,
  }, idx: number) => O) => O[]

}
```
TODO: document

</details>



<details>
<summary><b><code>.length</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  length: number

}
```
Gets or sets the length of the array. This is a number one higher than the highest index in the array.



</details>



<details>
<summary><b><code>.[unscopables]</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [unscopables]: {
    length?: boolean,
    toString?: ,
    toLocaleString?: ,
    pop?: ,
    push?: ,
    concat?: ,
    join?: ,
    reverse?: ,
    shift?: ,
    slice?: ,
    sort?: ,
    splice?: ,
    unshift?: ,
    indexOf?: ,
    lastIndexOf?: ,
    every?: ,
    some?: ,
    forEach?: ,
    map?: ,
    filter?: ,
    reduce?: ,
    reduceRight?: ,
    find?: ,
    findIndex?: ,
    fill?: ,
    copyWithin?: ,
    entries?: ,
    keys?: ,
    values?: ,
    includes?: ,
    flatMap?: ,
    flat?: ,
    at?: ,
    findLast?: ,
    findLastIndex?: ,
    [iterator]?: ,
    [unscopables]?: boolean,
  }

}
```
Is an object whose properties have the value 'true'
when they will be absent when used in a 'with' statement.



</details>



----

## `ResolvedCoMapBase`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class ResolvedCoMapBase<M extends CoMap> {...}
```
TODO: document

### `ResolvedCoMapBase`: Constructors

<br/>

### `ResolvedCoMapBase`: Methods



<details>
<summary><b><code>.get(key)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  get<K extends string>(
    key: K
  ): ResolvedCoMap<M>[K] {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.set(key, value, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set<K extends string>(
    key: K,
    value: M["_shape"][K],
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set(
    kv: {
      [K in string]: M["_shape"][K]
    },
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  delete(
    key: keyof M["_shape"] & string,
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  mutate(
    mutator: (mutable: MutableCoMap<M["_shape"], M["headerMeta"]>) => void
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoMapBase`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  id: CoID<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  coValueType: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  meta: ResolvedCoMapMeta<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.as</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  as: (extension: AutoSubExtension<M, O>) => undefined | O

}
```
TODO: document

</details>



----

## `ResolvedAccount`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class ResolvedAccount<A extends Account> extends ResolvedGroup<A> {...}
```
TODO: document

### `ResolvedAccount`: Constructors

<details>
<summary><b><code>new ResolvedAccount</code></b>(account, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  constructor<A extends Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>>(
    account: A,
    autoSubContext: AutoSubContext
  ): ResolvedAccount<A> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Methods

<details>
<summary><b><code>.createGroup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createGroup(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.acceptInvite(groupOrOwnedValueID, inviteSecret)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  acceptInvite<T extends CoValue>(
    groupOrOwnedValueID: CoID<T>,
    inviteSecret: `inviteSecret_z${string}`
  ): Promise<void> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `groupOrOwnedValueID` | TODO: document  |
| `inviteSecret` | TODO: document  |

</details>



<details>
<summary><b><code>.addMember(accountID, role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  removeMember(
    accountID: AccountID
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Properties

<details>
<summary><b><code>.isMe</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  isMe: boolean

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  id: CoID<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  meta: ResolvedGroupMeta<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  profile: ValueOrResolvedRef<A["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  root: ValueOrResolvedRef<A["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `ResolvedGroup`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class ResolvedGroup<G extends Group> {...}
```
TODO: document

### `ResolvedGroup`: Constructors

<details>
<summary><b><code>new ResolvedGroup</code></b>(group, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  constructor<G extends Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>>(
    group: G,
    autoSubContext: AutoSubContext
  ): ResolvedGroup<G> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `group` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Methods

<details>
<summary><b><code>.addMember(accountID, role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  removeMember(
    accountID: AccountID
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  id: CoID<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  meta: ResolvedGroupMeta<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  profile: ValueOrResolvedRef<G["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  root: ValueOrResolvedRef<G["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `AutoSubContext`

<sup>(class in `jazz-browser`)</sup>

```typescript
export class AutoSubContext {...}
```
TODO: document

### `AutoSubContext`: Constructors

<details>
<summary><b><code>new AutoSubContext</code></b>(node, onUpdate)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  constructor(
    node: LocalNode,
    onUpdate: () => void
  ): AutoSubContext {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `node` | TODO: document  |


</details>

<br/>

### `AutoSubContext`: Methods

<details>
<summary><b><code>.autoSub(valueID, alsoRender, _path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  autoSub<T extends CoValue>(
    valueID: CoID<T>,
    alsoRender: CoID<CoValue>[],
    _path: string
  ): undefined | Resolved<T> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `valueID` | TODO: document  |
| `alsoRender` | TODO: document  |
| `_path` | TODO: document  |

</details>



<details>
<summary><b><code>.subscribeIfCoID(value, alsoRender, path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  subscribeIfCoID<T extends undefined | JsonValue>(
    value: T,
    alsoRender: CoID<CoValue>[],
    path: string
  ): T extends CoID<C> ? undefined | Resolved<C> : T {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `alsoRender` | TODO: document  |
| `path` | TODO: document  |

</details>



<details>
<summary><b><code>.valueOrResolvedRefPropertyDescriptor(value, alsoRender, path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  valueOrResolvedRefPropertyDescriptor<T extends undefined | JsonValue>(
    value: T,
    alsoRender: CoID<CoValue>[],
    path: string
  ): T extends CoID<C>
    ? {
      get((): undefined | Resolved<C>,
    }
    : {
      value: T,
    } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `alsoRender` | TODO: document  |
| `path` | TODO: document  |

</details>



<details>
<summary><b><code>.defineResolvedRefPropertiesIn(obj, subqueryProps, alsoRender)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  defineResolvedRefPropertiesIn<O extends object, P extends {
    [key: string]: {
      value: JsonValue | undefined,
      enumerable: boolean,
    } }>(
    obj: O,
    subqueryProps: P,
    alsoRender: CoID<CoValue>[]
  ): O & {
    [Key in string | number | symbol]: ValueOrResolvedRef<P[Key]["value"]>
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `obj` | TODO: document  |
| `subqueryProps` | TODO: document  |
| `alsoRender` | TODO: document  |

</details>



<details>
<summary><b><code>.getOrCreateExtension(valueID, extension)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  getOrCreateExtension<T extends CoValue, O>(
    valueID: CoID<T>,
    extension: AutoSubExtension<T, O>
  ): undefined | O {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `valueID` | TODO: document  |
| `extension` | TODO: document  |

</details>



<details>
<summary><b><code>.cleanup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  cleanup(): void {...}

}
```
TODO: document

undefined</details>

<br/>

### `AutoSubContext`: Properties

<details>
<summary><b><code>.values</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  values: {
    [id: CoID<CoValue>]: {
      lastUpdate: CoValue | undefined,
      lastLoaded: Resolved<CoValue> | undefined,
      render: () => void,
      unsubscribe: () => void,
    } }

}
```
TODO: document

</details>



<details>
<summary><b><code>.extensions</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  extensions: {
    [id: `${CoID<CoValue>}_${string}`]: {
      lastOutput: unknown,
      unsubscribe: () => void,
    } }

}
```
TODO: document

</details>



<details>
<summary><b><code>.node</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  node: LocalNode

}
```
TODO: document

</details>



<details>
<summary><b><code>.onUpdate</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  onUpdate: () => void

}
```
TODO: document

</details>



----

## `AuthProvider`

<sup>(interface in `jazz-browser`)</sup>

```typescript
export interface AuthProvider {...}
```
TODO: document

### `AuthProvider`: Methods

<details>
<summary><b><code>.createNode(getSessionFor, initialPeers, migration?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface AuthProvider {

  createNode(
    getSessionFor: SessionProvider,
    initialPeers: Peer[],
    migration?: AccountMigration
  ): Promise<LocalNode> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `getSessionFor` | TODO: document  |
| `initialPeers` | TODO: document  |
| `migration?` | TODO: document  |

</details>



----

## `BrowserDemoAuthDriver`

<sup>(interface in `jazz-browser`)</sup>

```typescript
export interface BrowserDemoAuthDriver {...}
```
TODO: document

### `BrowserDemoAuthDriver`: Properties

<details>
<summary><b><code>.onReady</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface BrowserDemoAuthDriver {

  onReady: (next: {
    signUp: (username: string) => Promise<void>,
    existingUsers: string[],
    logInAs: (existingUser: string) => Promise<void>,
  }) => void

}
```
TODO: document

</details>



<details>
<summary><b><code>.onSignedIn</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface BrowserDemoAuthDriver {

  onSignedIn: (next: {
    logOut: () => void,
  }) => void

}
```
TODO: document

</details>



----

## `AutoSubExtension`

<sup>(interface in `jazz-browser`)</sup>

```typescript
export interface AutoSubExtension<T extends CoValue, O> {...}
```
TODO: document

### `AutoSubExtension`: Methods

<details>
<summary><b><code>.subscribe(base, autoSubContext, onUpdate)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface AutoSubExtension<T, O> {

  subscribe(
    base: T,
    autoSubContext: AutoSubContext,
    onUpdate: (value: O) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `base` | TODO: document  |
| `autoSubContext` | TODO: document  |


</details>

<br/>

### `AutoSubExtension`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface AutoSubExtension<T, O> {

  id: string

}
```
TODO: document

</details>



----

## `BrowserNodeHandle`

<sup>(type alias in `jazz-browser`)</sup>

```typescript
export type BrowserNodeHandle = {
  node: LocalNode,
  done: () => void,
}
```
TODO: doc generator not implemented yet 2097152

----

## `SessionProvider`

<sup>(type alias in `jazz-browser`)</sup>

```typescript
export type SessionProvider = (accountID: AccountID | AgentID) => Promise<SessionID>
```
TODO: doc generator not implemented yet 2097152

----

## `SessionHandle`

<sup>(type alias in `jazz-browser`)</sup>

```typescript
export type SessionHandle = {
  session: Promise<SessionID>,
  done: () => void,
}
```
TODO: doc generator not implemented yet 2097152

----

## `ResolvedCoMap`

<sup>(type alias in `jazz-browser`)</sup>

```typescript
export type ResolvedCoMap<M extends CoMap> = {
  [K in keyof M["_shape"] & string]: ValueOrResolvedRef<M["_shape"][K]>
} & ResolvedCoMapBase<M>
```
TODO: doc generator not implemented yet 2097152

----

## `Resolved`

<sup>(type alias in `jazz-browser`)</sup>

```typescript
export type Resolved<T extends CoValue> = T extends CoMap
  ? T extends Account ? ResolvedAccount<T> : T extends Group ? ResolvedGroup<T> : ResolvedCoMap<T>
  : T extends CoList
    ? ResolvedCoList<T>
    : T extends CoStream
      ? T["headerMeta"] extends {
        type: "binary",
      } ? never : ResolvedCoStream<T>
      : ResolvedAccount | ResolvedGroup | ResolvedCoMap<CoMap> | ResolvedCoList<CoList> | ResolvedCoStream<CoStream>
```
TODO: doc generator not implemented yet 2097152


# jazz-browser-media-images

## `createImage(imageBlobOrFile, inGroup, maxSize?)`

<sup>(function in `jazz-browser-media-images`)</sup>

```typescript
export function createImage(imageBlobOrFile: Blob | File, inGroup: Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> | ResolvedGroup<Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>>, maxSize: 1024 | 256 | 2048): Promise<Media.ImageDefinition>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `imageBlobOrFile` | TODO: document  |
| `inGroup` | TODO: document  |
| `maxSize?` | TODO: document  |





----

## `loadImage(imageDef, localNode, progressiveCallback)`

<sup>(function in `jazz-browser-media-images`)</sup>

```typescript
export function loadImage(imageDef: ImageDefinition | CoID<ImageDefinition> | {
  id: CoID<ImageDefinition>,
}, localNode: LocalNode, progressiveCallback: (update: LoadingImageInfo) => void): () => void
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `imageDef` | TODO: document  |
| `localNode` | TODO: document  |






----

## `LoadingImageInfo`

<sup>(type alias in `jazz-browser-media-images`)</sup>

```typescript
export type LoadingImageInfo = {
  originalSize?: [number, number],
  placeholderDataURL?: string,
  highestResSrc?: string,
  highestResSrcOrPlaceholder?: string,
}
```
TODO: doc generator not implemented yet 2097152

----

## `BrowserImage`

<sup>(variable in `jazz-browser-media-images`)</sup>

```typescript
export  BrowserImage
```
TODO: doc generator not implemented yet 32


# jazz-autosub

## `autoSub(id, node, callback)`

<sup>(function in `jazz-autosub`)</sup>

```typescript
export function autoSub<C extends CoValue>(id: undefined | CoID<C>, node: LocalNode, callback: (resolved: undefined | Resolved<C>) => void): () => void
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |
| `node` | TODO: document  |






----

## `autoSubResolution(id, drillDown, node)`

<sup>(function in `jazz-autosub`)</sup>

```typescript
export function autoSubResolution<A extends Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>, O extends ResolvedAccount<Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>> | ResolvedGroup<Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>> | ResolvedCoMap<CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>> | ResolvedCoList<CoList<JsonValue, null | JsonObject>> | ResolvedCoStream<CoStream<JsonValue, null | JsonObject>>>(id: "me", drillDown: (root: ResolvedAccount<A>) => undefined | O, node: LocalNode): Promise<O>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |

| `node` | TODO: document  |





----

## `ResolvedCoStream`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class ResolvedCoStream<S extends CoStream> {...}
```
TODO: document

### `ResolvedCoStream`: Constructors

<br/>

### `ResolvedCoStream`: Methods

<details>
<summary><b><code>.push(item, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  push(
    item: S["_item"],
    privacy?: "private" | "trusting"
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  mutate(
    mutator: (mutable: MutableCoStream<S["_item"], S["headerMeta"]>) => void
  ): S {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoStream`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  id: CoID<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  coValueType: "costream"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  meta: ResolvedCoStreamMeta<S>

}
```
TODO: document

</details>



<details>
<summary><b><code>.perAccount</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perAccount: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.perSession</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  perSession: [COMPLEX_TYPE_namedTupleMember, COMPLEX_TYPE_namedTupleMember][]

}
```
TODO: document

</details>



<details>
<summary><b><code>.me</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoStream<S> {

  me: ResolvedCoStreamEntry<S["_item"]>

}
```
TODO: document

</details>



----

## `ResolvedCoList`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class ResolvedCoList<L extends CoList> extends Array<ValueOrResolvedRef<L["_item"]>> {...}
```
TODO: document

### `ResolvedCoList`: Constructors

<br/>

### `ResolvedCoList`: Methods







<details>
<summary><b><code>.append(item, after?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  append(
    item: L["_item"],
    after?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `after?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.prepend(item, before?, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  prepend(
    item: L["_item"],
    before?: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `item` | TODO: document  |
| `before?` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(at, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  delete(
    at: number,
    privacy?: "private" | "trusting"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `at` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mutate(
    mutator: (mutable: MutableCoList<L["_item"], L["headerMeta"]>) => void
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>























<details>
<summary><b><code>.toString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toString(): string {...}

}
```
Returns a string representation of an array.



undefined</details>



<details>
<summary><b><code>.toLocaleString()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  toLocaleString(): string {...}

}
```
Returns a string representation of an array. The elements are converted to string using their toLocaleString methods.



undefined</details>



<details>
<summary><b><code>.join(separator?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  join(
    separator?: string
  ): string {...}

}
```
Adds all the elements of an array into a string, separated by the specified separator string.



### Parameters:

| name | description |
| ----: | ---- |
| `separator?` | A string used to separate one element of the array from the next in the resulting string. If omitted, the array elements are separated with a comma. |

</details>



<details>
<summary><b><code>.slice(start?, end?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  slice(
    start?: number,
    end?: number
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns a copy of a section of an array.
For both start and end, a negative index can be used to indicate an offset from the end of the array.
For example, -2 refers to the second to last element of the array.



### Parameters:

| name | description |
| ----: | ---- |
| `start?` | The beginning index of the specified portion of the array.
If start is undefined, then the slice begins at index 0. |
| `end?` | The end index of the specified portion of the array. This is exclusive of the element at the index 'end'.
If end is undefined, then the slice extends to the end of the array. |

</details>



<details>
<summary><b><code>.indexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  indexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the first occurrence of a value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0. |

</details>



<details>
<summary><b><code>.lastIndexOf(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  lastIndexOf(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): number {...}

}
```
Returns the index of the last occurrence of a specified value in an array, or -1 if it is not present.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The value to locate in the array. |
| `fromIndex?` | The array index at which to begin searching backward. If fromIndex is omitted, the search starts at the last index in the array. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): COMPLEX_TYPE_predicate {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.every(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  every(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether all the members of an array satisfy the specified test.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.some(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  some(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): boolean {...}

}
```
Determines whether the specified callback function returns true for any element of an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function.
If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.forEach(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  forEach(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => void,
    thisArg?: any
  ): void {...}

}
```
Performs the specified action for each element in an array.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.map(callbackfn, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  map<U>(
    callbackfn: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    thisArg?: any
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array, and returns an array that contains the results.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): S[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.filter(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  filter(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): ValueOrResolvedRef<L["_item"]>[] {...}

}
```
Returns the elements of an array that meet the condition specified in a callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.reduce(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduce(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduce(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduce<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |


</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  reduceRight(
    callbackfn: (previousValue: ValueOrResolvedRef<L["_item"]>, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => ValueOrResolvedRef<L["_item"]>,
    initialValue: ValueOrResolvedRef<L["_item"]>
  ): ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | TODO: document  |

</details>



<details>
<summary><b><code>.reduceRight(callbackfn, initialValue)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  reduceRight<U>(
    callbackfn: (previousValue: U, currentValue: ValueOrResolvedRef<L["_item"]>, currentIndex: number, array: ValueOrResolvedRef<L["_item"]>[]) => U,
    initialValue: U
  ): U {...}

}
```
Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.



### Parameters:

| name | description |
| ----: | ---- |

| `initialValue` | If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  find<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the first element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.find(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  find(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, obj: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the first element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.entries()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  entries(): IterableIterator<[number, ValueOrResolvedRef<L["_item"]>]> {...}

}
```
Returns an iterable of key, value pairs for every entry in the array



undefined</details>



<details>
<summary><b><code>.keys()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  keys(): IterableIterator<number> {...}

}
```
Returns an iterable of keys in the array



undefined</details>



<details>
<summary><b><code>.values()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  values(): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Returns an iterable of values in the array



undefined</details>



<details>
<summary><b><code>.includes(searchElement, fromIndex?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  includes(
    searchElement: ValueOrResolvedRef<L["_item"]>,
    fromIndex?: number
  ): boolean {...}

}
```
Determines whether an array includes a certain element, returning true or false as appropriate.



### Parameters:

| name | description |
| ----: | ---- |
| `searchElement` | The element to search for. |
| `fromIndex?` | The position in this array at which to begin searching for searchElement. |

</details>



<details>
<summary><b><code>.flatMap(callback, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flatMap<U, This>(
    callback: (this: This, value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => U | readonly U[],
    thisArg?: This
  ): U[] {...}

}
```
Calls a defined callback function on each element of an array. Then, flattens the result into
a new array.
This is identical to a map followed by flat with depth 1.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | An object to which the this keyword can refer in the callback function. If
thisArg is omitted, undefined is used as the this value. |

</details>



<details>
<summary><b><code>.flat(this, depth?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  flat<A, D extends number>(
    this: A,
    depth?: D
  ): FlatArray<A, D>[] {...}

}
```
Returns a new array with all sub-array elements concatenated into it recursively up to the
specified depth.



### Parameters:

| name | description |
| ----: | ---- |
| `this` | TODO: document  |
| `depth?` | The maximum recursion depth |

</details>



<details>
<summary><b><code>.at(index)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  at(
    index: number
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
Returns the item located at the specified index.



### Parameters:

| name | description |
| ----: | ---- |
| `index` | The zero-based index of the desired code unit. A negative index will count back from the last item. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLast<S extends JsonValue>(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => COMPLEX_TYPE_predicate,
    thisArg?: any
  ): undefined | S {...}

}
```
Returns the value of the last element in the array where predicate is true, and undefined
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.findLast(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  findLast(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): undefined | ValueOrResolvedRef<L["_item"]> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | TODO: document  |

</details>



<details>
<summary><b><code>.findLastIndex(predicate, thisArg?)</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  findLastIndex(
    predicate: (value: ValueOrResolvedRef<L["_item"]>, index: number, array: ValueOrResolvedRef<L["_item"]>[]) => unknown,
    thisArg?: any
  ): number {...}

}
```
Returns the index of the last element in the array where predicate is true, and -1
otherwise.



### Parameters:

| name | description |
| ----: | ---- |

| `thisArg?` | If provided, it will be used as the this value for each invocation of
predicate. If it is not provided, undefined is used instead. |

</details>



<details>
<summary><b><code>.[iterator]()</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [iterator](): IterableIterator<ValueOrResolvedRef<L["_item"]>> {...}

}
```
Iterator



undefined</details>

<br/>

### `ResolvedCoList`: Properties

<details>
<summary><b><code>ResolvedCoList.[species]</code></b> <sub><sup>from <code>Array</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  [species]: ArrayConstructor

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  id: CoID<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  coValueType: "colist"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  meta: ResolvedCoListMeta<L>

}
```
TODO: document

</details>



<details>
<summary><b><code>.mapDeferred</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoList<L> {

  mapDeferred: (mapper: (item: {
    loaded: boolean,
    id: L["_item"] extends CoID<CoValue> ? any[any] : never,
    value((): ValueOrResolvedRef<L["_item"]>,
  }, idx: number) => O) => O[]

}
```
TODO: document

</details>



<details>
<summary><b><code>.length</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  length: number

}
```
Gets or sets the length of the array. This is a number one higher than the highest index in the array.



</details>



<details>
<summary><b><code>.[unscopables]</code></b> <sub><sup>from <code>Array</code></sup></sub>  </summary>

```typescript
class ResolvedCoList<L> {

  [unscopables]: {
    length?: boolean,
    toString?: ,
    toLocaleString?: ,
    pop?: ,
    push?: ,
    concat?: ,
    join?: ,
    reverse?: ,
    shift?: ,
    slice?: ,
    sort?: ,
    splice?: ,
    unshift?: ,
    indexOf?: ,
    lastIndexOf?: ,
    every?: ,
    some?: ,
    forEach?: ,
    map?: ,
    filter?: ,
    reduce?: ,
    reduceRight?: ,
    find?: ,
    findIndex?: ,
    fill?: ,
    copyWithin?: ,
    entries?: ,
    keys?: ,
    values?: ,
    includes?: ,
    flatMap?: ,
    flat?: ,
    at?: ,
    findLast?: ,
    findLastIndex?: ,
    [iterator]?: ,
    [unscopables]?: boolean,
  }

}
```
Is an object whose properties have the value 'true'
when they will be absent when used in a 'with' statement.



</details>



----

## `ResolvedCoMapBase`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class ResolvedCoMapBase<M extends CoMap> {...}
```
TODO: document

### `ResolvedCoMapBase`: Constructors

<br/>

### `ResolvedCoMapBase`: Methods



<details>
<summary><b><code>.get(key)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  get<K extends string>(
    key: K
  ): ResolvedCoMap<M>[K] {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |

</details>



<details>
<summary><b><code>.set(key, value, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set<K extends string>(
    key: K,
    value: M["_shape"][K],
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `value` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.set(kv, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  set(
    kv: {
      [K in string]: M["_shape"][K]
    },
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `kv` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.delete(key, privacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  delete(
    key: keyof M["_shape"] & string,
    privacy?: "private" | "trusting"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `key` | TODO: document  |
| `privacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.mutate(mutator)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  mutate(
    mutator: (mutable: MutableCoMap<M["_shape"], M["headerMeta"]>) => void
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |


</details>

<br/>

### `ResolvedCoMapBase`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  id: CoID<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  coValueType: "comap"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  meta: ResolvedCoMapMeta<M>

}
```
TODO: document

</details>



<details>
<summary><b><code>.as</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedCoMapBase<M> {

  as: (extension: AutoSubExtension<M, O>) => undefined | O

}
```
TODO: document

</details>



----

## `ResolvedAccount`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class ResolvedAccount<A extends Account> extends ResolvedGroup<A> {...}
```
TODO: document

### `ResolvedAccount`: Constructors

<details>
<summary><b><code>new ResolvedAccount</code></b>(account, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  constructor<A extends Account<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, AccountMeta>>(
    account: A,
    autoSubContext: AutoSubContext
  ): ResolvedAccount<A> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `account` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Methods

<details>
<summary><b><code>.createGroup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createGroup(): Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject> {...}

}
```
TODO: document

undefined</details>



<details>
<summary><b><code>.acceptInvite(groupOrOwnedValueID, inviteSecret)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  acceptInvite<T extends CoValue>(
    groupOrOwnedValueID: CoID<T>,
    inviteSecret: `inviteSecret_z${string}`
  ): Promise<void> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `groupOrOwnedValueID` | TODO: document  |
| `inviteSecret` | TODO: document  |

</details>



<details>
<summary><b><code>.addMember(accountID, role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  removeMember(
    accountID: AccountID
  ): A {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedAccount`: Properties

<details>
<summary><b><code>.isMe</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  isMe: boolean

}
```
TODO: document

</details>



<details>
<summary><b><code>.id</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  id: CoID<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  meta: ResolvedGroupMeta<A>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  profile: ValueOrResolvedRef<A["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b> <sub><sup>from <code>ResolvedGroup</code></sup></sub>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedAccount<A> {

  root: ValueOrResolvedRef<A["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `ResolvedGroup`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class ResolvedGroup<G extends Group> {...}
```
TODO: document

### `ResolvedGroup`: Constructors

<details>
<summary><b><code>new ResolvedGroup</code></b>(group, autoSubContext)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  constructor<G extends Group<Profile<ProfileShape, ProfileMeta>, CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>, null | JsonObject>>(
    group: G,
    autoSubContext: AutoSubContext
  ): ResolvedGroup<G> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `group` | TODO: document  |
| `autoSubContext` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Methods

<details>
<summary><b><code>.addMember(accountID, role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  addMember(
    accountID: AccountID | "everyone",
    role: Role
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.removeMember(accountID)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  removeMember(
    accountID: AccountID
  ): G {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `accountID` | TODO: document  |

</details>



<details>
<summary><b><code>.createInvite(role)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createInvite(
    role: "reader" | "writer" | "admin"
  ): `inviteSecret_z${string}` {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `role` | TODO: document  |

</details>



<details>
<summary><b><code>.createMap(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createMap<M extends CoMap<{
    [key: string]: JsonValue | undefined }, null | JsonObject>>(
    init?: {
      [K in string | number | symbol]: M["_shape"][K]
    },
    meta?: M["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): M {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createList(init?, meta?, initPrivacy?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createList<L extends CoList<JsonValue, null | JsonObject>>(
    init?: L["_item"][],
    meta?: L["headerMeta"],
    initPrivacy?: "private" | "trusting" = "private"
  ): L {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `init?` | TODO: document  |
| `meta?` | TODO: document  |
| `initPrivacy?` | TODO: document  |

</details>



<details>
<summary><b><code>.createStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createStream<C extends CoStream<JsonValue, null | JsonObject>>(
    meta?: C["headerMeta"]
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>



<details>
<summary><b><code>.createBinaryStream(meta?)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  createBinaryStream<C extends BinaryCoStream<{
    type: "binary",
  }>>(
    meta?: C["headerMeta"] = ...
  ): C {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `meta?` | TODO: document  |

</details>

<br/>

### `ResolvedGroup`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  id: CoID<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.coValueType</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  coValueType: "group"

}
```
TODO: document

</details>



<details>
<summary><b><code>.meta</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  meta: ResolvedGroupMeta<G>

}
```
TODO: document

</details>



<details>
<summary><b><code>.profile</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  profile: ValueOrResolvedRef<G["_shape"]["profile"]>

}
```
TODO: document

</details>



<details>
<summary><b><code>.root</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class ResolvedGroup<G> {

  root: ValueOrResolvedRef<G["_shape"]["root"]>

}
```
TODO: document

</details>



----

## `AutoSubContext`

<sup>(class in `jazz-autosub`)</sup>

```typescript
export class AutoSubContext {...}
```
TODO: document

### `AutoSubContext`: Constructors

<details>
<summary><b><code>new AutoSubContext</code></b>(node, onUpdate)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  constructor(
    node: LocalNode,
    onUpdate: () => void
  ): AutoSubContext {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `node` | TODO: document  |


</details>

<br/>

### `AutoSubContext`: Methods

<details>
<summary><b><code>.autoSub(valueID, alsoRender, _path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  autoSub<T extends CoValue>(
    valueID: CoID<T>,
    alsoRender: CoID<CoValue>[],
    _path: string
  ): undefined | Resolved<T> {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `valueID` | TODO: document  |
| `alsoRender` | TODO: document  |
| `_path` | TODO: document  |

</details>



<details>
<summary><b><code>.subscribeIfCoID(value, alsoRender, path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  subscribeIfCoID<T extends undefined | JsonValue>(
    value: T,
    alsoRender: CoID<CoValue>[],
    path: string
  ): T extends CoID<C> ? undefined | Resolved<C> : T {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `alsoRender` | TODO: document  |
| `path` | TODO: document  |

</details>



<details>
<summary><b><code>.valueOrResolvedRefPropertyDescriptor(value, alsoRender, path)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  valueOrResolvedRefPropertyDescriptor<T extends undefined | JsonValue>(
    value: T,
    alsoRender: CoID<CoValue>[],
    path: string
  ): T extends CoID<C>
    ? {
      get((): undefined | Resolved<C>,
    }
    : {
      value: T,
    } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `value` | TODO: document  |
| `alsoRender` | TODO: document  |
| `path` | TODO: document  |

</details>



<details>
<summary><b><code>.defineResolvedRefPropertiesIn(obj, subqueryProps, alsoRender)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  defineResolvedRefPropertiesIn<O extends object, P extends {
    [key: string]: {
      value: JsonValue | undefined,
      enumerable: boolean,
    } }>(
    obj: O,
    subqueryProps: P,
    alsoRender: CoID<CoValue>[]
  ): O & {
    [Key in string | number | symbol]: ValueOrResolvedRef<P[Key]["value"]>
  } {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `obj` | TODO: document  |
| `subqueryProps` | TODO: document  |
| `alsoRender` | TODO: document  |

</details>



<details>
<summary><b><code>.getOrCreateExtension(valueID, extension)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  getOrCreateExtension<T extends CoValue, O>(
    valueID: CoID<T>,
    extension: AutoSubExtension<T, O>
  ): undefined | O {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `valueID` | TODO: document  |
| `extension` | TODO: document  |

</details>



<details>
<summary><b><code>.cleanup()</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  cleanup(): void {...}

}
```
TODO: document

undefined</details>

<br/>

### `AutoSubContext`: Properties

<details>
<summary><b><code>.values</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  values: {
    [id: CoID<CoValue>]: {
      lastUpdate: CoValue | undefined,
      lastLoaded: Resolved<CoValue> | undefined,
      render: () => void,
      unsubscribe: () => void,
    } }

}
```
TODO: document

</details>



<details>
<summary><b><code>.extensions</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  extensions: {
    [id: `${CoID<CoValue>}_${string}`]: {
      lastOutput: unknown,
      unsubscribe: () => void,
    } }

}
```
TODO: document

</details>



<details>
<summary><b><code>.node</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  node: LocalNode

}
```
TODO: document

</details>



<details>
<summary><b><code>.onUpdate</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
class AutoSubContext {

  onUpdate: () => void

}
```
TODO: document

</details>



----

## `AutoSubExtension`

<sup>(interface in `jazz-autosub`)</sup>

```typescript
export interface AutoSubExtension<T extends CoValue, O> {...}
```
TODO: document

### `AutoSubExtension`: Methods

<details>
<summary><b><code>.subscribe(base, autoSubContext, onUpdate)</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface AutoSubExtension<T, O> {

  subscribe(
    base: T,
    autoSubContext: AutoSubContext,
    onUpdate: (value: O) => void
  ): () => void {...}

}
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `base` | TODO: document  |
| `autoSubContext` | TODO: document  |


</details>

<br/>

### `AutoSubExtension`: Properties

<details>
<summary><b><code>.id</code></b>  <sub><sup>(undocumented)</sup></sub></summary>

```typescript
interface AutoSubExtension<T, O> {

  id: string

}
```
TODO: document

</details>



----

## `ResolvedCoMap`

<sup>(type alias in `jazz-autosub`)</sup>

```typescript
export type ResolvedCoMap<M extends CoMap> = {
  [K in keyof M["_shape"] & string]: ValueOrResolvedRef<M["_shape"][K]>
} & ResolvedCoMapBase<M>
```
TODO: doc generator not implemented yet 2097152

----

## `Resolved`

<sup>(type alias in `jazz-autosub`)</sup>

```typescript
export type Resolved<T extends CoValue> = T extends CoMap
  ? T extends Account ? ResolvedAccount<T> : T extends Group ? ResolvedGroup<T> : ResolvedCoMap<T>
  : T extends CoList
    ? ResolvedCoList<T>
    : T extends CoStream
      ? T["headerMeta"] extends {
        type: "binary",
      } ? never : ResolvedCoStream<T>
      : ResolvedAccount | ResolvedGroup | ResolvedCoMap<CoMap> | ResolvedCoList<CoList> | ResolvedCoStream<CoStream>
```
TODO: doc generator not implemented yet 2097152


# jazz-nodejs

## `createOrResumeWorker({workerName, syncServer?, migration?})`

<sup>(function in `jazz-nodejs`)</sup>

```typescript
export function createOrResumeWorker<P extends Profile<ProfileShape, ProfileMeta>, R extends CoMap<{
  [key: string]: JsonValue | undefined }, null | JsonObject>>({
  workerName: string,
  syncServer?: string,
  migration?: AccountMigration<P, R>,
}): Promise<{
  localNode: LocalNode,
  worker: ControlledAccount<P, R, AccountMeta>,
}>
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `__namedParameters.workerName` | TODO: document |
| `__namedParameters.syncServer?` | TODO: document |
| `__namedParameters.migration?` | TODO: document |





----

## `autoSub(id, node, callback)`

<sup>(function in `jazz-nodejs`)</sup>

```typescript
export function autoSub<C extends CoValue>(id: undefined | CoID<C>, node: LocalNode, callback: (resolved: undefined | Resolved<C>) => void): () => void
```
TODO: document

### Parameters:

| name | description |
| ----: | ---- |
| `id` | TODO: document  |
| `node` | TODO: document  |




