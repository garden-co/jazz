import { base58 } from "@scure/base";
import cronometro from "cronometro";
import { isMainThread } from "node:worker_threads";

// Realistic account prefixes - same format as generated by Jazz
// Using 3 different accounts to simulate multi-user scenarios
const ACCOUNT_PREFIXES = [
  "co_zUwh2n1dhsCxZzZyfhsmCECSfZM",
  "co_z7gVGDpNz9qUtsRxAkHMuu4DYdt",
  "co_z5yhsCCe2XwLTZC4254mUoMASsh",
];

type SessionID = `${string}_session_z${string}`;

// Generate realistic sessionIDs rotating between 3 accounts
function generateSessionID(index: number): SessionID {
  const accountPrefix = ACCOUNT_PREFIXES[index % ACCOUNT_PREFIXES.length]!;
  const randomBytes = crypto.getRandomValues(new Uint8Array(8));
  const randomPart = base58.encode(randomBytes);
  return `${accountPrefix}_session_z${randomPart}` as SessionID;
}

type Transaction = {
  madeAt: number;
  txID: { sessionID: SessionID; txIndex: number };
};

// Pre-generate test data: 100 transactions with equal timestamps (worst case)
// Rotating between 3 accounts
const sessionIDs: SessionID[] = Array.from({ length: 100 }, (_, i) =>
  generateSessionID(i),
);

const madeAt = Date.now();
const transactions: Transaction[] = sessionIDs.map((s) => ({
  madeAt,
  txID: { sessionID: s, txIndex: 0 },
}));

// Compare function from coValueCore.ts - compares sessionIDs from the last character
function compareTransactionsReverse(a: Transaction, b: Transaction): number {
  if (a.madeAt !== b.madeAt) return a.madeAt - b.madeAt;
  if (a.txID.sessionID === b.txID.sessionID)
    return a.txID.txIndex - b.txID.txIndex;

  const aSession = a.txID.sessionID;
  const bSession = b.txID.sessionID;
  const minLen = Math.min(aSession.length, bSession.length);
  for (let i = 1; i <= minLen; i++) {
    const aChar = aSession.charCodeAt(aSession.length - i);
    const bChar = bSession.charCodeAt(bSession.length - i);
    if (aChar !== bChar) return aChar - bChar;
  }
  return aSession.length - bSession.length;
}

function compareTransactionsLocale(a: Transaction, b: Transaction): number {
  if (a.madeAt !== b.madeAt) return a.madeAt - b.madeAt;
  if (a.txID.sessionID === b.txID.sessionID)
    return a.txID.txIndex - b.txID.txIndex;
  return a.txID.sessionID.localeCompare(b.txID.sessionID);
}

if (isMainThread) {
  console.log(
    "\n╔══════════════════════════════════════════════════════════════╗",
  );
  console.log(
    "║        SessionID Comparison Benchmark                        ║",
  );
  console.log(
    "╚══════════════════════════════════════════════════════════════╝",
  );
  console.log(
    `\nTransactions: ${transactions.length} (all with equal timestamps)`,
  );
  console.log(`Accounts: ${ACCOUNT_PREFIXES.length} (rotating)`);
  console.log(`Account prefix length: ${ACCOUNT_PREFIXES[0]!.length} chars`);
  console.log(
    `Session suffix length: ~${sessionIDs[0]!.length - ACCOUNT_PREFIXES[0]!.length} chars`,
  );
  console.log(`\nExample sessionIDs:`);
  console.log(`  Account 1: ${sessionIDs[0]}`);
  console.log(`  Account 2: ${sessionIDs[1]}`);
  console.log(`  Account 3: ${sessionIDs[2]}\n`);
}

await cronometro(
  {
    "reverse charCodeAt (current)": () => {
      const arr = [...transactions];
      arr.sort(compareTransactionsReverse);
    },
    localeCompare: () => {
      const arr = [...transactions];
      arr.sort(compareTransactionsLocale);
    },
  },
  {
    iterations: 1000,
    warmup: true,
    print: { colors: true, compare: true },
  },
);

if (isMainThread) {
  console.log("\n" + "─".repeat(66));
  console.log(
    "With multiple accounts, the reverse comparison still wins because",
  );
  console.log(
    "sessionIDs often share prefixes (same account) or differ early in",
  );
  console.log(
    "the suffix, making end-first comparison more efficient on average.",
  );
  console.log("─".repeat(66) + "\n");
}
