// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './cojson_core_rn-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Hash data once using BLAKE3.
 * - `data`: Raw bytes to hash
 * Returns 32 bytes of hash output.
 * This is the simplest way to compute a BLAKE3 hash of a single piece of data.
 */
export function blake3HashOnce(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_blake3_hash_once(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Hash data once using BLAKE3 with a context prefix.
 * - `data`: Raw bytes to hash
 * - `context`: Context bytes to prefix to the data
 * Returns 32 bytes of hash output.
 * This is useful for domain separation - the same data hashed with different contexts will produce different outputs.
 */
export function blake3HashOnceWithContext(
  data: ArrayBuffer,
  context: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_blake3_hash_once_with_context(
          FfiConverterArrayBuffer.lower(data),
          FfiConverterArrayBuffer.lower(context),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to decrypt bytes with a key secret and nonce material.
 * - `ciphertext`: The encrypted bytes to decrypt
 * - `key_secret`: A base58-encoded key secret with "keySecret_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce (must match encryption)
 * Returns the decrypted bytes or throws an error if decryption fails.
 */
export function decrypt(
  ciphertext: ArrayBuffer,
  keySecret: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_decrypt(
          FfiConverterArrayBuffer.lower(ciphertext),
          FfiConverterString.lower(keySecret),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for XSalsa20 decryption without authentication.
 * - `key`: 32-byte key for decryption (must match encryption key)
 * - `nonce_material`: Raw bytes used to generate a 24-byte nonce (must match encryption)
 * - `ciphertext`: Encrypted bytes to decrypt
 * Returns the decrypted bytes or throws an error if decryption fails.
 * Note: This function does not provide authentication. Use decrypt_xsalsa20_poly1305 for authenticated decryption.
 */
export function decryptXsalsa20(
  key: ArrayBuffer,
  nonceMaterial: ArrayBuffer,
  ciphertext: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_decrypt_xsalsa20(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          FfiConverterArrayBuffer.lower(ciphertext),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to sign a message using Ed25519.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws CryptoErrorUniffi if signing fails.
 */
export function ed25519Sign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 signature bytes.
 * - `bytes`: 64 bytes of signature material to validate
 * Returns the same 64 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519SignatureFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signature_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 signing key bytes.
 * - `bytes`: 32 bytes of signing key material to validate
 * Returns the same 32 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519SigningKeyFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to sign a message with an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws CryptoErrorUniffi if signing fails.
 */
export function ed25519SigningKeySign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to derive the public key from an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of public key material or throws CryptoErrorUniffi if key is invalid.
 */
export function ed25519SigningKeyToPublic(
  signingKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_to_public(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to verify an Ed25519 signature.
 * - `verifying_key`: 32 bytes of verifying key material
 * - `message`: Raw bytes that were signed
 * - `signature`: 64 bytes of signature material
 * Returns true if signature is valid, false otherwise, or throws CryptoErrorUniffi if verification fails.
 */
export function ed25519Verify(
  verifyingKey: ArrayBuffer,
  message: ArrayBuffer,
  signature: ArrayBuffer
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verify(
          FfiConverterArrayBuffer.lower(verifyingKey),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterArrayBuffer.lower(signature),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to derive an Ed25519 verifying key from a signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of verifying key material or throws CryptoErrorUniffi if key is invalid.
 */
export function ed25519VerifyingKey(
  signingKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verifying_key(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 verifying key bytes.
 * - `bytes`: 32 bytes of verifying key material to validate
 * Returns the same 32 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519VerifyingKeyFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verifying_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to encrypt bytes with a key secret and nonce material.
 * - `value`: The raw bytes to encrypt
 * - `key_secret`: A base58-encoded key secret with "keySecret_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce
 * Returns the encrypted bytes or throws an error if encryption fails.
 */
export function encrypt(
  value: ArrayBuffer,
  keySecret: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_encrypt(
          FfiConverterArrayBuffer.lower(value),
          FfiConverterString.lower(keySecret),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for XSalsa20 encryption without authentication.
 * - `key`: 32-byte key for encryption
 * - `nonce_material`: Raw bytes used to generate a 24-byte nonce via BLAKE3
 * - `plaintext`: Raw bytes to encrypt
 * Returns the encrypted bytes or throws an error if encryption fails.
 * Note: This function does not provide authentication. Use encrypt_xsalsa20_poly1305 for authenticated encryption.
 */
export function encryptXsalsa20(
  key: ArrayBuffer,
  nonceMaterial: ArrayBuffer,
  plaintext: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_encrypt_xsalsa20(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          FfiConverterArrayBuffer.lower(plaintext),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a 24-byte nonce from input material using BLAKE3.
 * - `nonce_material`: Raw bytes to derive the nonce from
 * Returns 24 bytes suitable for use as a nonce in cryptographic operations.
 * This function is deterministic - the same input will produce the same nonce.
 */
export function generateNonce(nonceMaterial: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_generate_nonce(
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive a sealer ID from a sealer secret.
 * - `secret`: UTF-8 encoded sealer secret string
 * Returns a base58-encoded sealer ID with "sealer_z" prefix or throws an error if derivation fails.
 */
export function getSealerId(secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_get_sealer_id(
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive a signer ID from a signing key.
 * - `secret`: UTF-8 encoded Ed25519 signing key string
 * Returns base58-encoded verifying key with "signer_z" prefix or throws an error if derivation fails.
 */
export function getSignerId(secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_get_signer_id(
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a new Ed25519 signing key using secure random number generation.
 * Returns 32 bytes of raw key material suitable for use with other Ed25519 functions.
 */
export function newEd25519SigningKey(): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_new_ed25519_signing_key(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a new X25519 private key using secure random number generation.
 * Returns 32 bytes of raw key material suitable for use with other X25519 functions.
 * This key can be reused for multiple Diffie-Hellman exchanges.
 */
export function newX25519PrivateKey(): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_new_x25519_private_key(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for sealing a message using X25519 + XSalsa20-Poly1305.
 * Provides authenticated encryption with perfect forward secrecy.
 * - `message`: Raw bytes to seal
 * - `sender_secret`: Base58-encoded sender's private key with "sealerSecret_z" prefix
 * - `recipient_id`: Base58-encoded recipient's public key with "sealer_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce
 * Returns sealed bytes or throws an error if sealing fails.
 */
export function seal(
  message: ArrayBuffer,
  senderSecret: string,
  recipientId: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_seal(
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(senderSecret),
          FfiConverterString.lower(recipientId),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to sign a message using Ed25519.
 * - `message`: Raw bytes to sign
 * - `secret`: UTF-8 encoded Ed25519 signing key string
 * Returns base58-encoded signature with "signature_z" prefix or throws an error if signing fails.
 */
export function sign(message: ArrayBuffer, secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_sign(
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for unsealing a message using X25519 + XSalsa20-Poly1305.
 * Provides authenticated decryption with perfect forward secrecy.
 * - `sealed_message`: The sealed bytes to decrypt
 * - `recipient_secret`: Base58-encoded recipient's private key with "sealerSecret_z" prefix
 * - `sender_id`: Base58-encoded sender's public key with "sealer_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce (must match sealing)
 * Returns unsealed bytes or throws an error if unsealing fails.
 */
export function unseal(
  sealedMessage: ArrayBuffer,
  recipientSecret: string,
  senderId: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_unseal(
          FfiConverterArrayBuffer.lower(sealedMessage),
          FfiConverterString.lower(recipientSecret),
          FfiConverterString.lower(senderId),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to verify an Ed25519 signature.
 * - `signature`: Base58-encoded signature string
 * - `message`: Raw bytes that were signed
 * - `id`: Base58-encoded verifying key string
 * Returns true if signature is valid, false otherwise, or throws an error if verification fails.
 */
export function verify(
  signature: string,
  message: ArrayBuffer,
  id: string
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_verify(
          FfiConverterString.lower(signature),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to perform X25519 Diffie-Hellman key exchange.
 * - `private_key`: 32 bytes of private key material
 * - `public_key`: 32 bytes of public key material
 * Returns 32 bytes of shared secret material or throws an error if key exchange fails.
 */
export function x25519DiffieHellman(
  privateKey: ArrayBuffer,
  publicKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_x25519_diffie_hellman(
          FfiConverterArrayBuffer.lower(privateKey),
          FfiConverterArrayBuffer.lower(publicKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive an X25519 public key from a private key.
 * - `private_key`: 32 bytes of private key material
 * Returns 32 bytes of public key material or throws an error if key is invalid.
 */
export function x25519PublicKey(
  privateKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_x25519_public_key(
          FfiConverterArrayBuffer.lower(privateKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type UniffiFfiTransaction = {
  /**
   * "private" or "trusting"
   */
  privacy: string;
  /**
   * For private transactions
   */
  encryptedChanges: string | undefined;
  /**
   * For private transactions
   */
  keyUsed: string | undefined;
  /**
   * For trusting transactions
   */
  changes: string | undefined;
  /**
   * Timestamp
   */
  madeAt: /*f64*/ number;
  /**
   * Optional meta (encrypted or stringified)
   */
  meta: string | undefined;
};

/**
 * Generated factory for {@link UniffiFfiTransaction} record objects.
 */
export const UniffiFfiTransaction = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      UniffiFfiTransaction,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UniffiFfiTransaction}, with defaults specified
     * in Rust, in the {@link cojson_core_rn} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UniffiFfiTransaction}, with defaults specified
     * in Rust, in the {@link cojson_core_rn} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link cojson_core_rn} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UniffiFfiTransaction>,
  });
})();

const FfiConverterTypeUniffiFfiTransaction = (() => {
  type TypeName = UniffiFfiTransaction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        privacy: FfiConverterString.read(from),
        encryptedChanges: FfiConverterOptionalString.read(from),
        keyUsed: FfiConverterOptionalString.read(from),
        changes: FfiConverterOptionalString.read(from),
        madeAt: FfiConverterFloat64.read(from),
        meta: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.privacy, into);
      FfiConverterOptionalString.write(value.encryptedChanges, into);
      FfiConverterOptionalString.write(value.keyUsed, into);
      FfiConverterOptionalString.write(value.changes, into);
      FfiConverterFloat64.write(value.madeAt, into);
      FfiConverterOptionalString.write(value.meta, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.privacy) +
        FfiConverterOptionalString.allocationSize(value.encryptedChanges) +
        FfiConverterOptionalString.allocationSize(value.keyUsed) +
        FfiConverterOptionalString.allocationSize(value.changes) +
        FfiConverterFloat64.allocationSize(value.madeAt) +
        FfiConverterOptionalString.allocationSize(value.meta)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: Blake3Error

// Enum: Blake3Error
export enum Blake3Error_Tags {
  LockError = 'LockError',
}
export const Blake3Error = (() => {
  type LockError__interface = {
    tag: Blake3Error_Tags.LockError;
  };

  class LockError_ extends UniffiError implements LockError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Blake3Error';
    readonly tag = Blake3Error_Tags.LockError;
    constructor() {
      super('Blake3Error', 'LockError');
    }

    static new(): LockError_ {
      return new LockError_();
    }

    static instanceOf(obj: any): obj is LockError_ {
      return obj.tag === Blake3Error_Tags.LockError;
    }

    static hasInner(obj: any): obj is LockError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is Blake3Error {
    return obj[uniffiTypeNameSymbol] === 'Blake3Error';
  }

  return Object.freeze({
    instanceOf,
    LockError: LockError_,
  });
})();

export type Blake3Error = InstanceType<
  (typeof Blake3Error)[keyof Omit<typeof Blake3Error, 'instanceOf'>]
>;

// FfiConverter for enum Blake3Error
const FfiConverterTypeBlake3Error = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Blake3Error;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Blake3Error.LockError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Blake3Error_Tags.LockError: {
          ordinalConverter.write(1, into);
          return;
        }
        default:
          // Throwing from here means that Blake3Error_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Blake3Error_Tags.LockError: {
          return ordinalConverter.allocationSize(1);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: CryptoErrorUniffi

// Enum: CryptoErrorUniffi
export enum CryptoErrorUniffi_Tags {
  InvalidKeyLength = 'InvalidKeyLength',
  InvalidNonceLength = 'InvalidNonceLength',
  InvalidSealerSecretFormat = 'InvalidSealerSecretFormat',
  InvalidSignatureLength = 'InvalidSignatureLength',
  InvalidVerifyingKey = 'InvalidVerifyingKey',
  InvalidPublicKey = 'InvalidPublicKey',
  WrongTag = 'WrongTag',
  CipherError = 'CipherError',
  InvalidPrefix = 'InvalidPrefix',
  Base58Error = 'Base58Error',
}
export const CryptoErrorUniffi = (() => {
  type InvalidKeyLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidKeyLength;
    inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
  };

  class InvalidKeyLength_
    extends UniffiError
    implements InvalidKeyLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidKeyLength;
    readonly inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
    constructor(v0: /*u64*/ bigint, v1: /*u64*/ bigint) {
      super('CryptoErrorUniffi', 'InvalidKeyLength');
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: /*u64*/ bigint, v1: /*u64*/ bigint): InvalidKeyLength_ {
      return new InvalidKeyLength_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidKeyLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidKeyLength;
    }

    static hasInner(obj: any): obj is InvalidKeyLength_ {
      return InvalidKeyLength_.instanceOf(obj);
    }

    static getInner(
      obj: InvalidKeyLength_
    ): Readonly<[/*u64*/ bigint, /*u64*/ bigint]> {
      return obj.inner;
    }
  }

  type InvalidNonceLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidNonceLength;
  };

  class InvalidNonceLength_
    extends UniffiError
    implements InvalidNonceLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidNonceLength;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidNonceLength');
    }

    static new(): InvalidNonceLength_ {
      return new InvalidNonceLength_();
    }

    static instanceOf(obj: any): obj is InvalidNonceLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidNonceLength;
    }

    static hasInner(obj: any): obj is InvalidNonceLength_ {
      return false;
    }
  }

  type InvalidSealerSecretFormat__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
  };

  class InvalidSealerSecretFormat_
    extends UniffiError
    implements InvalidSealerSecretFormat__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidSealerSecretFormat');
    }

    static new(): InvalidSealerSecretFormat_ {
      return new InvalidSealerSecretFormat_();
    }

    static instanceOf(obj: any): obj is InvalidSealerSecretFormat_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    }

    static hasInner(obj: any): obj is InvalidSealerSecretFormat_ {
      return false;
    }
  }

  type InvalidSignatureLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSignatureLength;
  };

  class InvalidSignatureLength_
    extends UniffiError
    implements InvalidSignatureLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidSignatureLength;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidSignatureLength');
    }

    static new(): InvalidSignatureLength_ {
      return new InvalidSignatureLength_();
    }

    static instanceOf(obj: any): obj is InvalidSignatureLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSignatureLength;
    }

    static hasInner(obj: any): obj is InvalidSignatureLength_ {
      return false;
    }
  }

  type InvalidVerifyingKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    inner: Readonly<[string]>;
  };

  class InvalidVerifyingKey_
    extends UniffiError
    implements InvalidVerifyingKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'InvalidVerifyingKey');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidVerifyingKey_ {
      return new InvalidVerifyingKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidVerifyingKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    }

    static hasInner(obj: any): obj is InvalidVerifyingKey_ {
      return InvalidVerifyingKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidVerifyingKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidPublicKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPublicKey;
    inner: Readonly<[string]>;
  };

  class InvalidPublicKey_
    extends UniffiError
    implements InvalidPublicKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidPublicKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'InvalidPublicKey');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidPublicKey_ {
      return new InvalidPublicKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidPublicKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPublicKey;
    }

    static hasInner(obj: any): obj is InvalidPublicKey_ {
      return InvalidPublicKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidPublicKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type WrongTag__interface = {
    tag: CryptoErrorUniffi_Tags.WrongTag;
  };

  class WrongTag_ extends UniffiError implements WrongTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.WrongTag;
    constructor() {
      super('CryptoErrorUniffi', 'WrongTag');
    }

    static new(): WrongTag_ {
      return new WrongTag_();
    }

    static instanceOf(obj: any): obj is WrongTag_ {
      return obj.tag === CryptoErrorUniffi_Tags.WrongTag;
    }

    static hasInner(obj: any): obj is WrongTag_ {
      return false;
    }
  }

  type CipherError__interface = {
    tag: CryptoErrorUniffi_Tags.CipherError;
  };

  class CipherError_ extends UniffiError implements CipherError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.CipherError;
    constructor() {
      super('CryptoErrorUniffi', 'CipherError');
    }

    static new(): CipherError_ {
      return new CipherError_();
    }

    static instanceOf(obj: any): obj is CipherError_ {
      return obj.tag === CryptoErrorUniffi_Tags.CipherError;
    }

    static hasInner(obj: any): obj is CipherError_ {
      return false;
    }
  }

  type InvalidPrefix__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPrefix;
    inner: Readonly<[string, string]>;
  };

  class InvalidPrefix_ extends UniffiError implements InvalidPrefix__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidPrefix;
    readonly inner: Readonly<[string, string]>;
    constructor(v0: string, v1: string) {
      super('CryptoErrorUniffi', 'InvalidPrefix');
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: string, v1: string): InvalidPrefix_ {
      return new InvalidPrefix_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidPrefix_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPrefix;
    }

    static hasInner(obj: any): obj is InvalidPrefix_ {
      return InvalidPrefix_.instanceOf(obj);
    }

    static getInner(obj: InvalidPrefix_): Readonly<[string, string]> {
      return obj.inner;
    }
  }

  type Base58Error__interface = {
    tag: CryptoErrorUniffi_Tags.Base58Error;
    inner: Readonly<[string]>;
  };

  class Base58Error_ extends UniffiError implements Base58Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.Base58Error;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'Base58Error');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Base58Error_ {
      return new Base58Error_(v0);
    }

    static instanceOf(obj: any): obj is Base58Error_ {
      return obj.tag === CryptoErrorUniffi_Tags.Base58Error;
    }

    static hasInner(obj: any): obj is Base58Error_ {
      return Base58Error_.instanceOf(obj);
    }

    static getInner(obj: Base58Error_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is CryptoErrorUniffi {
    return obj[uniffiTypeNameSymbol] === 'CryptoErrorUniffi';
  }

  return Object.freeze({
    instanceOf,
    InvalidKeyLength: InvalidKeyLength_,
    InvalidNonceLength: InvalidNonceLength_,
    InvalidSealerSecretFormat: InvalidSealerSecretFormat_,
    InvalidSignatureLength: InvalidSignatureLength_,
    InvalidVerifyingKey: InvalidVerifyingKey_,
    InvalidPublicKey: InvalidPublicKey_,
    WrongTag: WrongTag_,
    CipherError: CipherError_,
    InvalidPrefix: InvalidPrefix_,
    Base58Error: Base58Error_,
  });
})();

export type CryptoErrorUniffi = InstanceType<
  (typeof CryptoErrorUniffi)[keyof Omit<typeof CryptoErrorUniffi, 'instanceOf'>]
>;

// FfiConverter for enum CryptoErrorUniffi
const FfiConverterTypeCryptoErrorUniffi = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CryptoErrorUniffi;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new CryptoErrorUniffi.InvalidKeyLength(
            FfiConverterUInt64.read(from),
            FfiConverterUInt64.read(from)
          );
        case 2:
          return new CryptoErrorUniffi.InvalidNonceLength();
        case 3:
          return new CryptoErrorUniffi.InvalidSealerSecretFormat();
        case 4:
          return new CryptoErrorUniffi.InvalidSignatureLength();
        case 5:
          return new CryptoErrorUniffi.InvalidVerifyingKey(
            FfiConverterString.read(from)
          );
        case 6:
          return new CryptoErrorUniffi.InvalidPublicKey(
            FfiConverterString.read(from)
          );
        case 7:
          return new CryptoErrorUniffi.WrongTag();
        case 8:
          return new CryptoErrorUniffi.CipherError();
        case 9:
          return new CryptoErrorUniffi.InvalidPrefix(
            FfiConverterString.read(from),
            FfiConverterString.read(from)
          );
        case 10:
          return new CryptoErrorUniffi.Base58Error(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner[0], into);
          FfiConverterUInt64.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          ordinalConverter.write(2, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          ordinalConverter.write(3, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          ordinalConverter.write(4, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          ordinalConverter.write(7, into);
          return;
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          ordinalConverter.write(8, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          FfiConverterString.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that CryptoErrorUniffi_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner[0]);
          size += FfiConverterUInt64.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          return ordinalConverter.allocationSize(2);
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          return ordinalConverter.allocationSize(3);
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          return ordinalConverter.allocationSize(4);
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          return ordinalConverter.allocationSize(7);
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          return ordinalConverter.allocationSize(8);
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          size += FfiConverterString.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SessionLogError

// Enum: SessionLogError
export enum SessionLogError_Tags {
  CoJson = 'CoJson',
  Serde = 'Serde',
  Generic = 'Generic',
  LockError = 'LockError',
}
export const SessionLogError = (() => {
  type CoJson__interface = {
    tag: SessionLogError_Tags.CoJson;
    inner: Readonly<[string]>;
  };

  class CoJson_ extends UniffiError implements CoJson__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionLogError';
    readonly tag = SessionLogError_Tags.CoJson;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SessionLogError', 'CoJson');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): CoJson_ {
      return new CoJson_(v0);
    }

    static instanceOf(obj: any): obj is CoJson_ {
      return obj.tag === SessionLogError_Tags.CoJson;
    }

    static hasInner(obj: any): obj is CoJson_ {
      return CoJson_.instanceOf(obj);
    }

    static getInner(obj: CoJson_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Serde__interface = {
    tag: SessionLogError_Tags.Serde;
    inner: Readonly<[string]>;
  };

  class Serde_ extends UniffiError implements Serde__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionLogError';
    readonly tag = SessionLogError_Tags.Serde;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SessionLogError', 'Serde');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Serde_ {
      return new Serde_(v0);
    }

    static instanceOf(obj: any): obj is Serde_ {
      return obj.tag === SessionLogError_Tags.Serde;
    }

    static hasInner(obj: any): obj is Serde_ {
      return Serde_.instanceOf(obj);
    }

    static getInner(obj: Serde_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Generic__interface = {
    tag: SessionLogError_Tags.Generic;
    inner: Readonly<[string]>;
  };

  class Generic_ extends UniffiError implements Generic__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionLogError';
    readonly tag = SessionLogError_Tags.Generic;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SessionLogError', 'Generic');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Generic_ {
      return new Generic_(v0);
    }

    static instanceOf(obj: any): obj is Generic_ {
      return obj.tag === SessionLogError_Tags.Generic;
    }

    static hasInner(obj: any): obj is Generic_ {
      return Generic_.instanceOf(obj);
    }

    static getInner(obj: Generic_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type LockError__interface = {
    tag: SessionLogError_Tags.LockError;
  };

  class LockError_ extends UniffiError implements LockError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionLogError';
    readonly tag = SessionLogError_Tags.LockError;
    constructor() {
      super('SessionLogError', 'LockError');
    }

    static new(): LockError_ {
      return new LockError_();
    }

    static instanceOf(obj: any): obj is LockError_ {
      return obj.tag === SessionLogError_Tags.LockError;
    }

    static hasInner(obj: any): obj is LockError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is SessionLogError {
    return obj[uniffiTypeNameSymbol] === 'SessionLogError';
  }

  return Object.freeze({
    instanceOf,
    CoJson: CoJson_,
    Serde: Serde_,
    Generic: Generic_,
    LockError: LockError_,
  });
})();

export type SessionLogError = InstanceType<
  (typeof SessionLogError)[keyof Omit<typeof SessionLogError, 'instanceOf'>]
>;

// FfiConverter for enum SessionLogError
const FfiConverterTypeSessionLogError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SessionLogError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SessionLogError.CoJson(FfiConverterString.read(from));
        case 2:
          return new SessionLogError.Serde(FfiConverterString.read(from));
        case 3:
          return new SessionLogError.Generic(FfiConverterString.read(from));
        case 4:
          return new SessionLogError.LockError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SessionLogError_Tags.CoJson: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SessionLogError_Tags.Serde: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SessionLogError_Tags.Generic: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SessionLogError_Tags.LockError: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that SessionLogError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SessionLogError_Tags.CoJson: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SessionLogError_Tags.Serde: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SessionLogError_Tags.Generic: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SessionLogError_Tags.LockError: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface Blake3HasherInterface {
  cloneHasher() /*throws*/ : Blake3HasherInterface;
  finalize() /*throws*/ : ArrayBuffer;
  update(data: ArrayBuffer) /*throws*/ : void;
}

export class Blake3Hasher
  extends UniffiAbstractObject
  implements Blake3HasherInterface
{
  readonly [uniffiTypeNameSymbol] = 'Blake3Hasher';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_constructor_blake3hasher_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBlake3HasherObjectFactory.bless(pointer);
  }

  public cloneHasher(): Blake3HasherInterface /*throws*/ {
    return FfiConverterTypeBlake3Hasher.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
          FfiConverterTypeBlake3Error
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_clone_hasher(
            uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public finalize(): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
          FfiConverterTypeBlake3Error
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_finalize(
            uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public update(data: ArrayBuffer): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
        FfiConverterTypeBlake3Error
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_update(
          uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBlake3HasherObjectFactory.pointer(this);
      uniffiTypeBlake3HasherObjectFactory.freePointer(pointer);
      uniffiTypeBlake3HasherObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Blake3Hasher {
    return uniffiTypeBlake3HasherObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBlake3HasherObjectFactory: UniffiObjectFactory<Blake3HasherInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): Blake3HasherInterface {
        const instance = Object.create(Blake3Hasher.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'Blake3Hasher';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_blake3hasher_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: Blake3HasherInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: Blake3HasherInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_clone_blake3hasher(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_free_blake3hasher(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is Blake3HasherInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'Blake3Hasher'
        );
      },
    };
  })();
// FfiConverter for Blake3HasherInterface
const FfiConverterTypeBlake3Hasher = new FfiConverterObject(
  uniffiTypeBlake3HasherObjectFactory
);

export interface SessionLogInterface {
  addNewPrivateTransaction(
    changesJson: string,
    signerSecret: string,
    encryptionKey: string,
    keyId: string,
    madeAt: /*f64*/ number,
    meta: string | undefined
  ) /*throws*/ : string;
  addNewTrustingTransaction(
    changesJson: string,
    signerSecret: string,
    madeAt: /*f64*/ number,
    meta: string | undefined
  ) /*throws*/ : string;
  cloneSessionLog() /*throws*/ : SessionLogInterface;
  decryptNextTransactionChangesJson(
    txIndex: /*u32*/ number,
    encryptionKey: string
  ) /*throws*/ : string;
  decryptNextTransactionMetaJson(
    txIndex: /*u32*/ number,
    encryptionKey: string
  ) /*throws*/ : string | undefined;
  tryAdd(
    transactionsJson: Array<string>,
    newSignatureStr: string,
    skipVerify: boolean
  ) /*throws*/ : void;
  tryAddFfi(
    transactions: Array<UniffiFfiTransaction>,
    newSignatureStr: string,
    skipVerify: boolean
  ) /*throws*/ : void;
}

export class SessionLog
  extends UniffiAbstractObject
  implements SessionLogInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionLog';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(coId: string, sessionId: string, signerId: string | undefined) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_constructor_sessionlog_new(
          FfiConverterString.lower(coId),
          FfiConverterString.lower(sessionId),
          FfiConverterOptionalString.lower(signerId),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionLogObjectFactory.bless(pointer);
  }

  public addNewPrivateTransaction(
    changesJson: string,
    signerSecret: string,
    encryptionKey: string,
    keyId: string,
    madeAt: /*f64*/ number,
    meta: string | undefined
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
          FfiConverterTypeSessionLogError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_add_new_private_transaction(
            uniffiTypeSessionLogObjectFactory.clonePointer(this),
            FfiConverterString.lower(changesJson),
            FfiConverterString.lower(signerSecret),
            FfiConverterString.lower(encryptionKey),
            FfiConverterString.lower(keyId),
            FfiConverterFloat64.lower(madeAt),
            FfiConverterOptionalString.lower(meta),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public addNewTrustingTransaction(
    changesJson: string,
    signerSecret: string,
    madeAt: /*f64*/ number,
    meta: string | undefined
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
          FfiConverterTypeSessionLogError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_add_new_trusting_transaction(
            uniffiTypeSessionLogObjectFactory.clonePointer(this),
            FfiConverterString.lower(changesJson),
            FfiConverterString.lower(signerSecret),
            FfiConverterFloat64.lower(madeAt),
            FfiConverterOptionalString.lower(meta),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public cloneSessionLog(): SessionLogInterface /*throws*/ {
    return FfiConverterTypeSessionLog.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
          FfiConverterTypeSessionLogError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_clone_session_log(
            uniffiTypeSessionLogObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public decryptNextTransactionChangesJson(
    txIndex: /*u32*/ number,
    encryptionKey: string
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
          FfiConverterTypeSessionLogError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_decrypt_next_transaction_changes_json(
            uniffiTypeSessionLogObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(txIndex),
            FfiConverterString.lower(encryptionKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public decryptNextTransactionMetaJson(
    txIndex: /*u32*/ number,
    encryptionKey: string
  ): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
          FfiConverterTypeSessionLogError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_decrypt_next_transaction_meta_json(
            uniffiTypeSessionLogObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(txIndex),
            FfiConverterString.lower(encryptionKey),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public tryAdd(
    transactionsJson: Array<string>,
    newSignatureStr: string,
    skipVerify: boolean
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
        FfiConverterTypeSessionLogError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_try_add(
          uniffiTypeSessionLogObjectFactory.clonePointer(this),
          FfiConverterArrayString.lower(transactionsJson),
          FfiConverterString.lower(newSignatureStr),
          FfiConverterBool.lower(skipVerify),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public tryAddFfi(
    transactions: Array<UniffiFfiTransaction>,
    newSignatureStr: string,
    skipVerify: boolean
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionLogError.lift.bind(
        FfiConverterTypeSessionLogError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionlog_try_add_ffi(
          uniffiTypeSessionLogObjectFactory.clonePointer(this),
          FfiConverterArrayTypeUniffiFfiTransaction.lower(transactions),
          FfiConverterString.lower(newSignatureStr),
          FfiConverterBool.lower(skipVerify),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSessionLogObjectFactory.pointer(this);
      uniffiTypeSessionLogObjectFactory.freePointer(pointer);
      uniffiTypeSessionLogObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionLog {
    return uniffiTypeSessionLogObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSessionLogObjectFactory: UniffiObjectFactory<SessionLogInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): SessionLogInterface {
        const instance = Object.create(SessionLog.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'SessionLog';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_sessionlog_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: SessionLogInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: SessionLogInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_clone_sessionlog(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_free_sessionlog(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is SessionLogInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'SessionLog'
        );
      },
    };
  })();
// FfiConverter for SessionLogInterface
const FfiConverterTypeSessionLog = new FfiConverterObject(
  uniffiTypeSessionLogObjectFactory
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for Array<UniffiFfiTransaction>
const FfiConverterArrayTypeUniffiFfiTransaction = new FfiConverterArray(
  FfiConverterTypeUniffiFfiTransaction
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_cojson_core_rn_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_blake3_hash_once() !==
    58834
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_blake3_hash_once'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_blake3_hash_once_with_context() !==
    28201
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_blake3_hash_once_with_context'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_decrypt() !== 5223
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_decrypt_xsalsa20() !==
    29059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_decrypt_xsalsa20'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_sign() !==
    5643
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signature_from_bytes() !==
    4624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signature_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_from_bytes() !==
    37961
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_sign() !==
    50296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_to_public() !==
    17719
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_to_public'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verify() !==
    49484
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key() !==
    63215
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key_from_bytes() !==
    42802
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_encrypt() !== 552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_encrypt_xsalsa20() !==
    29297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_encrypt_xsalsa20'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_generate_nonce() !==
    55335
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_generate_nonce'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_get_sealer_id() !==
    35163
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_get_sealer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_get_signer_id() !==
    4067
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_get_signer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_new_ed25519_signing_key() !==
    3282
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_new_ed25519_signing_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_new_x25519_private_key() !==
    56777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_new_x25519_private_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_seal() !== 48965
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_seal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_sign() !== 12539
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_unseal() !== 52356
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_unseal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_verify() !== 59548
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_x25519_diffie_hellman() !==
    23336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_x25519_diffie_hellman'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_x25519_public_key() !==
    18915
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_x25519_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_clone_hasher() !==
    23778
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_clone_hasher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_finalize() !==
    64111
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_finalize'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_update() !==
    27902
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_add_new_private_transaction() !==
    3753
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_add_new_private_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_add_new_trusting_transaction() !==
    43511
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_add_new_trusting_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_clone_session_log() !==
    8261
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_clone_session_log'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_decrypt_next_transaction_changes_json() !==
    22072
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_decrypt_next_transaction_changes_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_decrypt_next_transaction_meta_json() !==
    5632
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_decrypt_next_transaction_meta_json'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_try_add() !==
    21226
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_try_add'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionlog_try_add_ffi() !==
    61205
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionlog_try_add_ffi'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_constructor_blake3hasher_new() !==
    24312
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_constructor_blake3hasher_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_constructor_sessionlog_new() !==
    25716
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_constructor_sessionlog_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBlake3Error,
    FfiConverterTypeBlake3Hasher,
    FfiConverterTypeCryptoErrorUniffi,
    FfiConverterTypeSessionLog,
    FfiConverterTypeSessionLogError,
    FfiConverterTypeUniffiFfiTransaction,
  },
});
