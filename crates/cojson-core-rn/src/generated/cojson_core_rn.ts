// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './cojson_core_rn-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Decodes a base64url string to bytes (handles both padded and unpadded)
 */
export function base64urlToBytes(base64: string): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_base64url_to_bytes(
          FfiConverterString.lower(base64),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Hash data once using BLAKE3.
 * - `data`: Raw bytes to hash
 * Returns 32 bytes of hash output.
 * This is the simplest way to compute a BLAKE3 hash of a single piece of data.
 */
export function blake3HashOnce(data: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_blake3_hash_once(
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Hash data once using BLAKE3 with a context prefix.
 * - `data`: Raw bytes to hash
 * - `context`: Context bytes to prefix to the data
 * Returns 32 bytes of hash output.
 * This is useful for domain separation - the same data hashed with different contexts will produce different outputs.
 */
export function blake3HashOnceWithContext(
  data: ArrayBuffer,
  context: ArrayBuffer
): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_blake3_hash_once_with_context(
          FfiConverterArrayBuffer.lower(data),
          FfiConverterArrayBuffer.lower(context),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Encodes bytes to a standard base64 string (with padding)
 * Use this for data URLs and other contexts requiring standard base64.
 */
export function bytesToBase64(bytes: ArrayBuffer): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_bytes_to_base64(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Encodes bytes to a base64url string (with padding to match JS implementation)
 */
export function bytesToBase64url(bytes: ArrayBuffer): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_bytes_to_base64url(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to decrypt bytes with a key secret and nonce material.
 * - `ciphertext`: The encrypted bytes to decrypt
 * - `key_secret`: A base58-encoded key secret with "keySecret_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce (must match encryption)
 * Returns the decrypted bytes or throws an error if decryption fails.
 */
export function decrypt(
  ciphertext: ArrayBuffer,
  keySecret: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_decrypt(
          FfiConverterArrayBuffer.lower(ciphertext),
          FfiConverterString.lower(keySecret),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for XSalsa20 decryption without authentication.
 * - `key`: 32-byte key for decryption (must match encryption key)
 * - `nonce_material`: Raw bytes used to generate a 24-byte nonce (must match encryption)
 * - `ciphertext`: Encrypted bytes to decrypt
 * Returns the decrypted bytes or throws an error if decryption fails.
 * Note: This function does not provide authentication. Use decrypt_xsalsa20_poly1305 for authenticated decryption.
 */
export function decryptXsalsa20(
  key: ArrayBuffer,
  nonceMaterial: ArrayBuffer,
  ciphertext: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_decrypt_xsalsa20(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          FfiConverterArrayBuffer.lower(ciphertext),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to sign a message using Ed25519.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws CryptoErrorUniffi if signing fails.
 */
export function ed25519Sign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 signature bytes.
 * - `bytes`: 64 bytes of signature material to validate
 * Returns the same 64 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519SignatureFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signature_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 signing key bytes.
 * - `bytes`: 32 bytes of signing key material to validate
 * Returns the same 32 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519SigningKeyFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to sign a message with an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws CryptoErrorUniffi if signing fails.
 */
export function ed25519SigningKeySign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to derive the public key from an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of public key material or throws CryptoErrorUniffi if key is invalid.
 */
export function ed25519SigningKeyToPublic(
  signingKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_signing_key_to_public(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to verify an Ed25519 signature.
 * - `verifying_key`: 32 bytes of verifying key material
 * - `message`: Raw bytes that were signed
 * - `signature`: 64 bytes of signature material
 * Returns true if signature is valid, false otherwise, or throws CryptoErrorUniffi if verification fails.
 */
export function ed25519Verify(
  verifyingKey: ArrayBuffer,
  message: ArrayBuffer,
  signature: ArrayBuffer
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verify(
          FfiConverterArrayBuffer.lower(verifyingKey),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterArrayBuffer.lower(signature),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to derive an Ed25519 verifying key from a signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of verifying key material or throws CryptoErrorUniffi if key is invalid.
 */
export function ed25519VerifyingKey(
  signingKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verifying_key(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * uniffi-exposed function to validate and copy Ed25519 verifying key bytes.
 * - `bytes`: 32 bytes of verifying key material to validate
 * Returns the same 32 bytes if valid or throws CryptoErrorUniffi if invalid.
 */
export function ed25519VerifyingKeyFromBytes(
  bytes: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_ed25519_verifying_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to encrypt bytes with a key secret and nonce material.
 * - `value`: The raw bytes to encrypt
 * - `key_secret`: A base58-encoded key secret with "keySecret_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce
 * Returns the encrypted bytes or throws an error if encryption fails.
 */
export function encrypt(
  value: ArrayBuffer,
  keySecret: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_encrypt(
          FfiConverterArrayBuffer.lower(value),
          FfiConverterString.lower(keySecret),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for XSalsa20 encryption without authentication.
 * - `key`: 32-byte key for encryption
 * - `nonce_material`: Raw bytes used to generate a 24-byte nonce via BLAKE3
 * - `plaintext`: Raw bytes to encrypt
 * Returns the encrypted bytes or throws an error if encryption fails.
 * Note: This function does not provide authentication. Use encrypt_xsalsa20_poly1305 for authenticated encryption.
 */
export function encryptXsalsa20(
  key: ArrayBuffer,
  nonceMaterial: ArrayBuffer,
  plaintext: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_encrypt_xsalsa20(
          FfiConverterArrayBuffer.lower(key),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          FfiConverterArrayBuffer.lower(plaintext),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a 24-byte nonce from input material using BLAKE3.
 * - `nonce_material`: Raw bytes to derive the nonce from
 * Returns 24 bytes suitable for use as a nonce in cryptographic operations.
 * This function is deterministic - the same input will produce the same nonce.
 */
export function generateNonce(nonceMaterial: ArrayBuffer): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_generate_nonce(
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive a sealer ID from a sealer secret.
 * - `secret`: UTF-8 encoded sealer secret string
 * Returns a base58-encoded sealer ID with "sealer_z" prefix or throws an error if derivation fails.
 */
export function getSealerId(secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_get_sealer_id(
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive a signer ID from a signing key.
 * - `secret`: UTF-8 encoded Ed25519 signing key string
 * Returns base58-encoded verifying key with "signer_z" prefix or throws an error if derivation fails.
 */
export function getSignerId(secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_get_signer_id(
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a new Ed25519 signing key using secure random number generation.
 * Returns 32 bytes of raw key material suitable for use with other Ed25519 functions.
 */
export function newEd25519SigningKey(): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_new_ed25519_signing_key(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Generate a new X25519 private key using secure random number generation.
 * Returns 32 bytes of raw key material suitable for use with other X25519 functions.
 * This key can be reused for multiple Diffie-Hellman exchanges.
 */
export function newX25519PrivateKey(): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_new_x25519_private_key(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for sealing a message using X25519 + XSalsa20-Poly1305.
 * Provides authenticated encryption with perfect forward secrecy.
 * - `message`: Raw bytes to seal
 * - `sender_secret`: Base58-encoded sender's private key with "sealerSecret_z" prefix
 * - `recipient_id`: Base58-encoded recipient's public key with "sealer_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce
 * Returns sealed bytes or throws an error if sealing fails.
 */
export function seal(
  message: ArrayBuffer,
  senderSecret: string,
  recipientId: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_seal(
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(senderSecret),
          FfiConverterString.lower(recipientId),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for sealing a message for a group (anonymous box pattern).
 * Uses an ephemeral key pair, so no sender authentication is provided.
 * - `message`: Raw bytes to seal
 * - `recipient_id`: Base58-encoded recipient's public key with "sealer_z" prefix (the group's sealer)
 * - `nonce_material`: Raw bytes used to generate the nonce
 * Returns ephemeral_public_key (32 bytes) || ciphertext, or throws an error if sealing fails.
 */
export function sealForGroup(
  message: ArrayBuffer,
  recipientId: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_seal_for_group(
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(recipientId),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Compute a short hash of a stable-stringified JSON value.
 * The input should already be serialized using stableStringify on the JS side.
 * Returns a string prefixed with "shortHash_z" followed by base58-encoded hash.
 */
export function shortHash(value: string): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_short_hash(
          FfiConverterString.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to sign a message using Ed25519.
 * - `message`: Raw bytes to sign
 * - `secret`: UTF-8 encoded Ed25519 signing key string
 * Returns base58-encoded signature with "signature_z" prefix or throws an error if signing fails.
 */
export function sign(message: ArrayBuffer, secret: string): string /*throws*/ {
  return FfiConverterString.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_sign(
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(secret),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for unsealing a message using X25519 + XSalsa20-Poly1305.
 * Provides authenticated decryption with perfect forward secrecy.
 * - `sealed_message`: The sealed bytes to decrypt
 * - `recipient_secret`: Base58-encoded recipient's private key with "sealerSecret_z" prefix
 * - `sender_id`: Base58-encoded sender's public key with "sealer_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce (must match sealing)
 * Returns unsealed bytes or throws an error if unsealing fails.
 */
export function unseal(
  sealedMessage: ArrayBuffer,
  recipientSecret: string,
  senderId: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_unseal(
          FfiConverterArrayBuffer.lower(sealedMessage),
          FfiConverterString.lower(recipientSecret),
          FfiConverterString.lower(senderId),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function for unsealing a message sealed for a group (anonymous box pattern).
 * Extracts the ephemeral public key and decrypts the message.
 * - `sealed_message`: ephemeral_public_key (32 bytes) || ciphertext
 * - `recipient_secret`: Base58-encoded recipient's private key with "sealerSecret_z" prefix
 * - `nonce_material`: Raw bytes used to generate the nonce (must match sealing)
 * Returns unsealed bytes or throws an error if unsealing fails.
 */
export function unsealForGroup(
  sealedMessage: ArrayBuffer,
  recipientSecret: string,
  nonceMaterial: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_unseal_for_group(
          FfiConverterArrayBuffer.lower(sealedMessage),
          FfiConverterString.lower(recipientSecret),
          FfiConverterArrayBuffer.lower(nonceMaterial),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to verify an Ed25519 signature.
 * - `signature`: Base58-encoded signature string
 * - `message`: Raw bytes that were signed
 * - `id`: Base58-encoded verifying key string
 * Returns true if signature is valid, false otherwise, or throws an error if verification fails.
 */
export function verify(
  signature: string,
  message: ArrayBuffer,
  id: string
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_verify(
          FfiConverterString.lower(signature),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterString.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to perform X25519 Diffie-Hellman key exchange.
 * - `private_key`: 32 bytes of private key material
 * - `public_key`: 32 bytes of public key material
 * Returns 32 bytes of shared secret material or throws an error if key exchange fails.
 */
export function x25519DiffieHellman(
  privateKey: ArrayBuffer,
  publicKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_x25519_diffie_hellman(
          FfiConverterArrayBuffer.lower(privateKey),
          FfiConverterArrayBuffer.lower(publicKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
/**
 * Uniffi-exposed function to derive an X25519 public key from a private key.
 * - `private_key`: 32 bytes of private key material
 * Returns 32 bytes of public key material or throws an error if key is invalid.
 */
export function x25519PublicKey(
  privateKey: ArrayBuffer
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_func_x25519_public_key(
          FfiConverterArrayBuffer.lower(privateKey),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

/**
 * KnownState as a native Record (no JSON serialization needed)
 */
export type KnownState = {
  id: string;
  header: boolean;
  sessions: Map<string, /*u32*/ number>;
};

/**
 * Generated factory for {@link KnownState} record objects.
 */
export const KnownState = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KnownState, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KnownState}, with defaults specified
     * in Rust, in the {@link cojson_core_rn} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KnownState}, with defaults specified
     * in Rust, in the {@link cojson_core_rn} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link cojson_core_rn} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KnownState>,
  });
})();

const FfiConverterTypeKnownState = (() => {
  type TypeName = KnownState;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterString.read(from),
        header: FfiConverterBool.read(from),
        sessions: FfiConverterMapStringUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.id, into);
      FfiConverterBool.write(value.header, into);
      FfiConverterMapStringUInt32.write(value.sessions, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.id) +
        FfiConverterBool.allocationSize(value.header) +
        FfiConverterMapStringUInt32.allocationSize(value.sessions)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: Blake3Error

// Enum: Blake3Error
export enum Blake3Error_Tags {
  LockError = 'LockError',
}
export const Blake3Error = (() => {
  type LockError__interface = {
    tag: Blake3Error_Tags.LockError;
  };

  class LockError_ extends UniffiError implements LockError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Blake3Error';
    readonly tag = Blake3Error_Tags.LockError;
    constructor() {
      super('Blake3Error', 'LockError');
    }

    static new(): LockError_ {
      return new LockError_();
    }

    static instanceOf(obj: any): obj is LockError_ {
      return obj.tag === Blake3Error_Tags.LockError;
    }

    static hasInner(obj: any): obj is LockError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is Blake3Error {
    return obj[uniffiTypeNameSymbol] === 'Blake3Error';
  }

  return Object.freeze({
    instanceOf,
    LockError: LockError_,
  });
})();

export type Blake3Error = InstanceType<
  (typeof Blake3Error)[keyof Omit<typeof Blake3Error, 'instanceOf'>]
>;

// FfiConverter for enum Blake3Error
const FfiConverterTypeBlake3Error = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Blake3Error;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Blake3Error.LockError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Blake3Error_Tags.LockError: {
          ordinalConverter.write(1, into);
          return;
        }
        default:
          // Throwing from here means that Blake3Error_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Blake3Error_Tags.LockError: {
          return ordinalConverter.allocationSize(1);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: CryptoErrorUniffi

// Enum: CryptoErrorUniffi
export enum CryptoErrorUniffi_Tags {
  InvalidKeyLength = 'InvalidKeyLength',
  InvalidNonceLength = 'InvalidNonceLength',
  InvalidSealerSecretFormat = 'InvalidSealerSecretFormat',
  InvalidSignatureLength = 'InvalidSignatureLength',
  InvalidVerifyingKey = 'InvalidVerifyingKey',
  InvalidPublicKey = 'InvalidPublicKey',
  WrongTag = 'WrongTag',
  CipherError = 'CipherError',
  InvalidPrefix = 'InvalidPrefix',
  Base58Error = 'Base58Error',
  Base64DecodeError = 'Base64DecodeError',
}
export const CryptoErrorUniffi = (() => {
  type InvalidKeyLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidKeyLength;
    inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
  };

  class InvalidKeyLength_
    extends UniffiError
    implements InvalidKeyLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidKeyLength;
    readonly inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
    constructor(v0: /*u64*/ bigint, v1: /*u64*/ bigint) {
      super('CryptoErrorUniffi', 'InvalidKeyLength');
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: /*u64*/ bigint, v1: /*u64*/ bigint): InvalidKeyLength_ {
      return new InvalidKeyLength_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidKeyLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidKeyLength;
    }

    static hasInner(obj: any): obj is InvalidKeyLength_ {
      return InvalidKeyLength_.instanceOf(obj);
    }

    static getInner(
      obj: InvalidKeyLength_
    ): Readonly<[/*u64*/ bigint, /*u64*/ bigint]> {
      return obj.inner;
    }
  }

  type InvalidNonceLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidNonceLength;
  };

  class InvalidNonceLength_
    extends UniffiError
    implements InvalidNonceLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidNonceLength;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidNonceLength');
    }

    static new(): InvalidNonceLength_ {
      return new InvalidNonceLength_();
    }

    static instanceOf(obj: any): obj is InvalidNonceLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidNonceLength;
    }

    static hasInner(obj: any): obj is InvalidNonceLength_ {
      return false;
    }
  }

  type InvalidSealerSecretFormat__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
  };

  class InvalidSealerSecretFormat_
    extends UniffiError
    implements InvalidSealerSecretFormat__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidSealerSecretFormat');
    }

    static new(): InvalidSealerSecretFormat_ {
      return new InvalidSealerSecretFormat_();
    }

    static instanceOf(obj: any): obj is InvalidSealerSecretFormat_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    }

    static hasInner(obj: any): obj is InvalidSealerSecretFormat_ {
      return false;
    }
  }

  type InvalidSignatureLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSignatureLength;
  };

  class InvalidSignatureLength_
    extends UniffiError
    implements InvalidSignatureLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidSignatureLength;
    constructor() {
      super('CryptoErrorUniffi', 'InvalidSignatureLength');
    }

    static new(): InvalidSignatureLength_ {
      return new InvalidSignatureLength_();
    }

    static instanceOf(obj: any): obj is InvalidSignatureLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSignatureLength;
    }

    static hasInner(obj: any): obj is InvalidSignatureLength_ {
      return false;
    }
  }

  type InvalidVerifyingKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    inner: Readonly<[string]>;
  };

  class InvalidVerifyingKey_
    extends UniffiError
    implements InvalidVerifyingKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'InvalidVerifyingKey');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidVerifyingKey_ {
      return new InvalidVerifyingKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidVerifyingKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    }

    static hasInner(obj: any): obj is InvalidVerifyingKey_ {
      return InvalidVerifyingKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidVerifyingKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidPublicKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPublicKey;
    inner: Readonly<[string]>;
  };

  class InvalidPublicKey_
    extends UniffiError
    implements InvalidPublicKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidPublicKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'InvalidPublicKey');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidPublicKey_ {
      return new InvalidPublicKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidPublicKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPublicKey;
    }

    static hasInner(obj: any): obj is InvalidPublicKey_ {
      return InvalidPublicKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidPublicKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type WrongTag__interface = {
    tag: CryptoErrorUniffi_Tags.WrongTag;
  };

  class WrongTag_ extends UniffiError implements WrongTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.WrongTag;
    constructor() {
      super('CryptoErrorUniffi', 'WrongTag');
    }

    static new(): WrongTag_ {
      return new WrongTag_();
    }

    static instanceOf(obj: any): obj is WrongTag_ {
      return obj.tag === CryptoErrorUniffi_Tags.WrongTag;
    }

    static hasInner(obj: any): obj is WrongTag_ {
      return false;
    }
  }

  type CipherError__interface = {
    tag: CryptoErrorUniffi_Tags.CipherError;
  };

  class CipherError_ extends UniffiError implements CipherError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.CipherError;
    constructor() {
      super('CryptoErrorUniffi', 'CipherError');
    }

    static new(): CipherError_ {
      return new CipherError_();
    }

    static instanceOf(obj: any): obj is CipherError_ {
      return obj.tag === CryptoErrorUniffi_Tags.CipherError;
    }

    static hasInner(obj: any): obj is CipherError_ {
      return false;
    }
  }

  type InvalidPrefix__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPrefix;
    inner: Readonly<[string, string]>;
  };

  class InvalidPrefix_ extends UniffiError implements InvalidPrefix__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.InvalidPrefix;
    readonly inner: Readonly<[string, string]>;
    constructor(v0: string, v1: string) {
      super('CryptoErrorUniffi', 'InvalidPrefix');
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: string, v1: string): InvalidPrefix_ {
      return new InvalidPrefix_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidPrefix_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPrefix;
    }

    static hasInner(obj: any): obj is InvalidPrefix_ {
      return InvalidPrefix_.instanceOf(obj);
    }

    static getInner(obj: InvalidPrefix_): Readonly<[string, string]> {
      return obj.inner;
    }
  }

  type Base58Error__interface = {
    tag: CryptoErrorUniffi_Tags.Base58Error;
    inner: Readonly<[string]>;
  };

  class Base58Error_ extends UniffiError implements Base58Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.Base58Error;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'Base58Error');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Base58Error_ {
      return new Base58Error_(v0);
    }

    static instanceOf(obj: any): obj is Base58Error_ {
      return obj.tag === CryptoErrorUniffi_Tags.Base58Error;
    }

    static hasInner(obj: any): obj is Base58Error_ {
      return Base58Error_.instanceOf(obj);
    }

    static getInner(obj: Base58Error_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type Base64DecodeError__interface = {
    tag: CryptoErrorUniffi_Tags.Base64DecodeError;
    inner: Readonly<[string]>;
  };

  class Base64DecodeError_
    extends UniffiError
    implements Base64DecodeError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'CryptoErrorUniffi';
    readonly tag = CryptoErrorUniffi_Tags.Base64DecodeError;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('CryptoErrorUniffi', 'Base64DecodeError');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Base64DecodeError_ {
      return new Base64DecodeError_(v0);
    }

    static instanceOf(obj: any): obj is Base64DecodeError_ {
      return obj.tag === CryptoErrorUniffi_Tags.Base64DecodeError;
    }

    static hasInner(obj: any): obj is Base64DecodeError_ {
      return Base64DecodeError_.instanceOf(obj);
    }

    static getInner(obj: Base64DecodeError_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is CryptoErrorUniffi {
    return obj[uniffiTypeNameSymbol] === 'CryptoErrorUniffi';
  }

  return Object.freeze({
    instanceOf,
    InvalidKeyLength: InvalidKeyLength_,
    InvalidNonceLength: InvalidNonceLength_,
    InvalidSealerSecretFormat: InvalidSealerSecretFormat_,
    InvalidSignatureLength: InvalidSignatureLength_,
    InvalidVerifyingKey: InvalidVerifyingKey_,
    InvalidPublicKey: InvalidPublicKey_,
    WrongTag: WrongTag_,
    CipherError: CipherError_,
    InvalidPrefix: InvalidPrefix_,
    Base58Error: Base58Error_,
    Base64DecodeError: Base64DecodeError_,
  });
})();

export type CryptoErrorUniffi = InstanceType<
  (typeof CryptoErrorUniffi)[keyof Omit<typeof CryptoErrorUniffi, 'instanceOf'>]
>;

// FfiConverter for enum CryptoErrorUniffi
const FfiConverterTypeCryptoErrorUniffi = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CryptoErrorUniffi;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new CryptoErrorUniffi.InvalidKeyLength(
            FfiConverterUInt64.read(from),
            FfiConverterUInt64.read(from)
          );
        case 2:
          return new CryptoErrorUniffi.InvalidNonceLength();
        case 3:
          return new CryptoErrorUniffi.InvalidSealerSecretFormat();
        case 4:
          return new CryptoErrorUniffi.InvalidSignatureLength();
        case 5:
          return new CryptoErrorUniffi.InvalidVerifyingKey(
            FfiConverterString.read(from)
          );
        case 6:
          return new CryptoErrorUniffi.InvalidPublicKey(
            FfiConverterString.read(from)
          );
        case 7:
          return new CryptoErrorUniffi.WrongTag();
        case 8:
          return new CryptoErrorUniffi.CipherError();
        case 9:
          return new CryptoErrorUniffi.InvalidPrefix(
            FfiConverterString.read(from),
            FfiConverterString.read(from)
          );
        case 10:
          return new CryptoErrorUniffi.Base58Error(
            FfiConverterString.read(from)
          );
        case 11:
          return new CryptoErrorUniffi.Base64DecodeError(
            FfiConverterString.read(from)
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner[0], into);
          FfiConverterUInt64.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          ordinalConverter.write(2, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          ordinalConverter.write(3, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          ordinalConverter.write(4, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          ordinalConverter.write(7, into);
          return;
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          ordinalConverter.write(8, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          FfiConverterString.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.Base64DecodeError: {
          ordinalConverter.write(11, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that CryptoErrorUniffi_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner[0]);
          size += FfiConverterUInt64.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          return ordinalConverter.allocationSize(2);
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          return ordinalConverter.allocationSize(3);
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          return ordinalConverter.allocationSize(4);
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          return ordinalConverter.allocationSize(7);
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          return ordinalConverter.allocationSize(8);
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          size += FfiConverterString.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.Base64DecodeError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(11);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Error type: SessionMapError

// Enum: SessionMapError
export enum SessionMapError_Tags {
  Internal = 'Internal',
  LockError = 'LockError',
}
export const SessionMapError = (() => {
  type Internal__interface = {
    tag: SessionMapError_Tags.Internal;
    inner: Readonly<[string]>;
  };

  class Internal_ extends UniffiError implements Internal__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionMapError';
    readonly tag = SessionMapError_Tags.Internal;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super('SessionMapError', 'Internal');
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Internal_ {
      return new Internal_(v0);
    }

    static instanceOf(obj: any): obj is Internal_ {
      return obj.tag === SessionMapError_Tags.Internal;
    }

    static hasInner(obj: any): obj is Internal_ {
      return Internal_.instanceOf(obj);
    }

    static getInner(obj: Internal_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type LockError__interface = {
    tag: SessionMapError_Tags.LockError;
  };

  class LockError_ extends UniffiError implements LockError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'SessionMapError';
    readonly tag = SessionMapError_Tags.LockError;
    constructor() {
      super('SessionMapError', 'LockError');
    }

    static new(): LockError_ {
      return new LockError_();
    }

    static instanceOf(obj: any): obj is LockError_ {
      return obj.tag === SessionMapError_Tags.LockError;
    }

    static hasInner(obj: any): obj is LockError_ {
      return false;
    }
  }

  function instanceOf(obj: any): obj is SessionMapError {
    return obj[uniffiTypeNameSymbol] === 'SessionMapError';
  }

  return Object.freeze({
    instanceOf,
    Internal: Internal_,
    LockError: LockError_,
  });
})();

export type SessionMapError = InstanceType<
  (typeof SessionMapError)[keyof Omit<typeof SessionMapError, 'instanceOf'>]
>;

// FfiConverter for enum SessionMapError
const FfiConverterTypeSessionMapError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = SessionMapError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new SessionMapError.Internal(FfiConverterString.read(from));
        case 2:
          return new SessionMapError.LockError();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case SessionMapError_Tags.Internal: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case SessionMapError_Tags.LockError: {
          ordinalConverter.write(2, into);
          return;
        }
        default:
          // Throwing from here means that SessionMapError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case SessionMapError_Tags.Internal: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case SessionMapError_Tags.LockError: {
          return ordinalConverter.allocationSize(2);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, /*u32*/number>
const FfiConverterMapStringUInt32 = new FfiConverterMap(
  FfiConverterString,
  FfiConverterUInt32
);

export interface Blake3HasherInterface {
  cloneHasher() /*throws*/ : Blake3HasherInterface;
  finalize() /*throws*/ : ArrayBuffer;
  update(data: ArrayBuffer) /*throws*/ : void;
}

export class Blake3Hasher
  extends UniffiAbstractObject
  implements Blake3HasherInterface
{
  readonly [uniffiTypeNameSymbol] = 'Blake3Hasher';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_constructor_blake3hasher_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeBlake3HasherObjectFactory.bless(pointer);
  }

  public cloneHasher(): Blake3HasherInterface /*throws*/ {
    return FfiConverterTypeBlake3Hasher.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
          FfiConverterTypeBlake3Error
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_clone_hasher(
            uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public finalize(): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
          FfiConverterTypeBlake3Error
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_finalize(
            uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public update(data: ArrayBuffer): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeBlake3Error.lift.bind(
        FfiConverterTypeBlake3Error
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_blake3hasher_update(
          uniffiTypeBlake3HasherObjectFactory.clonePointer(this),
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeBlake3HasherObjectFactory.pointer(this);
      uniffiTypeBlake3HasherObjectFactory.freePointer(pointer);
      uniffiTypeBlake3HasherObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Blake3Hasher {
    return uniffiTypeBlake3HasherObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeBlake3HasherObjectFactory: UniffiObjectFactory<Blake3HasherInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): Blake3HasherInterface {
        const instance = Object.create(Blake3Hasher.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'Blake3Hasher';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_blake3hasher_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: Blake3HasherInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: Blake3HasherInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_clone_blake3hasher(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_free_blake3hasher(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is Blake3HasherInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'Blake3Hasher'
        );
      },
    };
  })();
// FfiConverter for Blake3HasherInterface
const FfiConverterTypeBlake3Hasher = new FfiConverterObject(
  uniffiTypeBlake3HasherObjectFactory
);

export interface SessionMapInterface {
  /**
   * Add transactions to a session
   */
  addTransactions(
    sessionId: string,
    signerId: string | undefined,
    transactionsJson: string,
    signature: string,
    skipVerify: boolean
  ) /*throws*/ : void;
  /**
   * Decrypt transaction changes
   */
  decryptTransaction(
    sessionId: string,
    txIndex: /*u32*/ number,
    keySecret: string
  ) /*throws*/ : string | undefined;
  /**
   * Decrypt transaction meta
   */
  decryptTransactionMeta(
    sessionId: string,
    txIndex: /*u32*/ number,
    keySecret: string
  ) /*throws*/ : string | undefined;
  /**
   * Get the header as JSON
   */
  getHeader() /*throws*/ : string;
  /**
   * Get the known state as a native Record
   */
  getKnownState() /*throws*/ : KnownState;
  /**
   * Get the known state with streaming as a native Record
   */
  getKnownStateWithStreaming() /*throws*/ : KnownState | undefined;
  /**
   * Get last signature for a session (returns None if session not found)
   */
  getLastSignature(sessionId: string) /*throws*/ : string | undefined;
  /**
   * Get the last signature checkpoint index (-1 if no checkpoints, None if session not found)
   */
  getLastSignatureCheckpoint(
    sessionId: string
  ) /*throws*/ : /*i32*/ number | undefined;
  /**
   * Get all session IDs as native array
   */
  getSessionIds() /*throws*/ : Array<string>;
  /**
   * Get transactions for a session from index as JSON strings (returns None if session not found)
   */
  getSessionTransactions(
    sessionId: string,
    fromIndex: /*u32*/ number
  ) /*throws*/ : Array<string> | undefined;
  /**
   * Get signature after specific transaction index
   */
  getSignatureAfter(
    sessionId: string,
    txIndex: /*u32*/ number
  ) /*throws*/ : string | undefined;
  /**
   * Get single transaction by index as JSON string (returns None if not found)
   */
  getTransaction(
    sessionId: string,
    txIndex: /*u32*/ number
  ) /*throws*/ : string | undefined;
  /**
   * Get transaction count for a session (returns -1 if session not found)
   */
  getTransactionCount(sessionId: string) /*throws*/ : /*i32*/ number;
  /**
   * Check if this CoValue is deleted
   */
  isDeleted() /*throws*/ : boolean;
  /**
   * Create new private transaction (for local writes)
   * Returns JSON: { signature: string, transaction: Transaction }
   */
  makeNewPrivateTransaction(
    sessionId: string,
    signerSecret: string,
    changesJson: string,
    keyId: string,
    keySecret: string,
    metaJson: string | undefined,
    madeAt: /*f64*/ number
  ) /*throws*/ : string;
  /**
   * Create new trusting transaction (for local writes)
   * Returns JSON: { signature: string, transaction: Transaction }
   */
  makeNewTrustingTransaction(
    sessionId: string,
    signerSecret: string,
    changesJson: string,
    metaJson: string | undefined,
    madeAt: /*f64*/ number
  ) /*throws*/ : string;
  /**
   * Mark this CoValue as deleted
   */
  markAsDeleted() /*throws*/ : void;
  /**
   * Set streaming known state
   */
  setStreamingKnownState(streamingJson: string) /*throws*/ : void;
}

export class SessionMap
  extends UniffiAbstractObject
  implements SessionMapInterface
{
  readonly [uniffiTypeNameSymbol] = 'SessionMap';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new SessionMap for a CoValue
   * Create a new SessionMap for a CoValue.
   * Validates the header and verifies that `co_id` matches the hash of the header.
   * `max_tx_size` is the threshold for recording in-between signatures (default: 100KB)
   * `skip_verify` if true, skips uniqueness and ID validation (for trusted storage shards)
   */
  constructor(
    coId: string,
    headerJson: string,
    maxTxSize: /*u32*/ number | undefined,
    skipVerify: boolean | undefined
  ) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
        FfiConverterTypeSessionMapError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_rn_fn_constructor_sessionmap_new(
          FfiConverterString.lower(coId),
          FfiConverterString.lower(headerJson),
          FfiConverterOptionalUInt32.lower(maxTxSize),
          FfiConverterOptionalBool.lower(skipVerify),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSessionMapObjectFactory.bless(pointer);
  }

  /**
   * Add transactions to a session
   */
  public addTransactions(
    sessionId: string,
    signerId: string | undefined,
    transactionsJson: string,
    signature: string,
    skipVerify: boolean
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
        FfiConverterTypeSessionMapError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_add_transactions(
          uniffiTypeSessionMapObjectFactory.clonePointer(this),
          FfiConverterString.lower(sessionId),
          FfiConverterOptionalString.lower(signerId),
          FfiConverterString.lower(transactionsJson),
          FfiConverterString.lower(signature),
          FfiConverterBool.lower(skipVerify),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Decrypt transaction changes
   */
  public decryptTransaction(
    sessionId: string,
    txIndex: /*u32*/ number,
    keySecret: string
  ): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_decrypt_transaction(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterUInt32.lower(txIndex),
            FfiConverterString.lower(keySecret),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Decrypt transaction meta
   */
  public decryptTransactionMeta(
    sessionId: string,
    txIndex: /*u32*/ number,
    keySecret: string
  ): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_decrypt_transaction_meta(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterUInt32.lower(txIndex),
            FfiConverterString.lower(keySecret),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the header as JSON
   */
  public getHeader(): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_header(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the known state as a native Record
   */
  public getKnownState(): KnownState /*throws*/ {
    return FfiConverterTypeKnownState.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_known_state(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the known state with streaming as a native Record
   */
  public getKnownStateWithStreaming(): KnownState | undefined /*throws*/ {
    return FfiConverterOptionalTypeKnownState.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_known_state_with_streaming(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get last signature for a session (returns None if session not found)
   */
  public getLastSignature(sessionId: string): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_last_signature(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the last signature checkpoint index (-1 if no checkpoints, None if session not found)
   */
  public getLastSignatureCheckpoint(
    sessionId: string
  ): /*i32*/ number | undefined /*throws*/ {
    return FfiConverterOptionalInt32.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_last_signature_checkpoint(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get all session IDs as native array
   */
  public getSessionIds(): Array<string> /*throws*/ {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_session_ids(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get transactions for a session from index as JSON strings (returns None if session not found)
   */
  public getSessionTransactions(
    sessionId: string,
    fromIndex: /*u32*/ number
  ): Array<string> | undefined /*throws*/ {
    return FfiConverterOptionalArrayString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_session_transactions(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterUInt32.lower(fromIndex),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get signature after specific transaction index
   */
  public getSignatureAfter(
    sessionId: string,
    txIndex: /*u32*/ number
  ): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_signature_after(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterUInt32.lower(txIndex),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get single transaction by index as JSON string (returns None if not found)
   */
  public getTransaction(
    sessionId: string,
    txIndex: /*u32*/ number
  ): string | undefined /*throws*/ {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_transaction(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterUInt32.lower(txIndex),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get transaction count for a session (returns -1 if session not found)
   */
  public getTransactionCount(sessionId: string): /*i32*/ number /*throws*/ {
    return FfiConverterInt32.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_get_transaction_count(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if this CoValue is deleted
   */
  public isDeleted(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_is_deleted(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new private transaction (for local writes)
   * Returns JSON: { signature: string, transaction: Transaction }
   */
  public makeNewPrivateTransaction(
    sessionId: string,
    signerSecret: string,
    changesJson: string,
    keyId: string,
    keySecret: string,
    metaJson: string | undefined,
    madeAt: /*f64*/ number
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_make_new_private_transaction(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterString.lower(signerSecret),
            FfiConverterString.lower(changesJson),
            FfiConverterString.lower(keyId),
            FfiConverterString.lower(keySecret),
            FfiConverterOptionalString.lower(metaJson),
            FfiConverterFloat64.lower(madeAt),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create new trusting transaction (for local writes)
   * Returns JSON: { signature: string, transaction: Transaction }
   */
  public makeNewTrustingTransaction(
    sessionId: string,
    signerSecret: string,
    changesJson: string,
    metaJson: string | undefined,
    madeAt: /*f64*/ number
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
          FfiConverterTypeSessionMapError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_make_new_trusting_transaction(
            uniffiTypeSessionMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(sessionId),
            FfiConverterString.lower(signerSecret),
            FfiConverterString.lower(changesJson),
            FfiConverterOptionalString.lower(metaJson),
            FfiConverterFloat64.lower(madeAt),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Mark this CoValue as deleted
   */
  public markAsDeleted(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
        FfiConverterTypeSessionMapError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_mark_as_deleted(
          uniffiTypeSessionMapObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set streaming known state
   */
  public setStreamingKnownState(streamingJson: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeSessionMapError.lift.bind(
        FfiConverterTypeSessionMapError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_cojson_core_rn_fn_method_sessionmap_set_streaming_known_state(
          uniffiTypeSessionMapObjectFactory.clonePointer(this),
          FfiConverterString.lower(streamingJson),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSessionMapObjectFactory.pointer(this);
      uniffiTypeSessionMapObjectFactory.freePointer(pointer);
      uniffiTypeSessionMapObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SessionMap {
    return uniffiTypeSessionMapObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSessionMapObjectFactory: UniffiObjectFactory<SessionMapInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): SessionMapInterface {
        const instance = Object.create(SessionMap.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'SessionMap';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_sessionmap_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: SessionMapInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: SessionMapInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_clone_sessionmap(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_cojson_core_rn_fn_free_sessionmap(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is SessionMapInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'SessionMap'
        );
      },
    };
  })();
// FfiConverter for SessionMapInterface
const FfiConverterTypeSessionMap = new FfiConverterObject(
  uniffiTypeSessionMapObjectFactory
);

// FfiConverter for boolean | undefined
const FfiConverterOptionalBool = new FfiConverterOptional(FfiConverterBool);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for KnownState | undefined
const FfiConverterOptionalTypeKnownState = new FfiConverterOptional(
  FfiConverterTypeKnownState
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array<string> | undefined
const FfiConverterOptionalArrayString = new FfiConverterOptional(
  FfiConverterArrayString
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_cojson_core_rn_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_base64url_to_bytes() !==
    7419
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_base64url_to_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_blake3_hash_once() !==
    58834
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_blake3_hash_once'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_blake3_hash_once_with_context() !==
    28201
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_blake3_hash_once_with_context'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_bytes_to_base64() !==
    57289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_bytes_to_base64'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_bytes_to_base64url() !==
    47249
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_bytes_to_base64url'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_decrypt() !== 5223
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_decrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_decrypt_xsalsa20() !==
    29059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_decrypt_xsalsa20'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_sign() !==
    5643
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signature_from_bytes() !==
    4624
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signature_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_from_bytes() !==
    37961
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_sign() !==
    50296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_to_public() !==
    17719
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_signing_key_to_public'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verify() !==
    49484
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key() !==
    63215
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key_from_bytes() !==
    42802
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_ed25519_verifying_key_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_encrypt() !== 552
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_encrypt'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_encrypt_xsalsa20() !==
    29297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_encrypt_xsalsa20'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_generate_nonce() !==
    55335
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_generate_nonce'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_get_sealer_id() !==
    35163
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_get_sealer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_get_signer_id() !==
    4067
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_get_signer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_new_ed25519_signing_key() !==
    3282
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_new_ed25519_signing_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_new_x25519_private_key() !==
    56777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_new_x25519_private_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_seal() !== 48965
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_seal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_seal_for_group() !==
    16377
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_seal_for_group'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_short_hash() !==
    26806
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_short_hash'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_sign() !== 12539
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_sign'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_unseal() !== 52356
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_unseal'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_unseal_for_group() !==
    19938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_unseal_for_group'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_verify() !== 59548
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_verify'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_x25519_diffie_hellman() !==
    23336
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_x25519_diffie_hellman'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_func_x25519_public_key() !==
    18915
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_func_x25519_public_key'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_clone_hasher() !==
    23778
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_clone_hasher'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_finalize() !==
    64111
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_finalize'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_blake3hasher_update() !==
    27902
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_blake3hasher_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_add_transactions() !==
    19976
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_add_transactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_decrypt_transaction() !==
    17995
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_decrypt_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_decrypt_transaction_meta() !==
    47192
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_decrypt_transaction_meta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_header() !==
    19592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_header'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_known_state() !==
    41174
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_known_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_known_state_with_streaming() !==
    52743
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_known_state_with_streaming'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_last_signature() !==
    19191
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_last_signature'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_last_signature_checkpoint() !==
    22828
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_last_signature_checkpoint'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_session_ids() !==
    26592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_session_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_session_transactions() !==
    59047
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_session_transactions'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_signature_after() !==
    51130
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_signature_after'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_transaction() !==
    50009
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_get_transaction_count() !==
    15609
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_get_transaction_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_is_deleted() !==
    27742
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_make_new_private_transaction() !==
    13868
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_make_new_private_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_make_new_trusting_transaction() !==
    30612
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_make_new_trusting_transaction'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_mark_as_deleted() !==
    57677
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_mark_as_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_method_sessionmap_set_streaming_known_state() !==
    16495
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_method_sessionmap_set_streaming_known_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_constructor_blake3hasher_new() !==
    24312
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_constructor_blake3hasher_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_rn_checksum_constructor_sessionmap_new() !==
    2008
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_cojson_core_rn_checksum_constructor_sessionmap_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBlake3Error,
    FfiConverterTypeBlake3Hasher,
    FfiConverterTypeCryptoErrorUniffi,
    FfiConverterTypeKnownState,
    FfiConverterTypeSessionMap,
    FfiConverterTypeSessionMapError,
  },
});
