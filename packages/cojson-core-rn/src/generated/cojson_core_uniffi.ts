// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from "./cojson_core_uniffi-ffi";
import {
  type UniffiByteArray,
  AbstractFfiConverterByteArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterInt32,
  FfiConverterUInt64,
  RustBuffer,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  uniffiCreateFfiConverterString,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

/**
 * NAPI-exposed function to sign a message using Ed25519.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws JsError if signing fails.
 */
export function ed25519Sign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to validate and copy Ed25519 signature bytes.
 * - `bytes`: 64 bytes of signature material to validate
 * Returns the same 64 bytes if valid or throws JsError if invalid.
 */
export function ed25519SignatureFromBytes(
  bytes: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_signature_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to validate and copy Ed25519 signing key bytes.
 * - `bytes`: 32 bytes of signing key material to validate
 * Returns the same 32 bytes if valid or throws JsError if invalid.
 */
export function ed25519SigningKeyFromBytes(
  bytes: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_signing_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to sign a message with an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * - `message`: Raw bytes to sign
 * Returns 64 bytes of signature material or throws JsError if signing fails.
 */
export function ed25519SigningKeySign(
  signingKey: ArrayBuffer,
  message: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_signing_key_sign(
          FfiConverterArrayBuffer.lower(signingKey),
          FfiConverterArrayBuffer.lower(message),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to derive the public key from an Ed25519 signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of public key material or throws JsError if key is invalid.
 */
export function ed25519SigningKeyToPublic(
  signingKey: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_signing_key_to_public(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to verify an Ed25519 signature.
 * - `verifying_key`: 32 bytes of verifying key material
 * - `message`: Raw bytes that were signed
 * - `signature`: 64 bytes of signature material
 * Returns true if signature is valid, false otherwise, or throws JsError if verification fails.
 */
export function ed25519Verify(
  verifyingKey: ArrayBuffer,
  message: ArrayBuffer,
  signature: ArrayBuffer,
): boolean /*throws*/ {
  return FfiConverterBool.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_verify(
          FfiConverterArrayBuffer.lower(verifyingKey),
          FfiConverterArrayBuffer.lower(message),
          FfiConverterArrayBuffer.lower(signature),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to derive an Ed25519 verifying key from a signing key.
 * - `signing_key`: 32 bytes of signing key material
 * Returns 32 bytes of verifying key material or throws JsError if key is invalid.
 */
export function ed25519VerifyingKey(
  signingKey: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_verifying_key(
          FfiConverterArrayBuffer.lower(signingKey),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * NAPI-exposed function to validate and copy Ed25519 verifying key bytes.
 * - `bytes`: 32 bytes of verifying key material to validate
 * Returns the same 32 bytes if valid or throws JsError if invalid.
 */
export function ed25519VerifyingKeyFromBytes(
  bytes: ArrayBuffer,
): ArrayBuffer /*throws*/ {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeCryptoErrorUniffi.lift.bind(
        FfiConverterTypeCryptoErrorUniffi,
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_ed25519_verifying_key_from_bytes(
          FfiConverterArrayBuffer.lower(bytes),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}
/**
 * Generate a new Ed25519 signing key using secure random number generation.
 * Returns 32 bytes of raw key material suitable for use with other Ed25519 functions.
 */
export function newEd25519SigningKey(): ArrayBuffer {
  return FfiConverterArrayBuffer.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_cojson_core_uniffi_fn_func_new_ed25519_signing_key(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: CryptoErrorUniffi

// Enum: CryptoErrorUniffi
export enum CryptoErrorUniffi_Tags {
  InvalidKeyLength = "InvalidKeyLength",
  InvalidNonceLength = "InvalidNonceLength",
  InvalidSealerSecretFormat = "InvalidSealerSecretFormat",
  InvalidSignatureLength = "InvalidSignatureLength",
  InvalidVerifyingKey = "InvalidVerifyingKey",
  InvalidPublicKey = "InvalidPublicKey",
  WrongTag = "WrongTag",
  CipherError = "CipherError",
  InvalidPrefix = "InvalidPrefix",
  Base58Error = "Base58Error",
}
export const CryptoErrorUniffi = (() => {
  type InvalidKeyLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidKeyLength;
    inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
  };

  class InvalidKeyLength_
    extends UniffiError
    implements InvalidKeyLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidKeyLength;
    readonly inner: Readonly<[/*u64*/ bigint, /*u64*/ bigint]>;
    constructor(v0: /*u64*/ bigint, v1: /*u64*/ bigint) {
      super("CryptoErrorUniffi", "InvalidKeyLength");
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: /*u64*/ bigint, v1: /*u64*/ bigint): InvalidKeyLength_ {
      return new InvalidKeyLength_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidKeyLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidKeyLength;
    }

    static hasInner(obj: any): obj is InvalidKeyLength_ {
      return InvalidKeyLength_.instanceOf(obj);
    }

    static getInner(
      obj: InvalidKeyLength_,
    ): Readonly<[/*u64*/ bigint, /*u64*/ bigint]> {
      return obj.inner;
    }
  }

  type InvalidNonceLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidNonceLength;
  };

  class InvalidNonceLength_
    extends UniffiError
    implements InvalidNonceLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidNonceLength;
    constructor() {
      super("CryptoErrorUniffi", "InvalidNonceLength");
    }

    static new(): InvalidNonceLength_ {
      return new InvalidNonceLength_();
    }

    static instanceOf(obj: any): obj is InvalidNonceLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidNonceLength;
    }

    static hasInner(obj: any): obj is InvalidNonceLength_ {
      return false;
    }
  }

  type InvalidSealerSecretFormat__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
  };

  class InvalidSealerSecretFormat_
    extends UniffiError
    implements InvalidSealerSecretFormat__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    constructor() {
      super("CryptoErrorUniffi", "InvalidSealerSecretFormat");
    }

    static new(): InvalidSealerSecretFormat_ {
      return new InvalidSealerSecretFormat_();
    }

    static instanceOf(obj: any): obj is InvalidSealerSecretFormat_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSealerSecretFormat;
    }

    static hasInner(obj: any): obj is InvalidSealerSecretFormat_ {
      return false;
    }
  }

  type InvalidSignatureLength__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidSignatureLength;
  };

  class InvalidSignatureLength_
    extends UniffiError
    implements InvalidSignatureLength__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidSignatureLength;
    constructor() {
      super("CryptoErrorUniffi", "InvalidSignatureLength");
    }

    static new(): InvalidSignatureLength_ {
      return new InvalidSignatureLength_();
    }

    static instanceOf(obj: any): obj is InvalidSignatureLength_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidSignatureLength;
    }

    static hasInner(obj: any): obj is InvalidSignatureLength_ {
      return false;
    }
  }

  type InvalidVerifyingKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    inner: Readonly<[string]>;
  };

  class InvalidVerifyingKey_
    extends UniffiError
    implements InvalidVerifyingKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super("CryptoErrorUniffi", "InvalidVerifyingKey");
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidVerifyingKey_ {
      return new InvalidVerifyingKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidVerifyingKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidVerifyingKey;
    }

    static hasInner(obj: any): obj is InvalidVerifyingKey_ {
      return InvalidVerifyingKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidVerifyingKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type InvalidPublicKey__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPublicKey;
    inner: Readonly<[string]>;
  };

  class InvalidPublicKey_
    extends UniffiError
    implements InvalidPublicKey__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidPublicKey;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super("CryptoErrorUniffi", "InvalidPublicKey");
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): InvalidPublicKey_ {
      return new InvalidPublicKey_(v0);
    }

    static instanceOf(obj: any): obj is InvalidPublicKey_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPublicKey;
    }

    static hasInner(obj: any): obj is InvalidPublicKey_ {
      return InvalidPublicKey_.instanceOf(obj);
    }

    static getInner(obj: InvalidPublicKey_): Readonly<[string]> {
      return obj.inner;
    }
  }

  type WrongTag__interface = {
    tag: CryptoErrorUniffi_Tags.WrongTag;
  };

  class WrongTag_ extends UniffiError implements WrongTag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.WrongTag;
    constructor() {
      super("CryptoErrorUniffi", "WrongTag");
    }

    static new(): WrongTag_ {
      return new WrongTag_();
    }

    static instanceOf(obj: any): obj is WrongTag_ {
      return obj.tag === CryptoErrorUniffi_Tags.WrongTag;
    }

    static hasInner(obj: any): obj is WrongTag_ {
      return false;
    }
  }

  type CipherError__interface = {
    tag: CryptoErrorUniffi_Tags.CipherError;
  };

  class CipherError_ extends UniffiError implements CipherError__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.CipherError;
    constructor() {
      super("CryptoErrorUniffi", "CipherError");
    }

    static new(): CipherError_ {
      return new CipherError_();
    }

    static instanceOf(obj: any): obj is CipherError_ {
      return obj.tag === CryptoErrorUniffi_Tags.CipherError;
    }

    static hasInner(obj: any): obj is CipherError_ {
      return false;
    }
  }

  type InvalidPrefix__interface = {
    tag: CryptoErrorUniffi_Tags.InvalidPrefix;
    inner: Readonly<[string, string]>;
  };

  class InvalidPrefix_ extends UniffiError implements InvalidPrefix__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.InvalidPrefix;
    readonly inner: Readonly<[string, string]>;
    constructor(v0: string, v1: string) {
      super("CryptoErrorUniffi", "InvalidPrefix");
      this.inner = Object.freeze([v0, v1]);
    }

    static new(v0: string, v1: string): InvalidPrefix_ {
      return new InvalidPrefix_(v0, v1);
    }

    static instanceOf(obj: any): obj is InvalidPrefix_ {
      return obj.tag === CryptoErrorUniffi_Tags.InvalidPrefix;
    }

    static hasInner(obj: any): obj is InvalidPrefix_ {
      return InvalidPrefix_.instanceOf(obj);
    }

    static getInner(obj: InvalidPrefix_): Readonly<[string, string]> {
      return obj.inner;
    }
  }

  type Base58Error__interface = {
    tag: CryptoErrorUniffi_Tags.Base58Error;
    inner: Readonly<[string]>;
  };

  class Base58Error_ extends UniffiError implements Base58Error__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "CryptoErrorUniffi";
    readonly tag = CryptoErrorUniffi_Tags.Base58Error;
    readonly inner: Readonly<[string]>;
    constructor(v0: string) {
      super("CryptoErrorUniffi", "Base58Error");
      this.inner = Object.freeze([v0]);
    }

    static new(v0: string): Base58Error_ {
      return new Base58Error_(v0);
    }

    static instanceOf(obj: any): obj is Base58Error_ {
      return obj.tag === CryptoErrorUniffi_Tags.Base58Error;
    }

    static hasInner(obj: any): obj is Base58Error_ {
      return Base58Error_.instanceOf(obj);
    }

    static getInner(obj: Base58Error_): Readonly<[string]> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is CryptoErrorUniffi {
    return obj[uniffiTypeNameSymbol] === "CryptoErrorUniffi";
  }

  return Object.freeze({
    instanceOf,
    InvalidKeyLength: InvalidKeyLength_,
    InvalidNonceLength: InvalidNonceLength_,
    InvalidSealerSecretFormat: InvalidSealerSecretFormat_,
    InvalidSignatureLength: InvalidSignatureLength_,
    InvalidVerifyingKey: InvalidVerifyingKey_,
    InvalidPublicKey: InvalidPublicKey_,
    WrongTag: WrongTag_,
    CipherError: CipherError_,
    InvalidPrefix: InvalidPrefix_,
    Base58Error: Base58Error_,
  });
})();

export type CryptoErrorUniffi = InstanceType<
  (typeof CryptoErrorUniffi)[keyof Omit<typeof CryptoErrorUniffi, "instanceOf">]
>;

// FfiConverter for enum CryptoErrorUniffi
const FfiConverterTypeCryptoErrorUniffi = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = CryptoErrorUniffi;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new CryptoErrorUniffi.InvalidKeyLength(
            FfiConverterUInt64.read(from),
            FfiConverterUInt64.read(from),
          );
        case 2:
          return new CryptoErrorUniffi.InvalidNonceLength();
        case 3:
          return new CryptoErrorUniffi.InvalidSealerSecretFormat();
        case 4:
          return new CryptoErrorUniffi.InvalidSignatureLength();
        case 5:
          return new CryptoErrorUniffi.InvalidVerifyingKey(
            FfiConverterString.read(from),
          );
        case 6:
          return new CryptoErrorUniffi.InvalidPublicKey(
            FfiConverterString.read(from),
          );
        case 7:
          return new CryptoErrorUniffi.WrongTag();
        case 8:
          return new CryptoErrorUniffi.CipherError();
        case 9:
          return new CryptoErrorUniffi.InvalidPrefix(
            FfiConverterString.read(from),
            FfiConverterString.read(from),
          );
        case 10:
          return new CryptoErrorUniffi.Base58Error(
            FfiConverterString.read(from),
          );
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner[0], into);
          FfiConverterUInt64.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          ordinalConverter.write(2, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          ordinalConverter.write(3, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          ordinalConverter.write(4, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          ordinalConverter.write(7, into);
          return;
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          ordinalConverter.write(8, into);
          return;
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          FfiConverterString.write(inner[1], into);
          return;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          ordinalConverter.write(10, into);
          const inner = value.inner;
          FfiConverterString.write(inner[0], into);
          return;
        }
        default:
          // Throwing from here means that CryptoErrorUniffi_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case CryptoErrorUniffi_Tags.InvalidKeyLength: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt64.allocationSize(inner[0]);
          size += FfiConverterUInt64.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidNonceLength: {
          return ordinalConverter.allocationSize(2);
        }
        case CryptoErrorUniffi_Tags.InvalidSealerSecretFormat: {
          return ordinalConverter.allocationSize(3);
        }
        case CryptoErrorUniffi_Tags.InvalidSignatureLength: {
          return ordinalConverter.allocationSize(4);
        }
        case CryptoErrorUniffi_Tags.InvalidVerifyingKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.InvalidPublicKey: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        case CryptoErrorUniffi_Tags.WrongTag: {
          return ordinalConverter.allocationSize(7);
        }
        case CryptoErrorUniffi_Tags.CipherError: {
          return ordinalConverter.allocationSize(8);
        }
        case CryptoErrorUniffi_Tags.InvalidPrefix: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterString.allocationSize(inner[0]);
          size += FfiConverterString.allocationSize(inner[1]);
          return size;
        }
        case CryptoErrorUniffi_Tags.Base58Error: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(10);
          size += FfiConverterString.allocationSize(inner[0]);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_cojson_core_uniffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_sign() !==
    20009
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_sign",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_signature_from_bytes() !==
    11422
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_signature_from_bytes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_from_bytes() !==
    30324
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_from_bytes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_sign() !==
    62782
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_sign",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_to_public() !==
    40891
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_signing_key_to_public",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_verify() !==
    37569
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_verify",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_verifying_key() !==
    15441
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_verifying_key",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_ed25519_verifying_key_from_bytes() !==
    20470
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_ed25519_verifying_key_from_bytes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_cojson_core_uniffi_checksum_func_new_ed25519_signing_key() !==
    15369
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_cojson_core_uniffi_checksum_func_new_ed25519_signing_key",
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeCryptoErrorUniffi,
  },
});
