<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/favicon.ico
      " />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.blue.min.css" />
  <title>Jazz Demo</title>

  <style>
    /* Blue color for light color scheme (Default) */
    /* Can be forced with data-theme="light" */
    [data-theme='light'],
    :root:not([data-theme='dark']),
    :host:not([data-theme='dark']) {
      --pico-text-selection-color: rgba(20, 106, 255, 0.25);
      --pico-primary: #146aff;
      --pico-primary-background: #146aff;
      --pico-primary-underline: rgba(20, 106, 255, 0.5);
      --pico-primary-hover: #0e4acb;
      --pico-primary-hover-background: #0e4acb;
      --pico-primary-focus: rgba(20, 106, 255, 0.5);
      --pico-primary-inverse: #fff;
    }

    /* Blue color for dark color scheme (Auto) */
    /* Automatically enabled if user has Dark mode enabled */
    @media only screen and (prefers-color-scheme: dark) {

      :root:not([data-theme]),
      :host:not([data-theme]) {
        --pico-text-selection-color: rgba(92, 146, 255, 0.1875);
        --pico-primary: #5c92ff;
        --pico-primary-background: #146aff;
        --pico-primary-underline: rgba(92, 146, 255, 0.5);
        --pico-primary-hover: #85b0ff;
        --pico-primary-hover-background: #2f74ff;
        --pico-primary-focus: rgba(92, 146, 255, 0.375);
        --pico-primary-inverse: #fff;
      }
    }

    /* Blue color for dark color scheme (Forced) */
    /* Enabled if forced with data-theme="dark" */
    [data-theme='dark'] {
      --pico-text-selection-color: rgba(92, 146, 255, 0.1875);
      --pico-primary: #5c92ff;
      --pico-primary-background: #146aff;
      --pico-primary-underline: rgba(92, 146, 255, 0.5);
      --pico-primary-hover: #85b0ff;
      --pico-primary-hover-background: #2f74ff;
      --pico-primary-focus: rgba(92, 146, 255, 0.375);
      --pico-primary-inverse: #fff;
    }
  </style>
</head>

<body>
  <main class="container">
    <svg viewBox="0 0 386 146" fill="currentColor" xmlns="http://www.w3.org/2000/svg" alt="Jazz logo"
      style="max-width: 30%">
      <path id="text" fill="currentColor"
        d="M176.725 33.865H188.275V22.7H176.725V33.865ZM164.9 129.4H172.875C182.72 129.4 188.275 123.9 188.275 114.22V43.6H176.725V109.545C176.725 115.65 173.975 118.51 167.925 118.51H164.9V129.4ZM245.298 53.28C241.613 45.47 233.363 41.95 222.748 41.95C208.998 41.95 200.748 48.44 197.888 58.615L208.613 61.915C210.648 55.315 216.368 52.565 222.638 52.565C231.933 52.565 235.673 56.415 236.058 64.61C226.433 65.93 216.643 67.195 209.768 69.23C200.583 72.145 195.743 77.865 195.743 86.83C195.743 96.51 202.673 104.65 215.818 104.65C225.443 104.65 232.318 101.35 237.213 94.365V103H247.388V66.425C247.388 61.475 247.168 57.185 245.298 53.28ZM217.853 95.245C210.483 95.245 207.128 91.34 207.128 86.72C207.128 82.045 210.593 79.515 215.323 77.92C220.328 76.435 226.983 75.5 235.948 74.18C235.893 76.93 235.673 80.725 234.738 83.475C233.418 89.25 227.643 95.245 217.853 95.245ZM251.22 103H301.545V92.715H269.535L303.195 45.47V43.6H254.3V53.885H284.935L251.22 101.185V103ZM304.815 103H355.14V92.715H323.13L356.79 45.47V43.6H307.895V53.885H338.53L304.815 101.185V103Z" />
      <path fillRule="evenodd" clipRule="evenodd"
        d="M136.179 44.8277C136.179 44.8277 136.179 44.8277 136.179 44.8276V21.168C117.931 28.5527 97.9854 32.6192 77.0897 32.6192C65.1466 32.6192 53.5138 31.2908 42.331 28.7737V51.4076C42.331 51.4076 42.331 51.4076 42.331 51.4076V81.1508C41.2955 80.4385 40.1568 79.8458 38.9405 79.3915C36.1732 78.358 33.128 78.0876 30.1902 78.6145C27.2524 79.1414 24.5539 80.4419 22.4358 82.3516C20.3178 84.2613 18.8754 86.6944 18.291 89.3433C17.7066 91.9921 18.0066 94.7377 19.1528 97.2329C20.2991 99.728 22.2403 101.861 24.7308 103.361C27.2214 104.862 30.1495 105.662 33.1448 105.662H33.1455C33.6061 105.662 33.8365 105.662 34.0314 105.659C44.5583 105.449 53.042 96.9656 53.2513 86.4386C53.2534 86.3306 53.2544 86.2116 53.2548 86.0486H53.2552V85.7149L53.2552 85.5521V82.0762L53.2552 53.1993C61.0533 54.2324 69.0092 54.7656 77.0897 54.7656C77.6696 54.7656 78.2489 54.7629 78.8276 54.7574V110.696C77.792 109.983 76.6533 109.391 75.437 108.936C72.6697 107.903 69.6246 107.632 66.6867 108.159C63.7489 108.686 61.0504 109.987 58.9323 111.896C56.8143 113.806 55.3719 116.239 54.7875 118.888C54.2032 121.537 54.5031 124.283 55.6494 126.778C56.7956 129.273 58.7368 131.405 61.2273 132.906C63.7179 134.406 66.646 135.207 69.6414 135.207C70.1024 135.207 70.3329 135.207 70.5279 135.203C81.0548 134.994 89.5385 126.51 89.7478 115.983C89.7517 115.788 89.7517 115.558 89.7517 115.097V111.621L89.7517 54.3266C101.962 53.4768 113.837 51.4075 125.255 48.2397V80.9017C124.219 80.1894 123.081 79.5966 121.864 79.1424C119.097 78.1089 116.052 77.8384 113.114 78.3653C110.176 78.8922 107.478 80.1927 105.36 82.1025C103.242 84.0122 101.799 86.4453 101.215 89.0941C100.631 91.743 100.931 94.4886 102.077 96.9837C103.223 99.4789 105.164 101.612 107.655 103.112C110.145 104.612 113.073 105.413 116.069 105.413C116.53 105.413 116.76 105.413 116.955 105.409C127.482 105.2 135.966 96.7164 136.175 86.1895C136.179 85.9945 136.179 85.764 136.179 85.3029V81.8271L136.179 44.8277Z"
        fill="#146AFF" />
    </svg>
    <article id="app"></article>
  </main>
  <script type="module">
    (function () { const A = document.createElement("link").relList; if (A && A.supports && A.supports("modulepreload")) return; for (const t of document.querySelectorAll('link[rel="modulepreload"]')) I(t); new MutationObserver(t => { for (const i of t) if (i.type === "childList") for (const n of i.addedNodes) n.tagName === "LINK" && n.rel === "modulepreload" && I(n) }).observe(document, { childList: !0, subtree: !0 }); function g(t) { const i = {}; return t.integrity && (i.integrity = t.integrity), t.referrerPolicy && (i.referrerPolicy = t.referrerPolicy), t.crossOrigin === "use-credentials" ? i.credentials = "include" : t.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function I(t) { if (t.ep) return; t.ep = !0; const i = g(t); fetch(t.href, i) } })(); var su = Object.defineProperty, QC = (e, A) => { for (var g in A) su(e, g, { get: A[g], enumerable: !0 }) }; const sC = Object.freeze({ status: "aborted" }); function l(e, A, g) { function I(r, o) { var C; Object.defineProperty(r, "_zod", { value: r._zod ?? {}, enumerable: !1 }), (C = r._zod).traits ?? (C.traits = new Set), r._zod.traits.add(e), A(r, o); for (const B in n.prototype) B in r || Object.defineProperty(r, B, { value: n.prototype[B].bind(r) }); r._zod.constr = n, r._zod.def = o } const t = g?.Parent ?? Object; class i extends t { } Object.defineProperty(i, "name", { value: e }); function n(r) { var o; const C = g?.Parent ? new i : this; I(C, r), (o = C._zod).deferred ?? (o.deferred = []); for (const B of C._zod.deferred) B(); return C } return Object.defineProperty(n, "init", { value: I }), Object.defineProperty(n, Symbol.hasInstance, { value: r => g?.Parent && r instanceof g.Parent ? !0 : r?._zod?.traits?.has(e) }), Object.defineProperty(n, "name", { value: e }), n } const aC = Symbol("zod_brand"); class He extends Error { constructor() { super("Encountered Promise during synchronous parse. Use .parseAsync() instead.") } } class QI extends Error { constructor(A) { super(`Encountered unidirectional transform during encode: ${A}`), this.name = "ZodEncodeError" } } const Ht = {}; function DA(e) { return e && Object.assign(Ht, e), Ht } function au(e) { return e } function Eu(e) { return e } function cu(e) { } function uu(e) { throw new Error } function hu(e) { } function Mi(e) { const A = Object.values(e).filter(I => typeof I == "number"); return Object.entries(e).filter(([I, t]) => A.indexOf(+I) === -1).map(([I, t]) => t) } function N(e, A = "|") { return e.map(g => L(g)).join(A) } function Lt(e, A) { return typeof A == "bigint" ? A.toString() : A } function At(e) { return { get value() { { const A = e(); return Object.defineProperty(this, "value", { value: A }), A } } } } function Ve(e) { return e == null } function sI(e) { const A = e.startsWith("^") ? 1 : 0, g = e.endsWith("$") ? e.length - 1 : e.length; return e.slice(A, g) } function EC(e, A) { const g = (e.toString().split(".")[1] || "").length, I = A.toString(); let t = (I.split(".")[1] || "").length; if (t === 0 && /\d?e-\d?/.test(I)) { const o = I.match(/\d?e-(\d?)/); o?.[1] && (t = Number.parseInt(o[1])) } const i = g > t ? g : t, n = Number.parseInt(e.toFixed(i).replace(".", "")), r = Number.parseInt(A.toFixed(i).replace(".", "")); return n % r / 10 ** i } const $r = Symbol("evaluating"); function V(e, A, g) { let I; Object.defineProperty(e, A, { get() { if (I !== $r) return I === void 0 && (I = $r, I = g()), I }, set(t) { Object.defineProperty(e, A, { value: t }) }, configurable: !0 }) } function lu(e) { return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e)) } function me(e, A, g) { Object.defineProperty(e, A, { value: g, writable: !0, enumerable: !0, configurable: !0 }) } function ae(...e) { const A = {}; for (const g of e) { const I = Object.getOwnPropertyDescriptors(g); Object.assign(A, I) } return Object.defineProperties({}, A) } function wu(e) { return ae(e._zod.def) } function du(e, A) { return A ? A.reduce((g, I) => g?.[I], e) : e } function Du(e) { const A = Object.keys(e), g = A.map(I => e[I]); return Promise.all(g).then(I => { const t = {}; for (let i = 0; i < A.length; i++)t[A[i]] = I[i]; return t }) } function fu(e = 10) { const A = "abcdefghijklmnopqrstuvwxyz"; let g = ""; for (let I = 0; I < e; I++)g += A[Math.floor(Math.random() * A.length)]; return g } function ri(e) { return JSON.stringify(e) } const Fi = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => { }; function Bg(e) { return typeof e == "object" && e !== null && !Array.isArray(e) } const cC = At(() => { if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return !1; try { const e = Function; return new e(""), !0 } catch { return !1 } }); function xe(e) { if (Bg(e) === !1) return !1; const A = e.constructor; if (A === void 0) return !0; const g = A.prototype; return !(Bg(g) === !1 || Object.prototype.hasOwnProperty.call(g, "isPrototypeOf") === !1) } function aI(e) { return xe(e) ? { ...e } : Array.isArray(e) ? [...e] : e } function yu(e) { let A = 0; for (const g in e) Object.prototype.hasOwnProperty.call(e, g) && A++; return A } const pu = e => { const A = typeof e; switch (A) { case "undefined": return "undefined"; case "string": return "string"; case "number": return Number.isNaN(e) ? "nan" : "number"; case "boolean": return "boolean"; case "function": return "function"; case "bigint": return "bigint"; case "symbol": return "symbol"; case "object": return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object"; default: throw new Error(`Unknown data type: ${A}`) } }, qt = new Set(["string", "number", "symbol"]), uC = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]); function ye(e) { return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function JA(e, A, g) { const I = new e._zod.constr(A ?? e._zod.def); return (!A || g?.parent) && (I._zod.parent = e), I } function y(e) { const A = e; if (!A) return {}; if (typeof A == "string") return { error: () => A }; if (A?.message !== void 0) { if (A?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params"); A.error = A.message } return delete A.message, typeof A.error == "string" ? { ...A, error: () => A.error } : A } function mu(e) { let A; return new Proxy({}, { get(g, I, t) { return A ?? (A = e()), Reflect.get(A, I, t) }, set(g, I, t, i) { return A ?? (A = e()), Reflect.set(A, I, t, i) }, has(g, I) { return A ?? (A = e()), Reflect.has(A, I) }, deleteProperty(g, I) { return A ?? (A = e()), Reflect.deleteProperty(A, I) }, ownKeys(g) { return A ?? (A = e()), Reflect.ownKeys(A) }, getOwnPropertyDescriptor(g, I) { return A ?? (A = e()), Reflect.getOwnPropertyDescriptor(A, I) }, defineProperty(g, I, t) { return A ?? (A = e()), Reflect.defineProperty(A, I, t) } }) } function L(e) { return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}` } function hC(e) { return Object.keys(e).filter(A => e[A]._zod.optin === "optional" && e[A]._zod.optout === "optional") } const lC = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] }, wC = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] }; function dC(e, A) { const g = e._zod.def, I = ae(e._zod.def, { get shape() { const t = {}; for (const i in A) { if (!(i in g.shape)) throw new Error(`Unrecognized key: "${i}"`); A[i] && (t[i] = g.shape[i]) } return me(this, "shape", t), t }, checks: [] }); return JA(e, I) } function DC(e, A) { const g = e._zod.def, I = ae(e._zod.def, { get shape() { const t = { ...e._zod.def.shape }; for (const i in A) { if (!(i in g.shape)) throw new Error(`Unrecognized key: "${i}"`); A[i] && delete t[i] } return me(this, "shape", t), t }, checks: [] }); return JA(e, I) } function fC(e, A) { if (!xe(A)) throw new Error("Invalid input to extend: expected a plain object"); const g = e._zod.def.checks; if (g && g.length > 0) throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead."); const t = ae(e._zod.def, { get shape() { const i = { ...e._zod.def.shape, ...A }; return me(this, "shape", i), i }, checks: [] }); return JA(e, t) } function yC(e, A) { if (!xe(A)) throw new Error("Invalid input to safeExtend: expected a plain object"); const g = { ...e._zod.def, get shape() { const I = { ...e._zod.def.shape, ...A }; return me(this, "shape", I), I }, checks: e._zod.def.checks }; return JA(e, g) } function pC(e, A) { const g = ae(e._zod.def, { get shape() { const I = { ...e._zod.def.shape, ...A._zod.def.shape }; return me(this, "shape", I), I }, get catchall() { return A._zod.def.catchall }, checks: [] }); return JA(e, g) } function mC(e, A, g) { const I = ae(A._zod.def, { get shape() { const t = A._zod.def.shape, i = { ...t }; if (g) for (const n in g) { if (!(n in t)) throw new Error(`Unrecognized key: "${n}"`); g[n] && (i[n] = e ? new e({ type: "optional", innerType: t[n] }) : t[n]) } else for (const n in t) i[n] = e ? new e({ type: "optional", innerType: t[n] }) : t[n]; return me(this, "shape", i), i }, checks: [] }); return JA(A, I) } function NC(e, A, g) { const I = ae(A._zod.def, { get shape() { const t = A._zod.def.shape, i = { ...t }; if (g) for (const n in g) { if (!(n in i)) throw new Error(`Unrecognized key: "${n}"`); g[n] && (i[n] = new e({ type: "nonoptional", innerType: t[n] })) } else for (const n in t) i[n] = new e({ type: "nonoptional", innerType: t[n] }); return me(this, "shape", i), i }, checks: [] }); return JA(A, I) } function be(e, A = 0) { if (e.aborted === !0) return !0; for (let g = A; g < e.issues.length; g++)if (e.issues[g]?.continue !== !0) return !0; return !1 } function qA(e, A) { return A.map(g => { var I; return (I = g).path ?? (I.path = []), g.path.unshift(e), g }) } function Mg(e) { return typeof e == "string" ? e : e?.message } function OA(e, A, g) { const I = { ...e, path: e.path ?? [] }; if (!e.message) { const t = Mg(e.inst?._zod.def?.error?.(e)) ?? Mg(A?.error?.(e)) ?? Mg(g.customError?.(e)) ?? Mg(g.localeError?.(e)) ?? "Invalid input"; I.message = t } return delete I.inst, delete I.continue, A?.reportInput || delete I.input, I } function EI(e) { return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown" } function cI(e) { return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown" } function Qg(...e) { const [A, g, I] = e; return typeof A == "string" ? { message: A, code: "custom", input: g, inst: I } : { ...A } } function Nu(e) { return Object.entries(e).filter(([A, g]) => Number.isNaN(Number.parseInt(A, 10))).map(A => A[1]) } function kC(e) { const A = atob(e), g = new Uint8Array(A.length); for (let I = 0; I < A.length; I++)g[I] = A.charCodeAt(I); return g } function GC(e) { let A = ""; for (let g = 0; g < e.length; g++)A += String.fromCharCode(e[g]); return btoa(A) } function ku(e) { const A = e.replace(/-/g, "+").replace(/_/g, "/"), g = "=".repeat((4 - A.length % 4) % 4); return kC(A + g) } function Gu(e) { return GC(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "") } function Su(e) { const A = e.replace(/^0x/, ""); if (A.length % 2 !== 0) throw new Error("Invalid hex string length"); const g = new Uint8Array(A.length / 2); for (let I = 0; I < A.length; I += 2)g[I / 2] = Number.parseInt(A.slice(I, I + 2), 16); return g } function Mu(e) { return Array.from(e).map(A => A.toString(16).padStart(2, "0")).join("") } class Fu { constructor(...A) { } } const SC = Object.freeze(Object.defineProperty({ __proto__: null, BIGINT_FORMAT_RANGES: wC, Class: Fu, NUMBER_FORMAT_RANGES: lC, aborted: be, allowsEval: cC, assert: hu, assertEqual: au, assertIs: cu, assertNever: uu, assertNotEqual: Eu, assignProp: me, base64ToUint8Array: kC, base64urlToUint8Array: ku, cached: At, captureStackTrace: Fi, cleanEnum: Nu, cleanRegex: sI, clone: JA, cloneDef: wu, createTransparentProxy: mu, defineLazy: V, esc: ri, escapeRegex: ye, extend: fC, finalizeIssue: OA, floatSafeRemainder: EC, getElementAtPath: du, getEnumValues: Mi, getLengthableOrigin: cI, getParsedType: pu, getSizableOrigin: EI, hexToUint8Array: Su, isObject: Bg, isPlainObject: xe, issue: Qg, joinValues: N, jsonStringifyReplacer: Lt, merge: pC, mergeDefs: ae, normalizeParams: y, nullish: Ve, numKeys: yu, objectClone: lu, omit: DC, optionalKeys: hC, partial: mC, pick: dC, prefixIssues: qA, primitiveTypes: uC, promiseAllObject: Du, propertyKeyTypes: qt, randomString: fu, required: NC, safeExtend: yC, shallowClone: aI, stringifyPrimitive: L, uint8ArrayToBase64: GC, uint8ArrayToBase64url: Gu, uint8ArrayToHex: Mu, unwrapMessage: Mg }, Symbol.toStringTag, { value: "Module" })), MC = (e, A) => { e.name = "$ZodError", Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }), Object.defineProperty(e, "issues", { value: A, enumerable: !1 }), e.message = JSON.stringify(A, Lt, 2), Object.defineProperty(e, "toString", { value: () => e.message, enumerable: !1 }) }, Ui = l("$ZodError", MC), FA = l("$ZodError", MC, { Parent: Error }); function Ri(e, A = g => g.message) { const g = {}, I = []; for (const t of e.issues) t.path.length > 0 ? (g[t.path[0]] = g[t.path[0]] || [], g[t.path[0]].push(A(t))) : I.push(A(t)); return { formErrors: I, fieldErrors: g } } function bi(e, A) { const g = A || function (i) { return i.message }, I = { _errors: [] }, t = i => { for (const n of i.issues) if (n.code === "invalid_union" && n.errors.length) n.errors.map(r => t({ issues: r })); else if (n.code === "invalid_key") t({ issues: n.issues }); else if (n.code === "invalid_element") t({ issues: n.issues }); else if (n.path.length === 0) I._errors.push(g(n)); else { let r = I, o = 0; for (; o < n.path.length;) { const C = n.path[o]; o === n.path.length - 1 ? (r[C] = r[C] || { _errors: [] }, r[C]._errors.push(g(n))) : r[C] = r[C] || { _errors: [] }, r = r[C], o++ } } }; return t(e), I } function FC(e, A) { const g = A || function (i) { return i.message }, I = { errors: [] }, t = (i, n = []) => { var r, o; for (const C of i.issues) if (C.code === "invalid_union" && C.errors.length) C.errors.map(B => t({ issues: B }, C.path)); else if (C.code === "invalid_key") t({ issues: C.issues }, C.path); else if (C.code === "invalid_element") t({ issues: C.issues }, C.path); else { const B = [...n, ...C.path]; if (B.length === 0) { I.errors.push(g(C)); continue } let Q = I, s = 0; for (; s < B.length;) { const E = B[s], a = s === B.length - 1; typeof E == "string" ? (Q.properties ?? (Q.properties = {}), (r = Q.properties)[E] ?? (r[E] = { errors: [] }), Q = Q.properties[E]) : (Q.items ?? (Q.items = []), (o = Q.items)[E] ?? (o[E] = { errors: [] }), Q = Q.items[E]), a && Q.errors.push(g(C)), s++ } } }; return t(e), I } function UC(e) { const A = [], g = e.map(I => typeof I == "object" ? I.key : I); for (const I of g) typeof I == "number" ? A.push(`[${I}]`) : typeof I == "symbol" ? A.push(`[${JSON.stringify(String(I))}]`) : /[^\w$]/.test(I) ? A.push(`[${JSON.stringify(I)}]`) : (A.length && A.push("."), A.push(I)); return A.join("") } function RC(e) {
      const A = [], g = [...e.issues].sort((I, t) => (I.path ?? []).length - (t.path ?? []).length); for (const I of g) A.push(`✖ ${I.message}`), I.path?.length && A.push(`  → at ${UC(I.path)}`); return A.join(`
`)
    } const et = e => (A, g, I, t) => { const i = I ? Object.assign(I, { async: !1 }) : { async: !1 }, n = A._zod.run({ value: g, issues: [] }, i); if (n instanceof Promise) throw new He; if (n.issues.length) { const r = new (t?.Err ?? e)(n.issues.map(o => OA(o, i, DA()))); throw Fi(r, t?.callee), r } return n.value }, oi = et(FA), gt = e => async (A, g, I, t) => { const i = I ? Object.assign(I, { async: !0 }) : { async: !0 }; let n = A._zod.run({ value: g, issues: [] }, i); if (n instanceof Promise && (n = await n), n.issues.length) { const r = new (t?.Err ?? e)(n.issues.map(o => OA(o, i, DA()))); throw Fi(r, t?.callee), r } return n.value }, Ci = gt(FA), tt = e => (A, g, I) => { const t = I ? { ...I, async: !1 } : { async: !1 }, i = A._zod.run({ value: g, issues: [] }, t); if (i instanceof Promise) throw new He; return i.issues.length ? { success: !1, error: new (e ?? Ui)(i.issues.map(n => OA(n, t, DA()))) } : { success: !0, data: i.value } }, bC = tt(FA), It = e => async (A, g, I) => { const t = I ? Object.assign(I, { async: !0 }) : { async: !0 }; let i = A._zod.run({ value: g, issues: [] }, t); return i instanceof Promise && (i = await i), i.issues.length ? { success: !1, error: new e(i.issues.map(n => OA(n, t, DA()))) } : { success: !0, data: i.value } }, YC = It(FA), Yi = e => (A, g, I) => { const t = I ? Object.assign(I, { direction: "backward" }) : { direction: "backward" }; return et(e)(A, g, t) }, Uu = Yi(FA), Ki = e => (A, g, I) => et(e)(A, g, I), Ru = Ki(FA), vi = e => async (A, g, I) => { const t = I ? Object.assign(I, { direction: "backward" }) : { direction: "backward" }; return gt(e)(A, g, t) }, bu = vi(FA), Ji = e => async (A, g, I) => gt(e)(A, g, I), Yu = Ji(FA), Hi = e => (A, g, I) => { const t = I ? Object.assign(I, { direction: "backward" }) : { direction: "backward" }; return tt(e)(A, g, t) }, Ku = Hi(FA), Li = e => (A, g, I) => tt(e)(A, g, I), vu = Li(FA), qi = e => async (A, g, I) => { const t = I ? Object.assign(I, { direction: "backward" }) : { direction: "backward" }; return It(e)(A, g, t) }, Ju = qi(FA), xi = e => async (A, g, I) => It(e)(A, g, I), Hu = xi(FA), KC = /^[cC][^\s-]{8,}$/, vC = /^[0-9a-z]+$/, JC = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, HC = /^[0-9a-vA-V]{20}$/, LC = /^[A-Za-z0-9]{27}$/, qC = /^[a-zA-Z0-9_-]{21}$/, xC = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Lu = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, zC = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, sg = e => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, qu = sg(4), xu = sg(6), zu = sg(7), OC = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Ou = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, ju = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, jC = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, Tu = jC, Zu = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, Pu = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$"; function TC() { return new RegExp(Pu, "u") } const ZC = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, PC = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, VC = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, WC = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, XC = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, zi = /^[A-Za-z0-9_-]*$/, Oi = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, _C = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, $C = /^\+(?:[0-9]){6,14}[0-9]$/, AB = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", eB = new RegExp(`^${AB}$`); function gB(e) { const A = "(?:[01]\\d|2[0-3]):[0-5]\\d"; return typeof e.precision == "number" ? e.precision === -1 ? `${A}` : e.precision === 0 ? `${A}:[0-5]\\d` : `${A}:[0-5]\\d\\.\\d{${e.precision}}` : `${A}(?::[0-5]\\d(?:\\.\\d+)?)?` } function tB(e) { return new RegExp(`^${gB(e)}$`) } function IB(e) { const A = gB({ precision: e.precision }), g = ["Z"]; e.local && g.push(""), e.offset && g.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)"); const I = `${A}(?:${g.join("|")})`; return new RegExp(`^${AB}T(?:${I})$`) } const iB = e => { const A = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*"; return new RegExp(`^${A}$`) }, nB = /^-?\d+n?$/, rB = /^-?\d+$/, oB = /^-?\d+(?:\.\d+)?/, CB = /^(?:true|false)$/i, BB = /^null$/i, QB = /^undefined$/i, sB = /^[^A-Z]*$/, aB = /^[^a-z]*$/, EB = /^[0-9a-fA-F]*$/; function it(e, A) { return new RegExp(`^[A-Za-z0-9+/]{${e}}${A}$`) } function nt(e) { return new RegExp(`^[A-Za-z0-9_-]{${e}}$`) } const Vu = /^[0-9a-fA-F]{32}$/, Wu = it(22, "=="), Xu = nt(22), _u = /^[0-9a-fA-F]{40}$/, $u = it(27, "="), Ah = nt(27), eh = /^[0-9a-fA-F]{64}$/, gh = it(43, "="), th = nt(43), Ih = /^[0-9a-fA-F]{96}$/, ih = it(64, ""), nh = nt(64), rh = /^[0-9a-fA-F]{128}$/, oh = it(86, "=="), Ch = nt(86), ji = Object.freeze(Object.defineProperty({ __proto__: null, base64: XC, base64url: zi, bigint: nB, boolean: CB, browserEmail: Zu, cidrv4: VC, cidrv6: WC, cuid: KC, cuid2: vC, date: eB, datetime: IB, domain: _C, duration: xC, e164: $C, email: OC, emoji: TC, extendedDuration: Lu, guid: zC, hex: EB, hostname: Oi, html5Email: Ou, idnEmail: Tu, integer: rB, ipv4: ZC, ipv6: PC, ksuid: LC, lowercase: sB, md5_base64: Wu, md5_base64url: Xu, md5_hex: Vu, nanoid: qC, null: BB, number: oB, rfc5322Email: ju, sha1_base64: $u, sha1_base64url: Ah, sha1_hex: _u, sha256_base64: gh, sha256_base64url: th, sha256_hex: eh, sha384_base64: ih, sha384_base64url: nh, sha384_hex: Ih, sha512_base64: oh, sha512_base64url: Ch, sha512_hex: rh, string: iB, time: tB, ulid: JC, undefined: QB, unicodeEmail: jC, uppercase: aB, uuid: sg, uuid4: qu, uuid6: xu, uuid7: zu, xid: HC }, Symbol.toStringTag, { value: "Module" })), rA = l("$ZodCheck", (e, A) => { var g; e._zod ?? (e._zod = {}), e._zod.def = A, (g = e._zod).onattach ?? (g.onattach = []) }), cB = { number: "number", bigint: "bigint", object: "date" }, Ti = l("$ZodCheckLessThan", (e, A) => { rA.init(e, A); const g = cB[typeof A.value]; e._zod.onattach.push(I => { const t = I._zod.bag, i = (A.inclusive ? t.maximum : t.exclusiveMaximum) ?? Number.POSITIVE_INFINITY; A.value < i && (A.inclusive ? t.maximum = A.value : t.exclusiveMaximum = A.value) }), e._zod.check = I => { (A.inclusive ? I.value <= A.value : I.value < A.value) || I.issues.push({ origin: g, code: "too_big", maximum: A.value, input: I.value, inclusive: A.inclusive, inst: e, continue: !A.abort }) } }), Zi = l("$ZodCheckGreaterThan", (e, A) => { rA.init(e, A); const g = cB[typeof A.value]; e._zod.onattach.push(I => { const t = I._zod.bag, i = (A.inclusive ? t.minimum : t.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY; A.value > i && (A.inclusive ? t.minimum = A.value : t.exclusiveMinimum = A.value) }), e._zod.check = I => { (A.inclusive ? I.value >= A.value : I.value > A.value) || I.issues.push({ origin: g, code: "too_small", minimum: A.value, input: I.value, inclusive: A.inclusive, inst: e, continue: !A.abort }) } }), uB = l("$ZodCheckMultipleOf", (e, A) => { rA.init(e, A), e._zod.onattach.push(g => { var I; (I = g._zod.bag).multipleOf ?? (I.multipleOf = A.value) }), e._zod.check = g => { if (typeof g.value != typeof A.value) throw new Error("Cannot mix number and bigint in multiple_of check."); (typeof g.value == "bigint" ? g.value % A.value === BigInt(0) : EC(g.value, A.value) === 0) || g.issues.push({ origin: typeof g.value, code: "not_multiple_of", divisor: A.value, input: g.value, inst: e, continue: !A.abort }) } }), hB = l("$ZodCheckNumberFormat", (e, A) => { rA.init(e, A), A.format = A.format || "float64"; const g = A.format?.includes("int"), I = g ? "int" : "number", [t, i] = lC[A.format]; e._zod.onattach.push(n => { const r = n._zod.bag; r.format = A.format, r.minimum = t, r.maximum = i, g && (r.pattern = rB) }), e._zod.check = n => { const r = n.value; if (g) { if (!Number.isInteger(r)) { n.issues.push({ expected: I, format: A.format, code: "invalid_type", continue: !1, input: r, inst: e }); return } if (!Number.isSafeInteger(r)) { r > 0 ? n.issues.push({ input: r, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: I, continue: !A.abort }) : n.issues.push({ input: r, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: e, origin: I, continue: !A.abort }); return } } r < t && n.issues.push({ origin: "number", input: r, code: "too_small", minimum: t, inclusive: !0, inst: e, continue: !A.abort }), r > i && n.issues.push({ origin: "number", input: r, code: "too_big", maximum: i, inst: e }) } }), lB = l("$ZodCheckBigIntFormat", (e, A) => { rA.init(e, A); const [g, I] = wC[A.format]; e._zod.onattach.push(t => { const i = t._zod.bag; i.format = A.format, i.minimum = g, i.maximum = I }), e._zod.check = t => { const i = t.value; i < g && t.issues.push({ origin: "bigint", input: i, code: "too_small", minimum: g, inclusive: !0, inst: e, continue: !A.abort }), i > I && t.issues.push({ origin: "bigint", input: i, code: "too_big", maximum: I, inst: e }) } }), wB = l("$ZodCheckMaxSize", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.size !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag.maximum ?? Number.POSITIVE_INFINITY; A.maximum < t && (I._zod.bag.maximum = A.maximum) }), e._zod.check = I => { const t = I.value; t.size <= A.maximum || I.issues.push({ origin: EI(t), code: "too_big", maximum: A.maximum, inclusive: !0, input: t, inst: e, continue: !A.abort }) } }), dB = l("$ZodCheckMinSize", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.size !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; A.minimum > t && (I._zod.bag.minimum = A.minimum) }), e._zod.check = I => { const t = I.value; t.size >= A.minimum || I.issues.push({ origin: EI(t), code: "too_small", minimum: A.minimum, inclusive: !0, input: t, inst: e, continue: !A.abort }) } }), DB = l("$ZodCheckSizeEquals", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.size !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag; t.minimum = A.size, t.maximum = A.size, t.size = A.size }), e._zod.check = I => { const t = I.value, i = t.size; if (i === A.size) return; const n = i > A.size; I.issues.push({ origin: EI(t), ...n ? { code: "too_big", maximum: A.size } : { code: "too_small", minimum: A.size }, inclusive: !0, exact: !0, input: I.value, inst: e, continue: !A.abort }) } }), fB = l("$ZodCheckMaxLength", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.length !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag.maximum ?? Number.POSITIVE_INFINITY; A.maximum < t && (I._zod.bag.maximum = A.maximum) }), e._zod.check = I => { const t = I.value; if (t.length <= A.maximum) return; const n = cI(t); I.issues.push({ origin: n, code: "too_big", maximum: A.maximum, inclusive: !0, input: t, inst: e, continue: !A.abort }) } }), yB = l("$ZodCheckMinLength", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.length !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag.minimum ?? Number.NEGATIVE_INFINITY; A.minimum > t && (I._zod.bag.minimum = A.minimum) }), e._zod.check = I => { const t = I.value; if (t.length >= A.minimum) return; const n = cI(t); I.issues.push({ origin: n, code: "too_small", minimum: A.minimum, inclusive: !0, input: t, inst: e, continue: !A.abort }) } }), pB = l("$ZodCheckLengthEquals", (e, A) => { var g; rA.init(e, A), (g = e._zod.def).when ?? (g.when = I => { const t = I.value; return !Ve(t) && t.length !== void 0 }), e._zod.onattach.push(I => { const t = I._zod.bag; t.minimum = A.length, t.maximum = A.length, t.length = A.length }), e._zod.check = I => { const t = I.value, i = t.length; if (i === A.length) return; const n = cI(t), r = i > A.length; I.issues.push({ origin: n, ...r ? { code: "too_big", maximum: A.length } : { code: "too_small", minimum: A.length }, inclusive: !0, exact: !0, input: I.value, inst: e, continue: !A.abort }) } }), rt = l("$ZodCheckStringFormat", (e, A) => { var g, I; rA.init(e, A), e._zod.onattach.push(t => { const i = t._zod.bag; i.format = A.format, A.pattern && (i.patterns ?? (i.patterns = new Set), i.patterns.add(A.pattern)) }), A.pattern ? (g = e._zod).check ?? (g.check = t => { A.pattern.lastIndex = 0, !A.pattern.test(t.value) && t.issues.push({ origin: "string", code: "invalid_format", format: A.format, input: t.value, ...A.pattern ? { pattern: A.pattern.toString() } : {}, inst: e, continue: !A.abort }) }) : (I = e._zod).check ?? (I.check = () => { }) }), mB = l("$ZodCheckRegex", (e, A) => { rt.init(e, A), e._zod.check = g => { A.pattern.lastIndex = 0, !A.pattern.test(g.value) && g.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: g.value, pattern: A.pattern.toString(), inst: e, continue: !A.abort }) } }), NB = l("$ZodCheckLowerCase", (e, A) => { A.pattern ?? (A.pattern = sB), rt.init(e, A) }), kB = l("$ZodCheckUpperCase", (e, A) => { A.pattern ?? (A.pattern = aB), rt.init(e, A) }), GB = l("$ZodCheckIncludes", (e, A) => { rA.init(e, A); const g = ye(A.includes), I = new RegExp(typeof A.position == "number" ? `^.{${A.position}}${g}` : g); A.pattern = I, e._zod.onattach.push(t => { const i = t._zod.bag; i.patterns ?? (i.patterns = new Set), i.patterns.add(I) }), e._zod.check = t => { t.value.includes(A.includes, A.position) || t.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: A.includes, input: t.value, inst: e, continue: !A.abort }) } }), SB = l("$ZodCheckStartsWith", (e, A) => { rA.init(e, A); const g = new RegExp(`^${ye(A.prefix)}.*`); A.pattern ?? (A.pattern = g), e._zod.onattach.push(I => { const t = I._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(g) }), e._zod.check = I => { I.value.startsWith(A.prefix) || I.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: A.prefix, input: I.value, inst: e, continue: !A.abort }) } }), MB = l("$ZodCheckEndsWith", (e, A) => { rA.init(e, A); const g = new RegExp(`.*${ye(A.suffix)}$`); A.pattern ?? (A.pattern = g), e._zod.onattach.push(I => { const t = I._zod.bag; t.patterns ?? (t.patterns = new Set), t.patterns.add(g) }), e._zod.check = I => { I.value.endsWith(A.suffix) || I.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: A.suffix, input: I.value, inst: e, continue: !A.abort }) } }); function Ao(e, A, g) { e.issues.length && A.issues.push(...qA(g, e.issues)) } const FB = l("$ZodCheckProperty", (e, A) => { rA.init(e, A), e._zod.check = g => { const I = A.schema._zod.run({ value: g.value[A.property], issues: [] }, {}); if (I instanceof Promise) return I.then(t => Ao(t, g, A.property)); Ao(I, g, A.property) } }), UB = l("$ZodCheckMimeType", (e, A) => { rA.init(e, A); const g = new Set(A.mime); e._zod.onattach.push(I => { I._zod.bag.mime = A.mime }), e._zod.check = I => { g.has(I.value.type) || I.issues.push({ code: "invalid_value", values: A.mime, input: I.value.type, inst: e, continue: !A.abort }) } }), RB = l("$ZodCheckOverwrite", (e, A) => { rA.init(e, A), e._zod.check = g => { g.value = A.tx(g.value) } }); class bB {
      constructor(A = []) { this.content = [], this.indent = 0, this && (this.args = A) } indented(A) { this.indent += 1, A(this), this.indent -= 1 } write(A) {
        if (typeof A == "function") { A(this, { execution: "sync" }), A(this, { execution: "async" }); return } const I = A.split(`
`).filter(n => n), t = Math.min(...I.map(n => n.length - n.trimStart().length)), i = I.map(n => n.slice(t)).map(n => " ".repeat(this.indent * 2) + n); for (const n of i) this.content.push(n)
      } compile() {
        const A = Function, g = this?.args, t = [...(this?.content ?? [""]).map(i => `  ${i}`)]; return new A(...g, t.join(`
`))
      }
    } const YB = { major: 4, minor: 1, patch: 11 }, z = l("$ZodType", (e, A) => { var g; e ?? (e = {}), e._zod.def = A, e._zod.bag = e._zod.bag || {}, e._zod.version = YB; const I = [...e._zod.def.checks ?? []]; e._zod.traits.has("$ZodCheck") && I.unshift(e); for (const t of I) for (const i of t._zod.onattach) i(e); if (I.length === 0) (g = e._zod).deferred ?? (g.deferred = []), e._zod.deferred?.push(() => { e._zod.run = e._zod.parse }); else { const t = (n, r, o) => { let C = be(n), B; for (const Q of r) { if (Q._zod.def.when) { if (!Q._zod.def.when(n)) continue } else if (C) continue; const s = n.issues.length, E = Q._zod.check(n); if (E instanceof Promise && o?.async === !1) throw new He; if (B || E instanceof Promise) B = (B ?? Promise.resolve()).then(async () => { await E, n.issues.length !== s && (C || (C = be(n, s))) }); else { if (n.issues.length === s) continue; C || (C = be(n, s)) } } return B ? B.then(() => n) : n }, i = (n, r, o) => { if (be(n)) return n.aborted = !0, n; const C = t(r, I, o); if (C instanceof Promise) { if (o.async === !1) throw new He; return C.then(B => e._zod.parse(B, o)) } return e._zod.parse(C, o) }; e._zod.run = (n, r) => { if (r.skipChecks) return e._zod.parse(n, r); if (r.direction === "backward") { const C = e._zod.parse({ value: n.value, issues: [] }, { ...r, skipChecks: !0 }); return C instanceof Promise ? C.then(B => i(B, n, r)) : i(C, n, r) } const o = e._zod.parse(n, r); if (o instanceof Promise) { if (r.async === !1) throw new He; return o.then(C => t(C, I, r)) } return t(o, I, r) } } e["~standard"] = { validate: t => { try { const i = bC(e, t); return i.success ? { value: i.data } : { issues: i.error?.issues } } catch { return YC(e, t).then(n => n.success ? { value: n.data } : { issues: n.error?.issues }) } }, vendor: "zod", version: 1 } }), ot = l("$ZodString", (e, A) => { z.init(e, A), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? iB(e._zod.bag), e._zod.parse = (g, I) => { if (A.coerce) try { g.value = String(g.value) } catch { } return typeof g.value == "string" || g.issues.push({ expected: "string", code: "invalid_type", input: g.value, inst: e }), g } }), tA = l("$ZodStringFormat", (e, A) => { rt.init(e, A), ot.init(e, A) }), KB = l("$ZodGUID", (e, A) => { A.pattern ?? (A.pattern = zC), tA.init(e, A) }), vB = l("$ZodUUID", (e, A) => { if (A.version) { const I = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[A.version]; if (I === void 0) throw new Error(`Invalid UUID version: "${A.version}"`); A.pattern ?? (A.pattern = sg(I)) } else A.pattern ?? (A.pattern = sg()); tA.init(e, A) }), JB = l("$ZodEmail", (e, A) => { A.pattern ?? (A.pattern = OC), tA.init(e, A) }), HB = l("$ZodURL", (e, A) => { tA.init(e, A), e._zod.check = g => { try { const I = g.value.trim(), t = new URL(I); A.hostname && (A.hostname.lastIndex = 0, A.hostname.test(t.hostname) || g.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: Oi.source, input: g.value, inst: e, continue: !A.abort })), A.protocol && (A.protocol.lastIndex = 0, A.protocol.test(t.protocol.endsWith(":") ? t.protocol.slice(0, -1) : t.protocol) || g.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: A.protocol.source, input: g.value, inst: e, continue: !A.abort })), A.normalize ? g.value = t.href : g.value = I; return } catch { g.issues.push({ code: "invalid_format", format: "url", input: g.value, inst: e, continue: !A.abort }) } } }), LB = l("$ZodEmoji", (e, A) => { A.pattern ?? (A.pattern = TC()), tA.init(e, A) }), qB = l("$ZodNanoID", (e, A) => { A.pattern ?? (A.pattern = qC), tA.init(e, A) }), xB = l("$ZodCUID", (e, A) => { A.pattern ?? (A.pattern = KC), tA.init(e, A) }), zB = l("$ZodCUID2", (e, A) => { A.pattern ?? (A.pattern = vC), tA.init(e, A) }), OB = l("$ZodULID", (e, A) => { A.pattern ?? (A.pattern = JC), tA.init(e, A) }), jB = l("$ZodXID", (e, A) => { A.pattern ?? (A.pattern = HC), tA.init(e, A) }), TB = l("$ZodKSUID", (e, A) => { A.pattern ?? (A.pattern = LC), tA.init(e, A) }), ZB = l("$ZodISODateTime", (e, A) => { A.pattern ?? (A.pattern = IB(A)), tA.init(e, A) }), PB = l("$ZodISODate", (e, A) => { A.pattern ?? (A.pattern = eB), tA.init(e, A) }), VB = l("$ZodISOTime", (e, A) => { A.pattern ?? (A.pattern = tB(A)), tA.init(e, A) }), WB = l("$ZodISODuration", (e, A) => { A.pattern ?? (A.pattern = xC), tA.init(e, A) }), XB = l("$ZodIPv4", (e, A) => { A.pattern ?? (A.pattern = ZC), tA.init(e, A), e._zod.onattach.push(g => { const I = g._zod.bag; I.format = "ipv4" }) }), _B = l("$ZodIPv6", (e, A) => { A.pattern ?? (A.pattern = PC), tA.init(e, A), e._zod.onattach.push(g => { const I = g._zod.bag; I.format = "ipv6" }), e._zod.check = g => { try { new URL(`http://[${g.value}]`) } catch { g.issues.push({ code: "invalid_format", format: "ipv6", input: g.value, inst: e, continue: !A.abort }) } } }), $B = l("$ZodCIDRv4", (e, A) => { A.pattern ?? (A.pattern = VC), tA.init(e, A) }), AQ = l("$ZodCIDRv6", (e, A) => { A.pattern ?? (A.pattern = WC), tA.init(e, A), e._zod.check = g => { const I = g.value.split("/"); try { if (I.length !== 2) throw new Error; const [t, i] = I; if (!i) throw new Error; const n = Number(i); if (`${n}` !== i) throw new Error; if (n < 0 || n > 128) throw new Error; new URL(`http://[${t}]`) } catch { g.issues.push({ code: "invalid_format", format: "cidrv6", input: g.value, inst: e, continue: !A.abort }) } } }); function Pi(e) { if (e === "") return !0; if (e.length % 4 !== 0) return !1; try { return atob(e), !0 } catch { return !1 } } const eQ = l("$ZodBase64", (e, A) => { A.pattern ?? (A.pattern = XC), tA.init(e, A), e._zod.onattach.push(g => { g._zod.bag.contentEncoding = "base64" }), e._zod.check = g => { Pi(g.value) || g.issues.push({ code: "invalid_format", format: "base64", input: g.value, inst: e, continue: !A.abort }) } }); function gQ(e) { if (!zi.test(e)) return !1; const A = e.replace(/[-_]/g, I => I === "-" ? "+" : "/"), g = A.padEnd(Math.ceil(A.length / 4) * 4, "="); return Pi(g) } const tQ = l("$ZodBase64URL", (e, A) => { A.pattern ?? (A.pattern = zi), tA.init(e, A), e._zod.onattach.push(g => { g._zod.bag.contentEncoding = "base64url" }), e._zod.check = g => { gQ(g.value) || g.issues.push({ code: "invalid_format", format: "base64url", input: g.value, inst: e, continue: !A.abort }) } }), IQ = l("$ZodE164", (e, A) => { A.pattern ?? (A.pattern = $C), tA.init(e, A) }); function iQ(e, A = null) { try { const g = e.split("."); if (g.length !== 3) return !1; const [I] = g; if (!I) return !1; const t = JSON.parse(atob(I)); return !("typ" in t && t?.typ !== "JWT" || !t.alg || A && (!("alg" in t) || t.alg !== A)) } catch { return !1 } } const nQ = l("$ZodJWT", (e, A) => { tA.init(e, A), e._zod.check = g => { iQ(g.value, A.alg) || g.issues.push({ code: "invalid_format", format: "jwt", input: g.value, inst: e, continue: !A.abort }) } }), rQ = l("$ZodCustomStringFormat", (e, A) => { tA.init(e, A), e._zod.check = g => { A.fn(g.value) || g.issues.push({ code: "invalid_format", format: A.format, input: g.value, inst: e, continue: !A.abort }) } }), Vi = l("$ZodNumber", (e, A) => { z.init(e, A), e._zod.pattern = e._zod.bag.pattern ?? oB, e._zod.parse = (g, I) => { if (A.coerce) try { g.value = Number(g.value) } catch { } const t = g.value; if (typeof t == "number" && !Number.isNaN(t) && Number.isFinite(t)) return g; const i = typeof t == "number" ? Number.isNaN(t) ? "NaN" : Number.isFinite(t) ? void 0 : "Infinity" : void 0; return g.issues.push({ expected: "number", code: "invalid_type", input: t, inst: e, ...i ? { received: i } : {} }), g } }), oQ = l("$ZodNumber", (e, A) => { hB.init(e, A), Vi.init(e, A) }), Wi = l("$ZodBoolean", (e, A) => { z.init(e, A), e._zod.pattern = CB, e._zod.parse = (g, I) => { if (A.coerce) try { g.value = !!g.value } catch { } const t = g.value; return typeof t == "boolean" || g.issues.push({ expected: "boolean", code: "invalid_type", input: t, inst: e }), g } }), Xi = l("$ZodBigInt", (e, A) => { z.init(e, A), e._zod.pattern = nB, e._zod.parse = (g, I) => { if (A.coerce) try { g.value = BigInt(g.value) } catch { } return typeof g.value == "bigint" || g.issues.push({ expected: "bigint", code: "invalid_type", input: g.value, inst: e }), g } }), CQ = l("$ZodBigInt", (e, A) => { lB.init(e, A), Xi.init(e, A) }), BQ = l("$ZodSymbol", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; return typeof t == "symbol" || g.issues.push({ expected: "symbol", code: "invalid_type", input: t, inst: e }), g } }), QQ = l("$ZodUndefined", (e, A) => { z.init(e, A), e._zod.pattern = QB, e._zod.values = new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (g, I) => { const t = g.value; return typeof t > "u" || g.issues.push({ expected: "undefined", code: "invalid_type", input: t, inst: e }), g } }), sQ = l("$ZodNull", (e, A) => { z.init(e, A), e._zod.pattern = BB, e._zod.values = new Set([null]), e._zod.parse = (g, I) => { const t = g.value; return t === null || g.issues.push({ expected: "null", code: "invalid_type", input: t, inst: e }), g } }), aQ = l("$ZodAny", (e, A) => { z.init(e, A), e._zod.parse = g => g }), EQ = l("$ZodUnknown", (e, A) => { z.init(e, A), e._zod.parse = g => g }), cQ = l("$ZodNever", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => (g.issues.push({ expected: "never", code: "invalid_type", input: g.value, inst: e }), g) }), uQ = l("$ZodVoid", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; return typeof t > "u" || g.issues.push({ expected: "void", code: "invalid_type", input: t, inst: e }), g } }), hQ = l("$ZodDate", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { if (A.coerce) try { g.value = new Date(g.value) } catch { } const t = g.value, i = t instanceof Date; return i && !Number.isNaN(t.getTime()) || g.issues.push({ expected: "date", code: "invalid_type", input: t, ...i ? { received: "Invalid Date" } : {}, inst: e }), g } }); function eo(e, A, g) { e.issues.length && A.issues.push(...qA(g, e.issues)), A.value[g] = e.value } const lQ = l("$ZodArray", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; if (!Array.isArray(t)) return g.issues.push({ expected: "array", code: "invalid_type", input: t, inst: e }), g; g.value = Array(t.length); const i = []; for (let n = 0; n < t.length; n++) { const r = t[n], o = A.element._zod.run({ value: r, issues: [] }, I); o instanceof Promise ? i.push(o.then(C => eo(C, g, n))) : eo(o, g, n) } return i.length ? Promise.all(i).then(() => g) : g } }); function xt(e, A, g, I) { e.issues.length && A.issues.push(...qA(g, e.issues)), e.value === void 0 ? g in I && (A.value[g] = void 0) : A.value[g] = e.value } function wQ(e) { const A = Object.keys(e.shape); for (const I of A) if (!e.shape?.[I]?._zod?.traits?.has("$ZodType")) throw new Error(`Invalid element at key "${I}": expected a Zod schema`); const g = hC(e.shape); return { ...e, keys: A, keySet: new Set(A), numKeys: A.length, optionalKeys: new Set(g) } } function dQ(e, A, g, I, t, i) { const n = [], r = t.keySet, o = t.catchall._zod, C = o.def.type; for (const B of Object.keys(A)) { if (r.has(B)) continue; if (C === "never") { n.push(B); continue } const Q = o.run({ value: A[B], issues: [] }, I); Q instanceof Promise ? e.push(Q.then(s => xt(s, g, B, A))) : xt(Q, g, B, A) } return n.length && g.issues.push({ code: "unrecognized_keys", keys: n, input: A, inst: i }), e.length ? Promise.all(e).then(() => g) : g } const DQ = l("$ZodObject", (e, A) => { if (z.init(e, A), !Object.getOwnPropertyDescriptor(A, "shape")?.get) { const r = A.shape; Object.defineProperty(A, "shape", { get: () => { const o = { ...r }; return Object.defineProperty(A, "shape", { value: o }), o } }) } const I = At(() => wQ(A)); V(e._zod, "propValues", () => { const r = A.shape, o = {}; for (const C in r) { const B = r[C]._zod; if (B.values) { o[C] ?? (o[C] = new Set); for (const Q of B.values) o[C].add(Q) } } return o }); const t = Bg, i = A.catchall; let n; e._zod.parse = (r, o) => { n ?? (n = I.value); const C = r.value; if (!t(C)) return r.issues.push({ expected: "object", code: "invalid_type", input: C, inst: e }), r; r.value = {}; const B = [], Q = n.shape; for (const s of n.keys) { const a = Q[s]._zod.run({ value: C[s], issues: [] }, o); a instanceof Promise ? B.push(a.then(c => xt(c, r, s, C))) : xt(a, r, s, C) } return i ? dQ(B, C, r, o, I.value, e) : B.length ? Promise.all(B).then(() => r) : r } }), fQ = l("$ZodObjectJIT", (e, A) => {
      DQ.init(e, A); const g = e._zod.parse, I = At(() => wQ(A)), t = s => {
        const E = new bB(["shape", "payload", "ctx"]), a = I.value, c = w => { const f = ri(w); return `shape[${f}]._zod.run({ value: input[${f}], issues: [] }, ctx)` }; E.write("const input = payload.value;"); const u = Object.create(null); let h = 0; for (const w of a.keys) u[w] = `key_${h++}`; E.write("const newResult = {};"); for (const w of a.keys) {
          const f = u[w], F = ri(w); E.write(`const ${f} = ${c(w)};`), E.write(`
        if (${f}.issues.length) {
          payload.issues = payload.issues.concat(${f}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${F}, ...iss.path] : [${F}]
          })));
        }
        
        
        if (${f}.value === undefined) {
          if (${F} in input) {
            newResult[${F}] = undefined;
          }
        } else {
          newResult[${F}] = ${f}.value;
        }
        
      `)
        } E.write("payload.value = newResult;"), E.write("return payload;"); const d = E.compile(); return (w, f) => d(s, w, f)
      }; let i; const n = Bg, r = !Ht.jitless, C = r && cC.value, B = A.catchall; let Q; e._zod.parse = (s, E) => { Q ?? (Q = I.value); const a = s.value; return n(a) ? r && C && E?.async === !1 && E.jitless !== !0 ? (i || (i = t(A.shape)), s = i(s, E), B ? dQ([], a, s, E, Q, e) : s) : g(s, E) : (s.issues.push({ expected: "object", code: "invalid_type", input: a, inst: e }), s) }
    }); function go(e, A, g, I) { for (const i of e) if (i.issues.length === 0) return A.value = i.value, A; const t = e.filter(i => !be(i)); return t.length === 1 ? (A.value = t[0].value, t[0]) : (A.issues.push({ code: "invalid_union", input: A.value, inst: g, errors: e.map(i => i.issues.map(n => OA(n, I, DA()))) }), A) } const uI = l("$ZodUnion", (e, A) => { z.init(e, A), V(e._zod, "optin", () => A.options.some(t => t._zod.optin === "optional") ? "optional" : void 0), V(e._zod, "optout", () => A.options.some(t => t._zod.optout === "optional") ? "optional" : void 0), V(e._zod, "values", () => { if (A.options.every(t => t._zod.values)) return new Set(A.options.flatMap(t => Array.from(t._zod.values))) }), V(e._zod, "pattern", () => { if (A.options.every(t => t._zod.pattern)) { const t = A.options.map(i => i._zod.pattern); return new RegExp(`^(${t.map(i => sI(i.source)).join("|")})$`) } }); const g = A.options.length === 1, I = A.options[0]._zod.run; e._zod.parse = (t, i) => { if (g) return I(t, i); let n = !1; const r = []; for (const o of A.options) { const C = o._zod.run({ value: t.value, issues: [] }, i); if (C instanceof Promise) r.push(C), n = !0; else { if (C.issues.length === 0) return C; r.push(C) } } return n ? Promise.all(r).then(o => go(o, t, e, i)) : go(r, t, e, i) } }), yQ = l("$ZodDiscriminatedUnion", (e, A) => { uI.init(e, A); const g = e._zod.parse; V(e._zod, "propValues", () => { const t = {}; for (const i of A.options) { const n = i._zod.propValues; if (!n || Object.keys(n).length === 0) throw new Error(`Invalid discriminated union option at index "${A.options.indexOf(i)}"`); for (const [r, o] of Object.entries(n)) { t[r] || (t[r] = new Set); for (const C of o) t[r].add(C) } } return t }); const I = At(() => { const t = A.options, i = new Map; for (const n of t) { const r = n._zod.propValues?.[A.discriminator]; if (!r || r.size === 0) throw new Error(`Invalid discriminated union option at index "${A.options.indexOf(n)}"`); for (const o of r) { if (i.has(o)) throw new Error(`Duplicate discriminator value "${String(o)}"`); i.set(o, n) } } return i }); e._zod.parse = (t, i) => { const n = t.value; if (!Bg(n)) return t.issues.push({ code: "invalid_type", expected: "object", input: n, inst: e }), t; const r = I.value.get(n?.[A.discriminator]); return r ? r._zod.run(t, i) : A.unionFallback ? g(t, i) : (t.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", discriminator: A.discriminator, input: n, path: [A.discriminator], inst: e }), t) } }), pQ = l("$ZodIntersection", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value, i = A.left._zod.run({ value: t, issues: [] }, I), n = A.right._zod.run({ value: t, issues: [] }, I); return i instanceof Promise || n instanceof Promise ? Promise.all([i, n]).then(([o, C]) => to(g, o, C)) : to(g, i, n) } }); function Bi(e, A) { if (e === A) return { valid: !0, data: e }; if (e instanceof Date && A instanceof Date && +e == +A) return { valid: !0, data: e }; if (xe(e) && xe(A)) { const g = Object.keys(A), I = Object.keys(e).filter(i => g.indexOf(i) !== -1), t = { ...e, ...A }; for (const i of I) { const n = Bi(e[i], A[i]); if (!n.valid) return { valid: !1, mergeErrorPath: [i, ...n.mergeErrorPath] }; t[i] = n.data } return { valid: !0, data: t } } if (Array.isArray(e) && Array.isArray(A)) { if (e.length !== A.length) return { valid: !1, mergeErrorPath: [] }; const g = []; for (let I = 0; I < e.length; I++) { const t = e[I], i = A[I], n = Bi(t, i); if (!n.valid) return { valid: !1, mergeErrorPath: [I, ...n.mergeErrorPath] }; g.push(n.data) } return { valid: !0, data: g } } return { valid: !1, mergeErrorPath: [] } } function to(e, A, g) { if (A.issues.length && e.issues.push(...A.issues), g.issues.length && e.issues.push(...g.issues), be(e)) return e; const I = Bi(A.value, g.value); if (!I.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(I.mergeErrorPath)}`); return e.value = I.data, e } const _i = l("$ZodTuple", (e, A) => { z.init(e, A); const g = A.items, I = g.length - [...g].reverse().findIndex(t => t._zod.optin !== "optional"); e._zod.parse = (t, i) => { const n = t.value; if (!Array.isArray(n)) return t.issues.push({ input: n, inst: e, expected: "tuple", code: "invalid_type" }), t; t.value = []; const r = []; if (!A.rest) { const C = n.length > g.length, B = n.length < I - 1; if (C || B) return t.issues.push({ ...C ? { code: "too_big", maximum: g.length } : { code: "too_small", minimum: g.length }, input: n, inst: e, origin: "array" }), t } let o = -1; for (const C of g) { if (o++, o >= n.length && o >= I) continue; const B = C._zod.run({ value: n[o], issues: [] }, i); B instanceof Promise ? r.push(B.then(Q => wt(Q, t, o))) : wt(B, t, o) } if (A.rest) { const C = n.slice(g.length); for (const B of C) { o++; const Q = A.rest._zod.run({ value: B, issues: [] }, i); Q instanceof Promise ? r.push(Q.then(s => wt(s, t, o))) : wt(Q, t, o) } } return r.length ? Promise.all(r).then(() => t) : t } }); function wt(e, A, g) { e.issues.length && A.issues.push(...qA(g, e.issues)), A.value[g] = e.value } const mQ = l("$ZodRecord", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; if (!xe(t)) return g.issues.push({ expected: "record", code: "invalid_type", input: t, inst: e }), g; const i = []; if (A.keyType._zod.values) { const n = A.keyType._zod.values; g.value = {}; for (const o of n) if (typeof o == "string" || typeof o == "number" || typeof o == "symbol") { const C = A.valueType._zod.run({ value: t[o], issues: [] }, I); C instanceof Promise ? i.push(C.then(B => { B.issues.length && g.issues.push(...qA(o, B.issues)), g.value[o] = B.value })) : (C.issues.length && g.issues.push(...qA(o, C.issues)), g.value[o] = C.value) } let r; for (const o in t) n.has(o) || (r = r ?? [], r.push(o)); r && r.length > 0 && g.issues.push({ code: "unrecognized_keys", input: t, inst: e, keys: r }) } else { g.value = {}; for (const n of Reflect.ownKeys(t)) { if (n === "__proto__") continue; const r = A.keyType._zod.run({ value: n, issues: [] }, I); if (r instanceof Promise) throw new Error("Async schemas not supported in object keys currently"); if (r.issues.length) { g.issues.push({ code: "invalid_key", origin: "record", issues: r.issues.map(C => OA(C, I, DA())), input: n, path: [n], inst: e }), g.value[r.value] = r.value; continue } const o = A.valueType._zod.run({ value: t[n], issues: [] }, I); o instanceof Promise ? i.push(o.then(C => { C.issues.length && g.issues.push(...qA(n, C.issues)), g.value[r.value] = C.value })) : (o.issues.length && g.issues.push(...qA(n, o.issues)), g.value[r.value] = o.value) } } return i.length ? Promise.all(i).then(() => g) : g } }), NQ = l("$ZodMap", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; if (!(t instanceof Map)) return g.issues.push({ expected: "map", code: "invalid_type", input: t, inst: e }), g; const i = []; g.value = new Map; for (const [n, r] of t) { const o = A.keyType._zod.run({ value: n, issues: [] }, I), C = A.valueType._zod.run({ value: r, issues: [] }, I); o instanceof Promise || C instanceof Promise ? i.push(Promise.all([o, C]).then(([B, Q]) => { Io(B, Q, g, n, t, e, I) })) : Io(o, C, g, n, t, e, I) } return i.length ? Promise.all(i).then(() => g) : g } }); function Io(e, A, g, I, t, i, n) { e.issues.length && (qt.has(typeof I) ? g.issues.push(...qA(I, e.issues)) : g.issues.push({ code: "invalid_key", origin: "map", input: t, inst: i, issues: e.issues.map(r => OA(r, n, DA())) })), A.issues.length && (qt.has(typeof I) ? g.issues.push(...qA(I, A.issues)) : g.issues.push({ origin: "map", code: "invalid_element", input: t, inst: i, key: I, issues: A.issues.map(r => OA(r, n, DA())) })), g.value.set(e.value, A.value) } const kQ = l("$ZodSet", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; if (!(t instanceof Set)) return g.issues.push({ input: t, inst: e, expected: "set", code: "invalid_type" }), g; const i = []; g.value = new Set; for (const n of t) { const r = A.valueType._zod.run({ value: n, issues: [] }, I); r instanceof Promise ? i.push(r.then(o => io(o, g))) : io(r, g) } return i.length ? Promise.all(i).then(() => g) : g } }); function io(e, A) { e.issues.length && A.issues.push(...e.issues), A.value.add(e.value) } const GQ = l("$ZodEnum", (e, A) => { z.init(e, A); const g = Mi(A.entries), I = new Set(g); e._zod.values = I, e._zod.pattern = new RegExp(`^(${g.filter(t => qt.has(typeof t)).map(t => typeof t == "string" ? ye(t) : t.toString()).join("|")})$`), e._zod.parse = (t, i) => { const n = t.value; return I.has(n) || t.issues.push({ code: "invalid_value", values: g, input: n, inst: e }), t } }), SQ = l("$ZodLiteral", (e, A) => { if (z.init(e, A), A.values.length === 0) throw new Error("Cannot create literal schema with no valid values"); e._zod.values = new Set(A.values), e._zod.pattern = new RegExp(`^(${A.values.map(g => typeof g == "string" ? ye(g) : g ? ye(g.toString()) : String(g)).join("|")})$`), e._zod.parse = (g, I) => { const t = g.value; return e._zod.values.has(t) || g.issues.push({ code: "invalid_value", values: A.values, input: t, inst: e }), g } }), MQ = l("$ZodFile", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { const t = g.value; return t instanceof File || g.issues.push({ expected: "file", code: "invalid_type", input: t, inst: e }), g } }), FQ = l("$ZodTransform", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { if (I.direction === "backward") throw new QI(e.constructor.name); const t = A.transform(g.value, g); if (I.async) return (t instanceof Promise ? t : Promise.resolve(t)).then(n => (g.value = n, g)); if (t instanceof Promise) throw new He; return g.value = t, g } }); function no(e, A) { return e.issues.length && A === void 0 ? { issues: [], value: void 0 } : e } const UQ = l("$ZodOptional", (e, A) => { z.init(e, A), e._zod.optin = "optional", e._zod.optout = "optional", V(e._zod, "values", () => A.innerType._zod.values ? new Set([...A.innerType._zod.values, void 0]) : void 0), V(e._zod, "pattern", () => { const g = A.innerType._zod.pattern; return g ? new RegExp(`^(${sI(g.source)})?$`) : void 0 }), e._zod.parse = (g, I) => { if (A.innerType._zod.optin === "optional") { const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(i => no(i, g.value)) : no(t, g.value) } return g.value === void 0 ? g : A.innerType._zod.run(g, I) } }), RQ = l("$ZodNullable", (e, A) => { z.init(e, A), V(e._zod, "optin", () => A.innerType._zod.optin), V(e._zod, "optout", () => A.innerType._zod.optout), V(e._zod, "pattern", () => { const g = A.innerType._zod.pattern; return g ? new RegExp(`^(${sI(g.source)}|null)$`) : void 0 }), V(e._zod, "values", () => A.innerType._zod.values ? new Set([...A.innerType._zod.values, null]) : void 0), e._zod.parse = (g, I) => g.value === null ? g : A.innerType._zod.run(g, I) }), bQ = l("$ZodDefault", (e, A) => { z.init(e, A), e._zod.optin = "optional", V(e._zod, "values", () => A.innerType._zod.values), e._zod.parse = (g, I) => { if (I.direction === "backward") return A.innerType._zod.run(g, I); if (g.value === void 0) return g.value = A.defaultValue, g; const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(i => ro(i, A)) : ro(t, A) } }); function ro(e, A) { return e.value === void 0 && (e.value = A.defaultValue), e } const YQ = l("$ZodPrefault", (e, A) => { z.init(e, A), e._zod.optin = "optional", V(e._zod, "values", () => A.innerType._zod.values), e._zod.parse = (g, I) => (I.direction === "backward" || g.value === void 0 && (g.value = A.defaultValue), A.innerType._zod.run(g, I)) }), KQ = l("$ZodNonOptional", (e, A) => { z.init(e, A), V(e._zod, "values", () => { const g = A.innerType._zod.values; return g ? new Set([...g].filter(I => I !== void 0)) : void 0 }), e._zod.parse = (g, I) => { const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(i => oo(i, e)) : oo(t, e) } }); function oo(e, A) { return !e.issues.length && e.value === void 0 && e.issues.push({ code: "invalid_type", expected: "nonoptional", input: e.value, inst: A }), e } const vQ = l("$ZodSuccess", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => { if (I.direction === "backward") throw new QI("ZodSuccess"); const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(i => (g.value = i.issues.length === 0, g)) : (g.value = t.issues.length === 0, g) } }), JQ = l("$ZodCatch", (e, A) => { z.init(e, A), V(e._zod, "optin", () => A.innerType._zod.optin), V(e._zod, "optout", () => A.innerType._zod.optout), V(e._zod, "values", () => A.innerType._zod.values), e._zod.parse = (g, I) => { if (I.direction === "backward") return A.innerType._zod.run(g, I); const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(i => (g.value = i.value, i.issues.length && (g.value = A.catchValue({ ...g, error: { issues: i.issues.map(n => OA(n, I, DA())) }, input: g.value }), g.issues = []), g)) : (g.value = t.value, t.issues.length && (g.value = A.catchValue({ ...g, error: { issues: t.issues.map(i => OA(i, I, DA())) }, input: g.value }), g.issues = []), g) } }), HQ = l("$ZodNaN", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => ((typeof g.value != "number" || !Number.isNaN(g.value)) && g.issues.push({ input: g.value, inst: e, expected: "nan", code: "invalid_type" }), g) }), LQ = l("$ZodPipe", (e, A) => { z.init(e, A), V(e._zod, "values", () => A.in._zod.values), V(e._zod, "optin", () => A.in._zod.optin), V(e._zod, "optout", () => A.out._zod.optout), V(e._zod, "propValues", () => A.in._zod.propValues), e._zod.parse = (g, I) => { if (I.direction === "backward") { const i = A.out._zod.run(g, I); return i instanceof Promise ? i.then(n => dt(n, A.in, I)) : dt(i, A.in, I) } const t = A.in._zod.run(g, I); return t instanceof Promise ? t.then(i => dt(i, A.out, I)) : dt(t, A.out, I) } }); function dt(e, A, g) { return e.issues.length ? (e.aborted = !0, e) : A._zod.run({ value: e.value, issues: e.issues }, g) } const $i = l("$ZodCodec", (e, A) => { z.init(e, A), V(e._zod, "values", () => A.in._zod.values), V(e._zod, "optin", () => A.in._zod.optin), V(e._zod, "optout", () => A.out._zod.optout), V(e._zod, "propValues", () => A.in._zod.propValues), e._zod.parse = (g, I) => { if ((I.direction || "forward") === "forward") { const i = A.in._zod.run(g, I); return i instanceof Promise ? i.then(n => Dt(n, A, I)) : Dt(i, A, I) } else { const i = A.out._zod.run(g, I); return i instanceof Promise ? i.then(n => Dt(n, A, I)) : Dt(i, A, I) } } }); function Dt(e, A, g) { if (e.issues.length) return e.aborted = !0, e; if ((g.direction || "forward") === "forward") { const t = A.transform(e.value, e); return t instanceof Promise ? t.then(i => ft(e, i, A.out, g)) : ft(e, t, A.out, g) } else { const t = A.reverseTransform(e.value, e); return t instanceof Promise ? t.then(i => ft(e, i, A.in, g)) : ft(e, t, A.in, g) } } function ft(e, A, g, I) { return e.issues.length ? (e.aborted = !0, e) : g._zod.run({ value: A, issues: e.issues }, I) } const qQ = l("$ZodReadonly", (e, A) => { z.init(e, A), V(e._zod, "propValues", () => A.innerType._zod.propValues), V(e._zod, "values", () => A.innerType._zod.values), V(e._zod, "optin", () => A.innerType._zod.optin), V(e._zod, "optout", () => A.innerType._zod.optout), e._zod.parse = (g, I) => { if (I.direction === "backward") return A.innerType._zod.run(g, I); const t = A.innerType._zod.run(g, I); return t instanceof Promise ? t.then(Co) : Co(t) } }); function Co(e) { return e.value = Object.freeze(e.value), e } const xQ = l("$ZodTemplateLiteral", (e, A) => { z.init(e, A); const g = []; for (const I of A.parts) if (typeof I == "object" && I !== null) { if (!I._zod.pattern) throw new Error(`Invalid template literal part, no pattern found: ${[...I._zod.traits].shift()}`); const t = I._zod.pattern instanceof RegExp ? I._zod.pattern.source : I._zod.pattern; if (!t) throw new Error(`Invalid template literal part: ${I._zod.traits}`); const i = t.startsWith("^") ? 1 : 0, n = t.endsWith("$") ? t.length - 1 : t.length; g.push(t.slice(i, n)) } else if (I === null || uC.has(typeof I)) g.push(ye(`${I}`)); else throw new Error(`Invalid template literal part: ${I}`); e._zod.pattern = new RegExp(`^${g.join("")}$`), e._zod.parse = (I, t) => typeof I.value != "string" ? (I.issues.push({ input: I.value, inst: e, expected: "template_literal", code: "invalid_type" }), I) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(I.value) || I.issues.push({ input: I.value, inst: e, code: "invalid_format", format: A.format ?? "template_literal", pattern: e._zod.pattern.source }), I) }), zQ = l("$ZodFunction", (e, A) => (z.init(e, A), e._def = A, e._zod.def = A, e.implement = g => { if (typeof g != "function") throw new Error("implement() must be called with a function"); return function (...I) { const t = e._def.input ? oi(e._def.input, I) : I, i = Reflect.apply(g, this, t); return e._def.output ? oi(e._def.output, i) : i } }, e.implementAsync = g => { if (typeof g != "function") throw new Error("implementAsync() must be called with a function"); return async function (...I) { const t = e._def.input ? await Ci(e._def.input, I) : I, i = await Reflect.apply(g, this, t); return e._def.output ? await Ci(e._def.output, i) : i } }, e._zod.parse = (g, I) => typeof g.value != "function" ? (g.issues.push({ code: "invalid_type", expected: "function", input: g.value, inst: e }), g) : (e._def.output && e._def.output._zod.def.type === "promise" ? g.value = e.implementAsync(g.value) : g.value = e.implement(g.value), g), e.input = (...g) => { const I = e.constructor; return Array.isArray(g[0]) ? new I({ type: "function", input: new _i({ type: "tuple", items: g[0], rest: g[1] }), output: e._def.output }) : new I({ type: "function", input: g[0], output: e._def.output }) }, e.output = g => { const I = e.constructor; return new I({ type: "function", input: e._def.input, output: g }) }, e)), OQ = l("$ZodPromise", (e, A) => { z.init(e, A), e._zod.parse = (g, I) => Promise.resolve(g.value).then(t => A.innerType._zod.run({ value: t, issues: [] }, I)) }), jQ = l("$ZodLazy", (e, A) => { z.init(e, A), V(e._zod, "innerType", () => A.getter()), V(e._zod, "pattern", () => e._zod.innerType._zod.pattern), V(e._zod, "propValues", () => e._zod.innerType._zod.propValues), V(e._zod, "optin", () => e._zod.innerType._zod.optin ?? void 0), V(e._zod, "optout", () => e._zod.innerType._zod.optout ?? void 0), e._zod.parse = (g, I) => e._zod.innerType._zod.run(g, I) }), TQ = l("$ZodCustom", (e, A) => { rA.init(e, A), z.init(e, A), e._zod.parse = (g, I) => g, e._zod.check = g => { const I = g.value, t = A.fn(I); if (t instanceof Promise) return t.then(i => Bo(i, g, I, e)); Bo(t, g, I, e) } }); function Bo(e, A, g, I) { if (!e) { const t = { code: "custom", input: g, inst: I, path: [...I._zod.def.path ?? []], continue: !I._zod.def.abort }; I._zod.def.params && (t.params = I._zod.def.params), A.issues.push(Qg(t)) } } const Bh = () => { const e = { string: { unit: "حرف", verb: "أن يحوي" }, file: { unit: "بايت", verb: "أن يحوي" }, array: { unit: "عنصر", verb: "أن يحوي" }, set: { unit: "عنصر", verb: "أن يحوي" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "مدخل", email: "بريد إلكتروني", url: "رابط", emoji: "إيموجي", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "تاريخ ووقت بمعيار ISO", date: "تاريخ بمعيار ISO", time: "وقت بمعيار ISO", duration: "مدة بمعيار ISO", ipv4: "عنوان IPv4", ipv6: "عنوان IPv6", cidrv4: "مدى عناوين بصيغة IPv4", cidrv6: "مدى عناوين بصيغة IPv6", base64: "نَص بترميز base64-encoded", base64url: "نَص بترميز base64url-encoded", json_string: "نَص على هيئة JSON", e164: "رقم هاتف بمعيار E.164", jwt: "JWT", template_literal: "مدخل" }; return t => { switch (t.code) { case "invalid_type": return `مدخلات غير مقبولة: يفترض إدخال ${t.expected}، ولكن تم إدخال ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `مدخلات غير مقبولة: يفترض إدخال ${L(t.values[0])}` : `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? ` أكبر من اللازم: يفترض أن تكون ${t.origin ?? "القيمة"} ${i} ${t.maximum.toString()} ${n.unit ?? "عنصر"}` : `أكبر من اللازم: يفترض أن تكون ${t.origin ?? "القيمة"} ${i} ${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `أصغر من اللازم: يفترض لـ ${t.origin} أن يكون ${i} ${t.minimum.toString()} ${n.unit}` : `أصغر من اللازم: يفترض لـ ${t.origin} أن يكون ${i} ${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `نَص غير مقبول: يجب أن يبدأ بـ "${t.prefix}"` : i.format === "ends_with" ? `نَص غير مقبول: يجب أن ينتهي بـ "${i.suffix}"` : i.format === "includes" ? `نَص غير مقبول: يجب أن يتضمَّن "${i.includes}"` : i.format === "regex" ? `نَص غير مقبول: يجب أن يطابق النمط ${i.pattern}` : `${I[i.format] ?? t.format} غير مقبول` } case "not_multiple_of": return `رقم غير مقبول: يجب أن يكون من مضاعفات ${t.divisor}`; case "unrecognized_keys": return `معرف${t.keys.length > 1 ? "ات" : ""} غريب${t.keys.length > 1 ? "ة" : ""}: ${N(t.keys, "، ")}`; case "invalid_key": return `معرف غير مقبول في ${t.origin}`; case "invalid_union": return "مدخل غير مقبول"; case "invalid_element": return `مدخل غير مقبول في ${t.origin}`; default: return "مدخل غير مقبول" } } }; function Qh() { return { localeError: Bh() } } const sh = () => { const e = { string: { unit: "simvol", verb: "olmalıdır" }, file: { unit: "bayt", verb: "olmalıdır" }, array: { unit: "element", verb: "olmalıdır" }, set: { unit: "element", verb: "olmalıdır" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Yanlış dəyər: gözlənilən ${t.expected}, daxil olan ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Yanlış dəyər: gözlənilən ${L(t.values[0])}` : `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Çox böyük: gözlənilən ${t.origin ?? "dəyər"} ${i}${t.maximum.toString()} ${n.unit ?? "element"}` : `Çox böyük: gözlənilən ${t.origin ?? "dəyər"} ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Çox kiçik: gözlənilən ${t.origin} ${i}${t.minimum.toString()} ${n.unit}` : `Çox kiçik: gözlənilən ${t.origin} ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Yanlış mətn: "${i.prefix}" ilə başlamalıdır` : i.format === "ends_with" ? `Yanlış mətn: "${i.suffix}" ilə bitməlidir` : i.format === "includes" ? `Yanlış mətn: "${i.includes}" daxil olmalıdır` : i.format === "regex" ? `Yanlış mətn: ${i.pattern} şablonuna uyğun olmalıdır` : `Yanlış ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Yanlış ədəd: ${t.divisor} ilə bölünə bilən olmalıdır`; case "unrecognized_keys": return `Tanınmayan açar${t.keys.length > 1 ? "lar" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `${t.origin} daxilində yanlış açar`; case "invalid_union": return "Yanlış dəyər"; case "invalid_element": return `${t.origin} daxilində yanlış dəyər`; default: return "Yanlış dəyər" } } }; function ah() { return { localeError: sh() } } function Qo(e, A, g, I) { const t = Math.abs(e), i = t % 10, n = t % 100; return n >= 11 && n <= 19 ? I : i === 1 ? A : i >= 2 && i <= 4 ? g : I } const Eh = () => { const e = { string: { unit: { one: "сімвал", few: "сімвалы", many: "сімвалаў" }, verb: "мець" }, array: { unit: { one: "элемент", few: "элементы", many: "элементаў" }, verb: "мець" }, set: { unit: { one: "элемент", few: "элементы", many: "элементаў" }, verb: "мець" }, file: { unit: { one: "байт", few: "байты", many: "байтаў" }, verb: "мець" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "лік"; case "object": { if (Array.isArray(t)) return "масіў"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "увод", email: "email адрас", url: "URL", emoji: "эмодзі", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO дата і час", date: "ISO дата", time: "ISO час", duration: "ISO працягласць", ipv4: "IPv4 адрас", ipv6: "IPv6 адрас", cidrv4: "IPv4 дыяпазон", cidrv6: "IPv6 дыяпазон", base64: "радок у фармаце base64", base64url: "радок у фармаце base64url", json_string: "JSON радок", e164: "нумар E.164", jwt: "JWT", template_literal: "увод" }; return t => { switch (t.code) { case "invalid_type": return `Няправільны ўвод: чакаўся ${t.expected}, атрымана ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Няправільны ўвод: чакалася ${L(t.values[0])}` : `Няправільны варыянт: чакаўся адзін з ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); if (n) { const r = Number(t.maximum), o = Qo(r, n.unit.one, n.unit.few, n.unit.many); return `Занадта вялікі: чакалася, што ${t.origin ?? "значэнне"} павінна ${n.verb} ${i}${t.maximum.toString()} ${o}` } return `Занадта вялікі: чакалася, што ${t.origin ?? "значэнне"} павінна быць ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); if (n) { const r = Number(t.minimum), o = Qo(r, n.unit.one, n.unit.few, n.unit.many); return `Занадта малы: чакалася, што ${t.origin} павінна ${n.verb} ${i}${t.minimum.toString()} ${o}` } return `Занадта малы: чакалася, што ${t.origin} павінна быць ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Няправільны радок: павінен пачынацца з "${i.prefix}"` : i.format === "ends_with" ? `Няправільны радок: павінен заканчвацца на "${i.suffix}"` : i.format === "includes" ? `Няправільны радок: павінен змяшчаць "${i.includes}"` : i.format === "regex" ? `Няправільны радок: павінен адпавядаць шаблону ${i.pattern}` : `Няправільны ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Няправільны лік: павінен быць кратным ${t.divisor}`; case "unrecognized_keys": return `Нераспазнаны ${t.keys.length > 1 ? "ключы" : "ключ"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Няправільны ключ у ${t.origin}`; case "invalid_union": return "Няправільны ўвод"; case "invalid_element": return `Няправільнае значэнне ў ${t.origin}`; default: return "Няправільны ўвод" } } }; function ch() { return { localeError: Eh() } } const uh = () => { const e = { string: { unit: "caràcters", verb: "contenir" }, file: { unit: "bytes", verb: "contenir" }, array: { unit: "elements", verb: "contenir" }, set: { unit: "elements", verb: "contenir" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "entrada", email: "adreça electrònica", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i hora ISO", date: "data ISO", time: "hora ISO", duration: "durada ISO", ipv4: "adreça IPv4", ipv6: "adreça IPv6", cidrv4: "rang IPv4", cidrv6: "rang IPv6", base64: "cadena codificada en base64", base64url: "cadena codificada en base64url", json_string: "cadena JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return t => { switch (t.code) { case "invalid_type": return `Tipus invàlid: s'esperava ${t.expected}, s'ha rebut ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Valor invàlid: s'esperava ${L(t.values[0])}` : `Opció invàlida: s'esperava una de ${N(t.values, " o ")}`; case "too_big": { const i = t.inclusive ? "com a màxim" : "menys de", n = A(t.origin); return n ? `Massa gran: s'esperava que ${t.origin ?? "el valor"} contingués ${i} ${t.maximum.toString()} ${n.unit ?? "elements"}` : `Massa gran: s'esperava que ${t.origin ?? "el valor"} fos ${i} ${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? "com a mínim" : "més de", n = A(t.origin); return n ? `Massa petit: s'esperava que ${t.origin} contingués ${i} ${t.minimum.toString()} ${n.unit}` : `Massa petit: s'esperava que ${t.origin} fos ${i} ${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Format invàlid: ha de començar amb "${i.prefix}"` : i.format === "ends_with" ? `Format invàlid: ha d'acabar amb "${i.suffix}"` : i.format === "includes" ? `Format invàlid: ha d'incloure "${i.includes}"` : i.format === "regex" ? `Format invàlid: ha de coincidir amb el patró ${i.pattern}` : `Format invàlid per a ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Número invàlid: ha de ser múltiple de ${t.divisor}`; case "unrecognized_keys": return `Clau${t.keys.length > 1 ? "s" : ""} no reconeguda${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Clau invàlida a ${t.origin}`; case "invalid_union": return "Entrada invàlida"; case "invalid_element": return `Element invàlid a ${t.origin}`; default: return "Entrada invàlida" } } }; function hh() { return { localeError: uh() } } const lh = () => { const e = { string: { unit: "znaků", verb: "mít" }, file: { unit: "bajtů", verb: "mít" }, array: { unit: "prvků", verb: "mít" }, set: { unit: "prvků", verb: "mít" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "číslo"; case "string": return "řetězec"; case "boolean": return "boolean"; case "bigint": return "bigint"; case "function": return "funkce"; case "symbol": return "symbol"; case "undefined": return "undefined"; case "object": { if (Array.isArray(t)) return "pole"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "regulární výraz", email: "e-mailová adresa", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "datum a čas ve formátu ISO", date: "datum ve formátu ISO", time: "čas ve formátu ISO", duration: "doba trvání ISO", ipv4: "IPv4 adresa", ipv6: "IPv6 adresa", cidrv4: "rozsah IPv4", cidrv6: "rozsah IPv6", base64: "řetězec zakódovaný ve formátu base64", base64url: "řetězec zakódovaný ve formátu base64url", json_string: "řetězec ve formátu JSON", e164: "číslo E.164", jwt: "JWT", template_literal: "vstup" }; return t => { switch (t.code) { case "invalid_type": return `Neplatný vstup: očekáváno ${t.expected}, obdrženo ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Neplatný vstup: očekáváno ${L(t.values[0])}` : `Neplatná možnost: očekávána jedna z hodnot ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Hodnota je příliš velká: ${t.origin ?? "hodnota"} musí mít ${i}${t.maximum.toString()} ${n.unit ?? "prvků"}` : `Hodnota je příliš velká: ${t.origin ?? "hodnota"} musí být ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Hodnota je příliš malá: ${t.origin ?? "hodnota"} musí mít ${i}${t.minimum.toString()} ${n.unit ?? "prvků"}` : `Hodnota je příliš malá: ${t.origin ?? "hodnota"} musí být ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Neplatný řetězec: musí začínat na "${i.prefix}"` : i.format === "ends_with" ? `Neplatný řetězec: musí končit na "${i.suffix}"` : i.format === "includes" ? `Neplatný řetězec: musí obsahovat "${i.includes}"` : i.format === "regex" ? `Neplatný řetězec: musí odpovídat vzoru ${i.pattern}` : `Neplatný formát ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Neplatné číslo: musí být násobkem ${t.divisor}`; case "unrecognized_keys": return `Neznámé klíče: ${N(t.keys, ", ")}`; case "invalid_key": return `Neplatný klíč v ${t.origin}`; case "invalid_union": return "Neplatný vstup"; case "invalid_element": return `Neplatná hodnota v ${t.origin}`; default: return "Neplatný vstup" } } }; function wh() { return { localeError: lh() } } const dh = () => { const e = { string: { unit: "tegn", verb: "havde" }, file: { unit: "bytes", verb: "havde" }, array: { unit: "elementer", verb: "indeholdt" }, set: { unit: "elementer", verb: "indeholdt" } }, A = { string: "streng", number: "tal", boolean: "boolean", array: "liste", object: "objekt", set: "sæt", file: "fil" }; function g(n) { return e[n] ?? null } function I(n) { return A[n] ?? n } const t = n => { const r = typeof n; switch (r) { case "number": return Number.isNaN(n) ? "NaN" : "tal"; case "object": return Array.isArray(n) ? "liste" : n === null ? "null" : Object.getPrototypeOf(n) !== Object.prototype && n.constructor ? n.constructor.name : "objekt" }return r }, i = { regex: "input", email: "e-mailadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslæt", date: "ISO-dato", time: "ISO-klokkeslæt", duration: "ISO-varighed", ipv4: "IPv4-område", ipv6: "IPv6-område", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodet streng", base64url: "base64url-kodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return n => { switch (n.code) { case "invalid_type": return `Ugyldigt input: forventede ${I(n.expected)}, fik ${I(t(n.input))}`; case "invalid_value": return n.values.length === 1 ? `Ugyldig værdi: forventede ${L(n.values[0])}` : `Ugyldigt valg: forventede en af følgende ${N(n.values, "|")}`; case "too_big": { const r = n.inclusive ? "<=" : "<", o = g(n.origin), C = I(n.origin); return o ? `For stor: forventede ${C ?? "value"} ${o.verb} ${r} ${n.maximum.toString()} ${o.unit ?? "elementer"}` : `For stor: forventede ${C ?? "value"} havde ${r} ${n.maximum.toString()}` } case "too_small": { const r = n.inclusive ? ">=" : ">", o = g(n.origin), C = I(n.origin); return o ? `For lille: forventede ${C} ${o.verb} ${r} ${n.minimum.toString()} ${o.unit}` : `For lille: forventede ${C} havde ${r} ${n.minimum.toString()}` } case "invalid_format": { const r = n; return r.format === "starts_with" ? `Ugyldig streng: skal starte med "${r.prefix}"` : r.format === "ends_with" ? `Ugyldig streng: skal ende med "${r.suffix}"` : r.format === "includes" ? `Ugyldig streng: skal indeholde "${r.includes}"` : r.format === "regex" ? `Ugyldig streng: skal matche mønsteret ${r.pattern}` : `Ugyldig ${i[r.format] ?? n.format}` } case "not_multiple_of": return `Ugyldigt tal: skal være deleligt med ${n.divisor}`; case "unrecognized_keys": return `${n.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${N(n.keys, ", ")}`; case "invalid_key": return `Ugyldig nøgle i ${n.origin}`; case "invalid_union": return "Ugyldigt input: matcher ingen af de tilladte typer"; case "invalid_element": return `Ugyldig værdi i ${n.origin}`; default: return "Ugyldigt input" } } }; function Dh() { return { localeError: dh() } } const fh = () => { const e = { string: { unit: "Zeichen", verb: "zu haben" }, file: { unit: "Bytes", verb: "zu haben" }, array: { unit: "Elemente", verb: "zu haben" }, set: { unit: "Elemente", verb: "zu haben" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "Zahl"; case "object": { if (Array.isArray(t)) return "Array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "Eingabe", email: "E-Mail-Adresse", url: "URL", emoji: "Emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-Datum und -Uhrzeit", date: "ISO-Datum", time: "ISO-Uhrzeit", duration: "ISO-Dauer", ipv4: "IPv4-Adresse", ipv6: "IPv6-Adresse", cidrv4: "IPv4-Bereich", cidrv6: "IPv6-Bereich", base64: "Base64-codierter String", base64url: "Base64-URL-codierter String", json_string: "JSON-String", e164: "E.164-Nummer", jwt: "JWT", template_literal: "Eingabe" }; return t => { switch (t.code) { case "invalid_type": return `Ungültige Eingabe: erwartet ${t.expected}, erhalten ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ungültige Eingabe: erwartet ${L(t.values[0])}` : `Ungültige Option: erwartet eine von ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Zu groß: erwartet, dass ${t.origin ?? "Wert"} ${i}${t.maximum.toString()} ${n.unit ?? "Elemente"} hat` : `Zu groß: erwartet, dass ${t.origin ?? "Wert"} ${i}${t.maximum.toString()} ist` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ${n.unit} hat` : `Zu klein: erwartet, dass ${t.origin} ${i}${t.minimum.toString()} ist` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Ungültiger String: muss mit "${i.prefix}" beginnen` : i.format === "ends_with" ? `Ungültiger String: muss mit "${i.suffix}" enden` : i.format === "includes" ? `Ungültiger String: muss "${i.includes}" enthalten` : i.format === "regex" ? `Ungültiger String: muss dem Muster ${i.pattern} entsprechen` : `Ungültig: ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Ungültige Zahl: muss ein Vielfaches von ${t.divisor} sein`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Ungültiger Schlüssel in ${t.origin}`; case "invalid_union": return "Ungültige Eingabe"; case "invalid_element": return `Ungültiger Wert in ${t.origin}`; default: return "Ungültige Eingabe" } } }; function yh() { return { localeError: fh() } } const ph = e => { const A = typeof e; switch (A) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": { if (Array.isArray(e)) return "array"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return A }, mh = () => { const e = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } }; function A(I) { return e[I] ?? null } const g = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" }; return I => { switch (I.code) { case "invalid_type": return `Invalid input: expected ${I.expected}, received ${ph(I.input)}`; case "invalid_value": return I.values.length === 1 ? `Invalid input: expected ${L(I.values[0])}` : `Invalid option: expected one of ${N(I.values, "|")}`; case "too_big": { const t = I.inclusive ? "<=" : "<", i = A(I.origin); return i ? `Too big: expected ${I.origin ?? "value"} to have ${t}${I.maximum.toString()} ${i.unit ?? "elements"}` : `Too big: expected ${I.origin ?? "value"} to be ${t}${I.maximum.toString()}` } case "too_small": { const t = I.inclusive ? ">=" : ">", i = A(I.origin); return i ? `Too small: expected ${I.origin} to have ${t}${I.minimum.toString()} ${i.unit}` : `Too small: expected ${I.origin} to be ${t}${I.minimum.toString()}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `Invalid string: must start with "${t.prefix}"` : t.format === "ends_with" ? `Invalid string: must end with "${t.suffix}"` : t.format === "includes" ? `Invalid string: must include "${t.includes}"` : t.format === "regex" ? `Invalid string: must match pattern ${t.pattern}` : `Invalid ${g[t.format] ?? I.format}` } case "not_multiple_of": return `Invalid number: must be a multiple of ${I.divisor}`; case "unrecognized_keys": return `Unrecognized key${I.keys.length > 1 ? "s" : ""}: ${N(I.keys, ", ")}`; case "invalid_key": return `Invalid key in ${I.origin}`; case "invalid_union": return "Invalid input"; case "invalid_element": return `Invalid value in ${I.origin}`; default: return "Invalid input" } } }; function ZQ() { return { localeError: mh() } } const Nh = e => { const A = typeof e; switch (A) { case "number": return Number.isNaN(e) ? "NaN" : "nombro"; case "object": { if (Array.isArray(e)) return "tabelo"; if (e === null) return "senvalora"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return A }, kh = () => { const e = { string: { unit: "karaktrojn", verb: "havi" }, file: { unit: "bajtojn", verb: "havi" }, array: { unit: "elementojn", verb: "havi" }, set: { unit: "elementojn", verb: "havi" } }; function A(I) { return e[I] ?? null } const g = { regex: "enigo", email: "retadreso", url: "URL", emoji: "emoĝio", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datotempo", date: "ISO-dato", time: "ISO-tempo", duration: "ISO-daŭro", ipv4: "IPv4-adreso", ipv6: "IPv6-adreso", cidrv4: "IPv4-rango", cidrv6: "IPv6-rango", base64: "64-ume kodita karaktraro", base64url: "URL-64-ume kodita karaktraro", json_string: "JSON-karaktraro", e164: "E.164-nombro", jwt: "JWT", template_literal: "enigo" }; return I => { switch (I.code) { case "invalid_type": return `Nevalida enigo: atendiĝis ${I.expected}, riceviĝis ${Nh(I.input)}`; case "invalid_value": return I.values.length === 1 ? `Nevalida enigo: atendiĝis ${L(I.values[0])}` : `Nevalida opcio: atendiĝis unu el ${N(I.values, "|")}`; case "too_big": { const t = I.inclusive ? "<=" : "<", i = A(I.origin); return i ? `Tro granda: atendiĝis ke ${I.origin ?? "valoro"} havu ${t}${I.maximum.toString()} ${i.unit ?? "elementojn"}` : `Tro granda: atendiĝis ke ${I.origin ?? "valoro"} havu ${t}${I.maximum.toString()}` } case "too_small": { const t = I.inclusive ? ">=" : ">", i = A(I.origin); return i ? `Tro malgranda: atendiĝis ke ${I.origin} havu ${t}${I.minimum.toString()} ${i.unit}` : `Tro malgranda: atendiĝis ke ${I.origin} estu ${t}${I.minimum.toString()}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `Nevalida karaktraro: devas komenciĝi per "${t.prefix}"` : t.format === "ends_with" ? `Nevalida karaktraro: devas finiĝi per "${t.suffix}"` : t.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${t.includes}"` : t.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${t.pattern}` : `Nevalida ${g[t.format] ?? I.format}` } case "not_multiple_of": return `Nevalida nombro: devas esti oblo de ${I.divisor}`; case "unrecognized_keys": return `Nekonata${I.keys.length > 1 ? "j" : ""} ŝlosilo${I.keys.length > 1 ? "j" : ""}: ${N(I.keys, ", ")}`; case "invalid_key": return `Nevalida ŝlosilo en ${I.origin}`; case "invalid_union": return "Nevalida enigo"; case "invalid_element": return `Nevalida valoro en ${I.origin}`; default: return "Nevalida enigo" } } }; function Gh() { return { localeError: kh() } } const Sh = () => { const e = { string: { unit: "caracteres", verb: "tener" }, file: { unit: "bytes", verb: "tener" }, array: { unit: "elementos", verb: "tener" }, set: { unit: "elementos", verb: "tener" } }, A = { string: "texto", number: "número", boolean: "booleano", array: "arreglo", object: "objeto", set: "conjunto", file: "archivo", date: "fecha", bigint: "número grande", symbol: "símbolo", undefined: "indefinido", null: "nulo", function: "función", map: "mapa", record: "registro", tuple: "tupla", enum: "enumeración", union: "unión", literal: "literal", promise: "promesa", void: "vacío", never: "nunca", unknown: "desconocido", any: "cualquiera" }; function g(n) { return e[n] ?? null } function I(n) { return A[n] ?? n } const t = n => { const r = typeof n; switch (r) { case "number": return Number.isNaN(n) ? "NaN" : "number"; case "object": return Array.isArray(n) ? "array" : n === null ? "null" : Object.getPrototypeOf(n) !== Object.prototype ? n.constructor.name : "object" }return r }, i = { regex: "entrada", email: "dirección de correo electrónico", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "fecha y hora ISO", date: "fecha ISO", time: "hora ISO", duration: "duración ISO", ipv4: "dirección IPv4", ipv6: "dirección IPv6", cidrv4: "rango IPv4", cidrv6: "rango IPv6", base64: "cadena codificada en base64", base64url: "URL codificada en base64", json_string: "cadena JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return n => { switch (n.code) { case "invalid_type": return `Entrada inválida: se esperaba ${I(n.expected)}, recibido ${I(t(n.input))}`; case "invalid_value": return n.values.length === 1 ? `Entrada inválida: se esperaba ${L(n.values[0])}` : `Opción inválida: se esperaba una de ${N(n.values, "|")}`; case "too_big": { const r = n.inclusive ? "<=" : "<", o = g(n.origin), C = I(n.origin); return o ? `Demasiado grande: se esperaba que ${C ?? "valor"} tuviera ${r}${n.maximum.toString()} ${o.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${C ?? "valor"} fuera ${r}${n.maximum.toString()}` } case "too_small": { const r = n.inclusive ? ">=" : ">", o = g(n.origin), C = I(n.origin); return o ? `Demasiado pequeño: se esperaba que ${C} tuviera ${r}${n.minimum.toString()} ${o.unit}` : `Demasiado pequeño: se esperaba que ${C} fuera ${r}${n.minimum.toString()}` } case "invalid_format": { const r = n; return r.format === "starts_with" ? `Cadena inválida: debe comenzar con "${r.prefix}"` : r.format === "ends_with" ? `Cadena inválida: debe terminar en "${r.suffix}"` : r.format === "includes" ? `Cadena inválida: debe incluir "${r.includes}"` : r.format === "regex" ? `Cadena inválida: debe coincidir con el patrón ${r.pattern}` : `Inválido ${i[r.format] ?? n.format}` } case "not_multiple_of": return `Número inválido: debe ser múltiplo de ${n.divisor}`; case "unrecognized_keys": return `Llave${n.keys.length > 1 ? "s" : ""} desconocida${n.keys.length > 1 ? "s" : ""}: ${N(n.keys, ", ")}`; case "invalid_key": return `Llave inválida en ${I(n.origin)}`; case "invalid_union": return "Entrada inválida"; case "invalid_element": return `Valor inválido en ${I(n.origin)}`; default: return "Entrada inválida" } } }; function Mh() { return { localeError: Sh() } } const Fh = () => { const e = { string: { unit: "کاراکتر", verb: "داشته باشد" }, file: { unit: "بایت", verb: "داشته باشد" }, array: { unit: "آیتم", verb: "داشته باشد" }, set: { unit: "آیتم", verb: "داشته باشد" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "عدد"; case "object": { if (Array.isArray(t)) return "آرایه"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ورودی", email: "آدرس ایمیل", url: "URL", emoji: "ایموجی", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "تاریخ و زمان ایزو", date: "تاریخ ایزو", time: "زمان ایزو", duration: "مدت زمان ایزو", ipv4: "IPv4 آدرس", ipv6: "IPv6 آدرس", cidrv4: "IPv4 دامنه", cidrv6: "IPv6 دامنه", base64: "base64-encoded رشته", base64url: "base64url-encoded رشته", json_string: "JSON رشته", e164: "E.164 عدد", jwt: "JWT", template_literal: "ورودی" }; return t => { switch (t.code) { case "invalid_type": return `ورودی نامعتبر: می‌بایست ${t.expected} می‌بود، ${g(t.input)} دریافت شد`; case "invalid_value": return t.values.length === 1 ? `ورودی نامعتبر: می‌بایست ${L(t.values[0])} می‌بود` : `گزینه نامعتبر: می‌بایست یکی از ${N(t.values, "|")} می‌بود`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `خیلی بزرگ: ${t.origin ?? "مقدار"} باید ${i}${t.maximum.toString()} ${n.unit ?? "عنصر"} باشد` : `خیلی بزرگ: ${t.origin ?? "مقدار"} باید ${i}${t.maximum.toString()} باشد` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `خیلی کوچک: ${t.origin} باید ${i}${t.minimum.toString()} ${n.unit} باشد` : `خیلی کوچک: ${t.origin} باید ${i}${t.minimum.toString()} باشد` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `رشته نامعتبر: باید با "${i.prefix}" شروع شود` : i.format === "ends_with" ? `رشته نامعتبر: باید با "${i.suffix}" تمام شود` : i.format === "includes" ? `رشته نامعتبر: باید شامل "${i.includes}" باشد` : i.format === "regex" ? `رشته نامعتبر: باید با الگوی ${i.pattern} مطابقت داشته باشد` : `${I[i.format] ?? t.format} نامعتبر` } case "not_multiple_of": return `عدد نامعتبر: باید مضرب ${t.divisor} باشد`; case "unrecognized_keys": return `کلید${t.keys.length > 1 ? "های" : ""} ناشناس: ${N(t.keys, ", ")}`; case "invalid_key": return `کلید ناشناس در ${t.origin}`; case "invalid_union": return "ورودی نامعتبر"; case "invalid_element": return `مقدار نامعتبر در ${t.origin}`; default: return "ورودی نامعتبر" } } }; function Uh() { return { localeError: Fh() } } const Rh = () => { const e = { string: { unit: "merkkiä", subject: "merkkijonon" }, file: { unit: "tavua", subject: "tiedoston" }, array: { unit: "alkiota", subject: "listan" }, set: { unit: "alkiota", subject: "joukon" }, number: { unit: "", subject: "luvun" }, bigint: { unit: "", subject: "suuren kokonaisluvun" }, int: { unit: "", subject: "kokonaisluvun" }, date: { unit: "", subject: "päivämäärän" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "säännöllinen lauseke", email: "sähköpostiosoite", url: "URL-osoite", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-aikaleima", date: "ISO-päivämäärä", time: "ISO-aika", duration: "ISO-kesto", ipv4: "IPv4-osoite", ipv6: "IPv6-osoite", cidrv4: "IPv4-alue", cidrv6: "IPv6-alue", base64: "base64-koodattu merkkijono", base64url: "base64url-koodattu merkkijono", json_string: "JSON-merkkijono", e164: "E.164-luku", jwt: "JWT", template_literal: "templaattimerkkijono" }; return t => { switch (t.code) { case "invalid_type": return `Virheellinen tyyppi: odotettiin ${t.expected}, oli ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Virheellinen syöte: täytyy olla ${L(t.values[0])}` : `Virheellinen valinta: täytyy olla yksi seuraavista: ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Liian suuri: ${n.subject} täytyy olla ${i}${t.maximum.toString()} ${n.unit}`.trim() : `Liian suuri: arvon täytyy olla ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Liian pieni: ${n.subject} täytyy olla ${i}${t.minimum.toString()} ${n.unit}`.trim() : `Liian pieni: arvon täytyy olla ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Virheellinen syöte: täytyy alkaa "${i.prefix}"` : i.format === "ends_with" ? `Virheellinen syöte: täytyy loppua "${i.suffix}"` : i.format === "includes" ? `Virheellinen syöte: täytyy sisältää "${i.includes}"` : i.format === "regex" ? `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${i.pattern}` : `Virheellinen ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Virheellinen luku: täytyy olla luvun ${t.divisor} monikerta`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${N(t.keys, ", ")}`; case "invalid_key": return "Virheellinen avain tietueessa"; case "invalid_union": return "Virheellinen unioni"; case "invalid_element": return "Virheellinen arvo joukossa"; default: return "Virheellinen syöte" } } }; function bh() { return { localeError: Rh() } } const Yh = () => { const e = { string: { unit: "caractères", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "éléments", verb: "avoir" }, set: { unit: "éléments", verb: "avoir" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "nombre"; case "object": { if (Array.isArray(t)) return "tableau"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "entrée", email: "adresse e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date et heure ISO", date: "date ISO", time: "heure ISO", duration: "durée ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaîne encodée en base64", base64url: "chaîne encodée en base64url", json_string: "chaîne JSON", e164: "numéro E.164", jwt: "JWT", template_literal: "entrée" }; return t => { switch (t.code) { case "invalid_type": return `Entrée invalide : ${t.expected} attendu, ${g(t.input)} reçu`; case "invalid_value": return t.values.length === 1 ? `Entrée invalide : ${L(t.values[0])} attendu` : `Option invalide : une valeur parmi ${N(t.values, "|")} attendue`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Trop grand : ${t.origin ?? "valeur"} doit ${n.verb} ${i}${t.maximum.toString()} ${n.unit ?? "élément(s)"}` : `Trop grand : ${t.origin ?? "valeur"} doit être ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Trop petit : ${t.origin} doit ${n.verb} ${i}${t.minimum.toString()} ${n.unit}` : `Trop petit : ${t.origin} doit être ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Chaîne invalide : doit commencer par "${i.prefix}"` : i.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${i.suffix}"` : i.format === "includes" ? `Chaîne invalide : doit inclure "${i.includes}"` : i.format === "regex" ? `Chaîne invalide : doit correspondre au modèle ${i.pattern}` : `${I[i.format] ?? t.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit être un multiple de ${t.divisor}`; case "unrecognized_keys": return `Clé${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${N(t.keys, ", ")}`; case "invalid_key": return `Clé invalide dans ${t.origin}`; case "invalid_union": return "Entrée invalide"; case "invalid_element": return `Valeur invalide dans ${t.origin}`; default: return "Entrée invalide" } } }; function Kh() { return { localeError: Yh() } } const vh = () => { const e = { string: { unit: "caractères", verb: "avoir" }, file: { unit: "octets", verb: "avoir" }, array: { unit: "éléments", verb: "avoir" }, set: { unit: "éléments", verb: "avoir" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "entrée", email: "adresse courriel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "date-heure ISO", date: "date ISO", time: "heure ISO", duration: "durée ISO", ipv4: "adresse IPv4", ipv6: "adresse IPv6", cidrv4: "plage IPv4", cidrv6: "plage IPv6", base64: "chaîne encodée en base64", base64url: "chaîne encodée en base64url", json_string: "chaîne JSON", e164: "numéro E.164", jwt: "JWT", template_literal: "entrée" }; return t => { switch (t.code) { case "invalid_type": return `Entrée invalide : attendu ${t.expected}, reçu ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Entrée invalide : attendu ${L(t.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "≤" : "<", n = A(t.origin); return n ? `Trop grand : attendu que ${t.origin ?? "la valeur"} ait ${i}${t.maximum.toString()} ${n.unit}` : `Trop grand : attendu que ${t.origin ?? "la valeur"} soit ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? "≥" : ">", n = A(t.origin); return n ? `Trop petit : attendu que ${t.origin} ait ${i}${t.minimum.toString()} ${n.unit}` : `Trop petit : attendu que ${t.origin} soit ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Chaîne invalide : doit commencer par "${i.prefix}"` : i.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${i.suffix}"` : i.format === "includes" ? `Chaîne invalide : doit inclure "${i.includes}"` : i.format === "regex" ? `Chaîne invalide : doit correspondre au motif ${i.pattern}` : `${I[i.format] ?? t.format} invalide` } case "not_multiple_of": return `Nombre invalide : doit être un multiple de ${t.divisor}`; case "unrecognized_keys": return `Clé${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${N(t.keys, ", ")}`; case "invalid_key": return `Clé invalide dans ${t.origin}`; case "invalid_union": return "Entrée invalide"; case "invalid_element": return `Valeur invalide dans ${t.origin}`; default: return "Entrée invalide" } } }; function Jh() { return { localeError: vh() } } const Hh = () => { const e = { string: { unit: "אותיות", verb: "לכלול" }, file: { unit: "בייטים", verb: "לכלול" }, array: { unit: "פריטים", verb: "לכלול" }, set: { unit: "פריטים", verb: "לכלול" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "קלט", email: "כתובת אימייל", url: "כתובת רשת", emoji: "אימוג'י", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "תאריך וזמן ISO", date: "תאריך ISO", time: "זמן ISO", duration: "משך זמן ISO", ipv4: "כתובת IPv4", ipv6: "כתובת IPv6", cidrv4: "טווח IPv4", cidrv6: "טווח IPv6", base64: "מחרוזת בבסיס 64", base64url: "מחרוזת בבסיס 64 לכתובות רשת", json_string: "מחרוזת JSON", e164: "מספר E.164", jwt: "JWT", template_literal: "קלט" }; return t => { switch (t.code) { case "invalid_type": return `קלט לא תקין: צריך ${t.expected}, התקבל ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `קלט לא תקין: צריך ${L(t.values[0])}` : `קלט לא תקין: צריך אחת מהאפשרויות  ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `גדול מדי: ${t.origin ?? "value"} צריך להיות ${i}${t.maximum.toString()} ${n.unit ?? "elements"}` : `גדול מדי: ${t.origin ?? "value"} צריך להיות ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `קטן מדי: ${t.origin} צריך להיות ${i}${t.minimum.toString()} ${n.unit}` : `קטן מדי: ${t.origin} צריך להיות ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `מחרוזת לא תקינה: חייבת להתחיל ב"${i.prefix}"` : i.format === "ends_with" ? `מחרוזת לא תקינה: חייבת להסתיים ב "${i.suffix}"` : i.format === "includes" ? `מחרוזת לא תקינה: חייבת לכלול "${i.includes}"` : i.format === "regex" ? `מחרוזת לא תקינה: חייבת להתאים לתבנית ${i.pattern}` : `${I[i.format] ?? t.format} לא תקין` } case "not_multiple_of": return `מספר לא תקין: חייב להיות מכפלה של ${t.divisor}`; case "unrecognized_keys": return `מפתח${t.keys.length > 1 ? "ות" : ""} לא מזוה${t.keys.length > 1 ? "ים" : "ה"}: ${N(t.keys, ", ")}`; case "invalid_key": return `מפתח לא תקין ב${t.origin}`; case "invalid_union": return "קלט לא תקין"; case "invalid_element": return `ערך לא תקין ב${t.origin}`; default: return "קלט לא תקין" } } }; function Lh() { return { localeError: Hh() } } const qh = () => { const e = { string: { unit: "karakter", verb: "legyen" }, file: { unit: "byte", verb: "legyen" }, array: { unit: "elem", verb: "legyen" }, set: { unit: "elem", verb: "legyen" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "szám"; case "object": { if (Array.isArray(t)) return "tömb"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "bemenet", email: "email cím", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO időbélyeg", date: "ISO dátum", time: "ISO idő", duration: "ISO időintervallum", ipv4: "IPv4 cím", ipv6: "IPv6 cím", cidrv4: "IPv4 tartomány", cidrv6: "IPv6 tartomány", base64: "base64-kódolt string", base64url: "base64url-kódolt string", json_string: "JSON string", e164: "E.164 szám", jwt: "JWT", template_literal: "bemenet" }; return t => { switch (t.code) { case "invalid_type": return `Érvénytelen bemenet: a várt érték ${t.expected}, a kapott érték ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Érvénytelen bemenet: a várt érték ${L(t.values[0])}` : `Érvénytelen opció: valamelyik érték várt ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Túl nagy: ${t.origin ?? "érték"} mérete túl nagy ${i}${t.maximum.toString()} ${n.unit ?? "elem"}` : `Túl nagy: a bemeneti érték ${t.origin ?? "érték"} túl nagy: ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Túl kicsi: a bemeneti érték ${t.origin} mérete túl kicsi ${i}${t.minimum.toString()} ${n.unit}` : `Túl kicsi: a bemeneti érték ${t.origin} túl kicsi ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Érvénytelen string: "${i.prefix}" értékkel kell kezdődnie` : i.format === "ends_with" ? `Érvénytelen string: "${i.suffix}" értékkel kell végződnie` : i.format === "includes" ? `Érvénytelen string: "${i.includes}" értéket kell tartalmaznia` : i.format === "regex" ? `Érvénytelen string: ${i.pattern} mintának kell megfelelnie` : `Érvénytelen ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Érvénytelen szám: ${t.divisor} többszörösének kell lennie`; case "unrecognized_keys": return `Ismeretlen kulcs${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Érvénytelen kulcs ${t.origin}`; case "invalid_union": return "Érvénytelen bemenet"; case "invalid_element": return `Érvénytelen érték: ${t.origin}`; default: return "Érvénytelen bemenet" } } }; function xh() { return { localeError: qh() } } const zh = () => { const e = { string: { unit: "karakter", verb: "memiliki" }, file: { unit: "byte", verb: "memiliki" }, array: { unit: "item", verb: "memiliki" }, set: { unit: "item", verb: "memiliki" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "input", email: "alamat email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tanggal dan waktu format ISO", date: "tanggal format ISO", time: "jam format ISO", duration: "durasi format ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "rentang alamat IPv4", cidrv6: "rentang alamat IPv6", base64: "string dengan enkode base64", base64url: "string dengan enkode base64url", json_string: "string JSON", e164: "angka E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input tidak valid: diharapkan ${t.expected}, diterima ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input tidak valid: diharapkan ${L(t.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Terlalu besar: diharapkan ${t.origin ?? "value"} memiliki ${i}${t.maximum.toString()} ${n.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${t.origin ?? "value"} menjadi ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Terlalu kecil: diharapkan ${t.origin} memiliki ${i}${t.minimum.toString()} ${n.unit}` : `Terlalu kecil: diharapkan ${t.origin} menjadi ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${i.prefix}"` : i.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${i.suffix}"` : i.format === "includes" ? `String tidak valid: harus menyertakan "${i.includes}"` : i.format === "regex" ? `String tidak valid: harus sesuai pola ${i.pattern}` : `${I[i.format] ?? t.format} tidak valid` } case "not_multiple_of": return `Angka tidak valid: harus kelipatan dari ${t.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali ${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Kunci tidak valid di ${t.origin}`; case "invalid_union": return "Input tidak valid"; case "invalid_element": return `Nilai tidak valid di ${t.origin}`; default: return "Input tidak valid" } } }; function Oh() { return { localeError: zh() } } const jh = e => { const A = typeof e; switch (A) { case "number": return Number.isNaN(e) ? "NaN" : "númer"; case "object": { if (Array.isArray(e)) return "fylki"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return A }, Th = () => { const e = { string: { unit: "stafi", verb: "að hafa" }, file: { unit: "bæti", verb: "að hafa" }, array: { unit: "hluti", verb: "að hafa" }, set: { unit: "hluti", verb: "að hafa" } }; function A(I) { return e[I] ?? null } const g = { regex: "gildi", email: "netfang", url: "vefslóð", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dagsetning og tími", date: "ISO dagsetning", time: "ISO tími", duration: "ISO tímalengd", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded strengur", base64url: "base64url-encoded strengur", json_string: "JSON strengur", e164: "E.164 tölugildi", jwt: "JWT", template_literal: "gildi" }; return I => { switch (I.code) { case "invalid_type": return `Rangt gildi: Þú slóst inn ${jh(I.input)} þar sem á að vera ${I.expected}`; case "invalid_value": return I.values.length === 1 ? `Rangt gildi: gert ráð fyrir ${L(I.values[0])}` : `Ógilt val: má vera eitt af eftirfarandi ${N(I.values, "|")}`; case "too_big": { const t = I.inclusive ? "<=" : "<", i = A(I.origin); return i ? `Of stórt: gert er ráð fyrir að ${I.origin ?? "gildi"} hafi ${t}${I.maximum.toString()} ${i.unit ?? "hluti"}` : `Of stórt: gert er ráð fyrir að ${I.origin ?? "gildi"} sé ${t}${I.maximum.toString()}` } case "too_small": { const t = I.inclusive ? ">=" : ">", i = A(I.origin); return i ? `Of lítið: gert er ráð fyrir að ${I.origin} hafi ${t}${I.minimum.toString()} ${i.unit}` : `Of lítið: gert er ráð fyrir að ${I.origin} sé ${t}${I.minimum.toString()}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `Ógildur strengur: verður að byrja á "${t.prefix}"` : t.format === "ends_with" ? `Ógildur strengur: verður að enda á "${t.suffix}"` : t.format === "includes" ? `Ógildur strengur: verður að innihalda "${t.includes}"` : t.format === "regex" ? `Ógildur strengur: verður að fylgja mynstri ${t.pattern}` : `Rangt ${g[t.format] ?? I.format}` } case "not_multiple_of": return `Röng tala: verður að vera margfeldi af ${I.divisor}`; case "unrecognized_keys": return `Óþekkt ${I.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${N(I.keys, ", ")}`; case "invalid_key": return `Rangur lykill í ${I.origin}`; case "invalid_union": return "Rangt gildi"; case "invalid_element": return `Rangt gildi í ${I.origin}`; default: return "Rangt gildi" } } }; function Zh() { return { localeError: Th() } } const Ph = () => { const e = { string: { unit: "caratteri", verb: "avere" }, file: { unit: "byte", verb: "avere" }, array: { unit: "elementi", verb: "avere" }, set: { unit: "elementi", verb: "avere" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "numero"; case "object": { if (Array.isArray(t)) return "vettore"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "input", email: "indirizzo email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e ora ISO", date: "data ISO", time: "ora ISO", duration: "durata ISO", ipv4: "indirizzo IPv4", ipv6: "indirizzo IPv6", cidrv4: "intervallo IPv4", cidrv6: "intervallo IPv6", base64: "stringa codificata in base64", base64url: "URL codificata in base64", json_string: "stringa JSON", e164: "numero E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input non valido: atteso ${t.expected}, ricevuto ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input non valido: atteso ${L(t.values[0])}` : `Opzione non valida: atteso uno tra ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Troppo grande: ${t.origin ?? "valore"} deve avere ${i}${t.maximum.toString()} ${n.unit ?? "elementi"}` : `Troppo grande: ${t.origin ?? "valore"} deve essere ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Troppo piccolo: ${t.origin} deve avere ${i}${t.minimum.toString()} ${n.unit}` : `Troppo piccolo: ${t.origin} deve essere ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Stringa non valida: deve iniziare con "${i.prefix}"` : i.format === "ends_with" ? `Stringa non valida: deve terminare con "${i.suffix}"` : i.format === "includes" ? `Stringa non valida: deve includere "${i.includes}"` : i.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${i.pattern}` : `Invalid ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Numero non valido: deve essere un multiplo di ${t.divisor}`; case "unrecognized_keys": return `Chiav${t.keys.length > 1 ? "i" : "e"} non riconosciut${t.keys.length > 1 ? "e" : "a"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Chiave non valida in ${t.origin}`; case "invalid_union": return "Input non valido"; case "invalid_element": return `Valore non valido in ${t.origin}`; default: return "Input non valido" } } }; function Vh() { return { localeError: Ph() } } const Wh = () => { const e = { string: { unit: "文字", verb: "である" }, file: { unit: "バイト", verb: "である" }, array: { unit: "要素", verb: "である" }, set: { unit: "要素", verb: "である" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "数値"; case "object": { if (Array.isArray(t)) return "配列"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "入力値", email: "メールアドレス", url: "URL", emoji: "絵文字", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO日時", date: "ISO日付", time: "ISO時刻", duration: "ISO期間", ipv4: "IPv4アドレス", ipv6: "IPv6アドレス", cidrv4: "IPv4範囲", cidrv6: "IPv6範囲", base64: "base64エンコード文字列", base64url: "base64urlエンコード文字列", json_string: "JSON文字列", e164: "E.164番号", jwt: "JWT", template_literal: "入力値" }; return t => { switch (t.code) { case "invalid_type": return `無効な入力: ${t.expected}が期待されましたが、${g(t.input)}が入力されました`; case "invalid_value": return t.values.length === 1 ? `無効な入力: ${L(t.values[0])}が期待されました` : `無効な選択: ${N(t.values, "、")}のいずれかである必要があります`; case "too_big": { const i = t.inclusive ? "以下である" : "より小さい", n = A(t.origin); return n ? `大きすぎる値: ${t.origin ?? "値"}は${t.maximum.toString()}${n.unit ?? "要素"}${i}必要があります` : `大きすぎる値: ${t.origin ?? "値"}は${t.maximum.toString()}${i}必要があります` } case "too_small": { const i = t.inclusive ? "以上である" : "より大きい", n = A(t.origin); return n ? `小さすぎる値: ${t.origin}は${t.minimum.toString()}${n.unit}${i}必要があります` : `小さすぎる値: ${t.origin}は${t.minimum.toString()}${i}必要があります` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `無効な文字列: "${i.prefix}"で始まる必要があります` : i.format === "ends_with" ? `無効な文字列: "${i.suffix}"で終わる必要があります` : i.format === "includes" ? `無効な文字列: "${i.includes}"を含む必要があります` : i.format === "regex" ? `無効な文字列: パターン${i.pattern}に一致する必要があります` : `無効な${I[i.format] ?? t.format}` } case "not_multiple_of": return `無効な数値: ${t.divisor}の倍数である必要があります`; case "unrecognized_keys": return `認識されていないキー${t.keys.length > 1 ? "群" : ""}: ${N(t.keys, "、")}`; case "invalid_key": return `${t.origin}内の無効なキー`; case "invalid_union": return "無効な入力"; case "invalid_element": return `${t.origin}内の無効な値`; default: return "無効な入力" } } }; function Xh() { return { localeError: Wh() } } const _h = e => { const A = typeof e; switch (A) { case "number": return Number.isNaN(e) ? "NaN" : "რიცხვი"; case "object": { if (Array.isArray(e)) return "მასივი"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return { string: "სტრინგი", boolean: "ბულეანი", undefined: "undefined", bigint: "bigint", symbol: "symbol", function: "ფუნქცია" }[A] ?? A }, $h = () => { const e = { string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" }, file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" }, array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }, set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" } }; function A(I) { return e[I] ?? null } const g = { regex: "შეყვანა", email: "ელ-ფოსტის მისამართი", url: "URL", emoji: "ემოჯი", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "თარიღი-დრო", date: "თარიღი", time: "დრო", duration: "ხანგრძლივობა", ipv4: "IPv4 მისამართი", ipv6: "IPv6 მისამართი", cidrv4: "IPv4 დიაპაზონი", cidrv6: "IPv6 დიაპაზონი", base64: "base64-კოდირებული სტრინგი", base64url: "base64url-კოდირებული სტრინგი", json_string: "JSON სტრინგი", e164: "E.164 ნომერი", jwt: "JWT", template_literal: "შეყვანა" }; return I => { switch (I.code) { case "invalid_type": return `არასწორი შეყვანა: მოსალოდნელი ${I.expected}, მიღებული ${_h(I.input)}`; case "invalid_value": return I.values.length === 1 ? `არასწორი შეყვანა: მოსალოდნელი ${L(I.values[0])}` : `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${N(I.values, "|")}-დან`; case "too_big": { const t = I.inclusive ? "<=" : "<", i = A(I.origin); return i ? `ზედმეტად დიდი: მოსალოდნელი ${I.origin ?? "მნიშვნელობა"} ${i.verb} ${t}${I.maximum.toString()} ${i.unit}` : `ზედმეტად დიდი: მოსალოდნელი ${I.origin ?? "მნიშვნელობა"} იყოს ${t}${I.maximum.toString()}` } case "too_small": { const t = I.inclusive ? ">=" : ">", i = A(I.origin); return i ? `ზედმეტად პატარა: მოსალოდნელი ${I.origin} ${i.verb} ${t}${I.minimum.toString()} ${i.unit}` : `ზედმეტად პატარა: მოსალოდნელი ${I.origin} იყოს ${t}${I.minimum.toString()}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `არასწორი სტრინგი: უნდა იწყებოდეს "${t.prefix}"-ით` : t.format === "ends_with" ? `არასწორი სტრინგი: უნდა მთავრდებოდეს "${t.suffix}"-ით` : t.format === "includes" ? `არასწორი სტრინგი: უნდა შეიცავდეს "${t.includes}"-ს` : t.format === "regex" ? `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${t.pattern}` : `არასწორი ${g[t.format] ?? I.format}` } case "not_multiple_of": return `არასწორი რიცხვი: უნდა იყოს ${I.divisor}-ის ჯერადი`; case "unrecognized_keys": return `უცნობი გასაღებ${I.keys.length > 1 ? "ები" : "ი"}: ${N(I.keys, ", ")}`; case "invalid_key": return `არასწორი გასაღები ${I.origin}-ში`; case "invalid_union": return "არასწორი შეყვანა"; case "invalid_element": return `არასწორი მნიშვნელობა ${I.origin}-ში`; default: return "არასწორი შეყვანა" } } }; function Al() { return { localeError: $h() } } const el = () => { const e = { string: { unit: "តួអក្សរ", verb: "គួរមាន" }, file: { unit: "បៃ", verb: "គួរមាន" }, array: { unit: "ធាតុ", verb: "គួរមាន" }, set: { unit: "ធាតុ", verb: "គួរមាន" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "មិនមែនជាលេខ (NaN)" : "លេខ"; case "object": { if (Array.isArray(t)) return "អារេ (Array)"; if (t === null) return "គ្មានតម្លៃ (null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ទិន្នន័យបញ្ចូល", email: "អាសយដ្ឋានអ៊ីមែល", url: "URL", emoji: "សញ្ញាអារម្មណ៍", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO", date: "កាលបរិច្ឆេទ ISO", time: "ម៉ោង ISO", duration: "រយៈពេល ISO", ipv4: "អាសយដ្ឋាន IPv4", ipv6: "អាសយដ្ឋាន IPv6", cidrv4: "ដែនអាសយដ្ឋាន IPv4", cidrv6: "ដែនអាសយដ្ឋាន IPv6", base64: "ខ្សែអក្សរអ៊ិកូដ base64", base64url: "ខ្សែអក្សរអ៊ិកូដ base64url", json_string: "ខ្សែអក្សរ JSON", e164: "លេខ E.164", jwt: "JWT", template_literal: "ទិន្នន័យបញ្ចូល" }; return t => { switch (t.code) { case "invalid_type": return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${t.expected} ប៉ុន្តែទទួលបាន ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${L(t.values[0])}` : `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `ធំពេក៖ ត្រូវការ ${t.origin ?? "តម្លៃ"} ${i} ${t.maximum.toString()} ${n.unit ?? "ធាតុ"}` : `ធំពេក៖ ត្រូវការ ${t.origin ?? "តម្លៃ"} ${i} ${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `តូចពេក៖ ត្រូវការ ${t.origin} ${i} ${t.minimum.toString()} ${n.unit}` : `តូចពេក៖ ត្រូវការ ${t.origin} ${i} ${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${i.prefix}"` : i.format === "ends_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${i.suffix}"` : i.format === "includes" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${i.includes}"` : i.format === "regex" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${i.pattern}` : `មិនត្រឹមត្រូវ៖ ${I[i.format] ?? t.format}` } case "not_multiple_of": return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${t.divisor}`; case "unrecognized_keys": return `រកឃើញសោមិនស្គាល់៖ ${N(t.keys, ", ")}`; case "invalid_key": return `សោមិនត្រឹមត្រូវនៅក្នុង ${t.origin}`; case "invalid_union": return "ទិន្នន័យមិនត្រឹមត្រូវ"; case "invalid_element": return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${t.origin}`; default: return "ទិន្នន័យមិនត្រឹមត្រូវ" } } }; function PQ() { return { localeError: el() } } function gl() { return PQ() } const tl = () => { const e = { string: { unit: "문자", verb: "to have" }, file: { unit: "바이트", verb: "to have" }, array: { unit: "개", verb: "to have" }, set: { unit: "개", verb: "to have" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "입력", email: "이메일 주소", url: "URL", emoji: "이모지", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO 날짜시간", date: "ISO 날짜", time: "ISO 시간", duration: "ISO 기간", ipv4: "IPv4 주소", ipv6: "IPv6 주소", cidrv4: "IPv4 범위", cidrv6: "IPv6 범위", base64: "base64 인코딩 문자열", base64url: "base64url 인코딩 문자열", json_string: "JSON 문자열", e164: "E.164 번호", jwt: "JWT", template_literal: "입력" }; return t => { switch (t.code) { case "invalid_type": return `잘못된 입력: 예상 타입은 ${t.expected}, 받은 타입은 ${g(t.input)}입니다`; case "invalid_value": return t.values.length === 1 ? `잘못된 입력: 값은 ${L(t.values[0])} 이어야 합니다` : `잘못된 옵션: ${N(t.values, "또는 ")} 중 하나여야 합니다`; case "too_big": { const i = t.inclusive ? "이하" : "미만", n = i === "미만" ? "이어야 합니다" : "여야 합니다", r = A(t.origin), o = r?.unit ?? "요소"; return r ? `${t.origin ?? "값"}이 너무 큽니다: ${t.maximum.toString()}${o} ${i}${n}` : `${t.origin ?? "값"}이 너무 큽니다: ${t.maximum.toString()} ${i}${n}` } case "too_small": { const i = t.inclusive ? "이상" : "초과", n = i === "이상" ? "이어야 합니다" : "여야 합니다", r = A(t.origin), o = r?.unit ?? "요소"; return r ? `${t.origin ?? "값"}이 너무 작습니다: ${t.minimum.toString()}${o} ${i}${n}` : `${t.origin ?? "값"}이 너무 작습니다: ${t.minimum.toString()} ${i}${n}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `잘못된 문자열: "${i.prefix}"(으)로 시작해야 합니다` : i.format === "ends_with" ? `잘못된 문자열: "${i.suffix}"(으)로 끝나야 합니다` : i.format === "includes" ? `잘못된 문자열: "${i.includes}"을(를) 포함해야 합니다` : i.format === "regex" ? `잘못된 문자열: 정규식 ${i.pattern} 패턴과 일치해야 합니다` : `잘못된 ${I[i.format] ?? t.format}` } case "not_multiple_of": return `잘못된 숫자: ${t.divisor}의 배수여야 합니다`; case "unrecognized_keys": return `인식할 수 없는 키: ${N(t.keys, ", ")}`; case "invalid_key": return `잘못된 키: ${t.origin}`; case "invalid_union": return "잘못된 입력"; case "invalid_element": return `잘못된 값: ${t.origin}`; default: return "잘못된 입력" } } }; function Il() { return { localeError: tl() } } const il = e => Fg(typeof e, e), Fg = (e, A = void 0) => { switch (e) { case "number": return Number.isNaN(A) ? "NaN" : "skaičius"; case "bigint": return "sveikasis skaičius"; case "string": return "eilutė"; case "boolean": return "loginė reikšmė"; case "undefined": case "void": return "neapibrėžta reikšmė"; case "function": return "funkcija"; case "symbol": return "simbolis"; case "object": return A === void 0 ? "nežinomas objektas" : A === null ? "nulinė reikšmė" : Array.isArray(A) ? "masyvas" : Object.getPrototypeOf(A) !== Object.prototype && A.constructor ? A.constructor.name : "objektas"; case "null": return "nulinė reikšmė" }return e }, yg = e => e.charAt(0).toUpperCase() + e.slice(1); function so(e) { const A = Math.abs(e), g = A % 10, I = A % 100; return I >= 11 && I <= 19 || g === 0 ? "many" : g === 1 ? "one" : "few" } const nl = () => { const e = { string: { unit: { one: "simbolis", few: "simboliai", many: "simbolių" }, verb: { smaller: { inclusive: "turi būti ne ilgesnė kaip", notInclusive: "turi būti trumpesnė kaip" }, bigger: { inclusive: "turi būti ne trumpesnė kaip", notInclusive: "turi būti ilgesnė kaip" } } }, file: { unit: { one: "baitas", few: "baitai", many: "baitų" }, verb: { smaller: { inclusive: "turi būti ne didesnis kaip", notInclusive: "turi būti mažesnis kaip" }, bigger: { inclusive: "turi būti ne mažesnis kaip", notInclusive: "turi būti didesnis kaip" } } }, array: { unit: { one: "elementą", few: "elementus", many: "elementų" }, verb: { smaller: { inclusive: "turi turėti ne daugiau kaip", notInclusive: "turi turėti mažiau kaip" }, bigger: { inclusive: "turi turėti ne mažiau kaip", notInclusive: "turi turėti daugiau kaip" } } }, set: { unit: { one: "elementą", few: "elementus", many: "elementų" }, verb: { smaller: { inclusive: "turi turėti ne daugiau kaip", notInclusive: "turi turėti mažiau kaip" }, bigger: { inclusive: "turi turėti ne mažiau kaip", notInclusive: "turi turėti daugiau kaip" } } } }; function A(I, t, i, n) { const r = e[I] ?? null; return r === null ? r : { unit: r.unit[t], verb: r.verb[n][i ? "inclusive" : "notInclusive"] } } const g = { regex: "įvestis", email: "el. pašto adresas", url: "URL", emoji: "jaustukas", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO data ir laikas", date: "ISO data", time: "ISO laikas", duration: "ISO trukmė", ipv4: "IPv4 adresas", ipv6: "IPv6 adresas", cidrv4: "IPv4 tinklo prefiksas (CIDR)", cidrv6: "IPv6 tinklo prefiksas (CIDR)", base64: "base64 užkoduota eilutė", base64url: "base64url užkoduota eilutė", json_string: "JSON eilutė", e164: "E.164 numeris", jwt: "JWT", template_literal: "įvestis" }; return I => { switch (I.code) { case "invalid_type": return `Gautas tipas ${il(I.input)}, o tikėtasi - ${Fg(I.expected)}`; case "invalid_value": return I.values.length === 1 ? `Privalo būti ${L(I.values[0])}` : `Privalo būti vienas iš ${N(I.values, "|")} pasirinkimų`; case "too_big": { const t = Fg(I.origin), i = A(I.origin, so(Number(I.maximum)), I.inclusive ?? !1, "smaller"); if (i?.verb) return `${yg(t ?? I.origin ?? "reikšmė")} ${i.verb} ${I.maximum.toString()} ${i.unit ?? "elementų"}`; const n = I.inclusive ? "ne didesnis kaip" : "mažesnis kaip"; return `${yg(t ?? I.origin ?? "reikšmė")} turi būti ${n} ${I.maximum.toString()} ${i?.unit}` } case "too_small": { const t = Fg(I.origin), i = A(I.origin, so(Number(I.minimum)), I.inclusive ?? !1, "bigger"); if (i?.verb) return `${yg(t ?? I.origin ?? "reikšmė")} ${i.verb} ${I.minimum.toString()} ${i.unit ?? "elementų"}`; const n = I.inclusive ? "ne mažesnis kaip" : "didesnis kaip"; return `${yg(t ?? I.origin ?? "reikšmė")} turi būti ${n} ${I.minimum.toString()} ${i?.unit}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `Eilutė privalo prasidėti "${t.prefix}"` : t.format === "ends_with" ? `Eilutė privalo pasibaigti "${t.suffix}"` : t.format === "includes" ? `Eilutė privalo įtraukti "${t.includes}"` : t.format === "regex" ? `Eilutė privalo atitikti ${t.pattern}` : `Neteisingas ${g[t.format] ?? I.format}` } case "not_multiple_of": return `Skaičius privalo būti ${I.divisor} kartotinis.`; case "unrecognized_keys": return `Neatpažint${I.keys.length > 1 ? "i" : "as"} rakt${I.keys.length > 1 ? "ai" : "as"}: ${N(I.keys, ", ")}`; case "invalid_key": return "Rastas klaidingas raktas"; case "invalid_union": return "Klaidinga įvestis"; case "invalid_element": { const t = Fg(I.origin); return `${yg(t ?? I.origin ?? "reikšmė")} turi klaidingą įvestį` } default: return "Klaidinga įvestis" } } }; function rl() { return { localeError: nl() } } const ol = () => { const e = { string: { unit: "знаци", verb: "да имаат" }, file: { unit: "бајти", verb: "да имаат" }, array: { unit: "ставки", verb: "да имаат" }, set: { unit: "ставки", verb: "да имаат" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "број"; case "object": { if (Array.isArray(t)) return "низа"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "внес", email: "адреса на е-пошта", url: "URL", emoji: "емоџи", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO датум и време", date: "ISO датум", time: "ISO време", duration: "ISO времетраење", ipv4: "IPv4 адреса", ipv6: "IPv6 адреса", cidrv4: "IPv4 опсег", cidrv6: "IPv6 опсег", base64: "base64-енкодирана низа", base64url: "base64url-енкодирана низа", json_string: "JSON низа", e164: "E.164 број", jwt: "JWT", template_literal: "внес" }; return t => { switch (t.code) { case "invalid_type": return `Грешен внес: се очекува ${t.expected}, примено ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Invalid input: expected ${L(t.values[0])}` : `Грешана опција: се очекува една ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Премногу голем: се очекува ${t.origin ?? "вредноста"} да има ${i}${t.maximum.toString()} ${n.unit ?? "елементи"}` : `Премногу голем: се очекува ${t.origin ?? "вредноста"} да биде ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Премногу мал: се очекува ${t.origin} да има ${i}${t.minimum.toString()} ${n.unit}` : `Премногу мал: се очекува ${t.origin} да биде ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Неважечка низа: мора да започнува со "${i.prefix}"` : i.format === "ends_with" ? `Неважечка низа: мора да завршува со "${i.suffix}"` : i.format === "includes" ? `Неважечка низа: мора да вклучува "${i.includes}"` : i.format === "regex" ? `Неважечка низа: мора да одгоара на патернот ${i.pattern}` : `Invalid ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Грешен број: мора да биде делив со ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Грешен клуч во ${t.origin}`; case "invalid_union": return "Грешен внес"; case "invalid_element": return `Грешна вредност во ${t.origin}`; default: return "Грешен внес" } } }; function Cl() { return { localeError: ol() } } const Bl = () => { const e = { string: { unit: "aksara", verb: "mempunyai" }, file: { unit: "bait", verb: "mempunyai" }, array: { unit: "elemen", verb: "mempunyai" }, set: { unit: "elemen", verb: "mempunyai" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "nombor"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "input", email: "alamat e-mel", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "tarikh masa ISO", date: "tarikh ISO", time: "masa ISO", duration: "tempoh ISO", ipv4: "alamat IPv4", ipv6: "alamat IPv6", cidrv4: "julat IPv4", cidrv6: "julat IPv6", base64: "string dikodkan base64", base64url: "string dikodkan base64url", json_string: "string JSON", e164: "nombor E.164", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Input tidak sah: dijangka ${t.expected}, diterima ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Input tidak sah: dijangka ${L(t.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Terlalu besar: dijangka ${t.origin ?? "nilai"} ${n.verb} ${i}${t.maximum.toString()} ${n.unit ?? "elemen"}` : `Terlalu besar: dijangka ${t.origin ?? "nilai"} adalah ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Terlalu kecil: dijangka ${t.origin} ${n.verb} ${i}${t.minimum.toString()} ${n.unit}` : `Terlalu kecil: dijangka ${t.origin} adalah ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${i.prefix}"` : i.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${i.suffix}"` : i.format === "includes" ? `String tidak sah: mesti mengandungi "${i.includes}"` : i.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${i.pattern}` : `${I[i.format] ?? t.format} tidak sah` } case "not_multiple_of": return `Nombor tidak sah: perlu gandaan ${t.divisor}`; case "unrecognized_keys": return `Kunci tidak dikenali: ${N(t.keys, ", ")}`; case "invalid_key": return `Kunci tidak sah dalam ${t.origin}`; case "invalid_union": return "Input tidak sah"; case "invalid_element": return `Nilai tidak sah dalam ${t.origin}`; default: return "Input tidak sah" } } }; function Ql() { return { localeError: Bl() } } const sl = () => { const e = { string: { unit: "tekens" }, file: { unit: "bytes" }, array: { unit: "elementen" }, set: { unit: "elementen" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "getal"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "invoer", email: "emailadres", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum en tijd", date: "ISO datum", time: "ISO tijd", duration: "ISO duur", ipv4: "IPv4-adres", ipv6: "IPv6-adres", cidrv4: "IPv4-bereik", cidrv6: "IPv6-bereik", base64: "base64-gecodeerde tekst", base64url: "base64 URL-gecodeerde tekst", json_string: "JSON string", e164: "E.164-nummer", jwt: "JWT", template_literal: "invoer" }; return t => { switch (t.code) { case "invalid_type": return `Ongeldige invoer: verwacht ${t.expected}, ontving ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ongeldige invoer: verwacht ${L(t.values[0])}` : `Ongeldige optie: verwacht één van ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Te lang: verwacht dat ${t.origin ?? "waarde"} ${i}${t.maximum.toString()} ${n.unit ?? "elementen"} bevat` : `Te lang: verwacht dat ${t.origin ?? "waarde"} ${i}${t.maximum.toString()} is` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Te kort: verwacht dat ${t.origin} ${i}${t.minimum.toString()} ${n.unit} bevat` : `Te kort: verwacht dat ${t.origin} ${i}${t.minimum.toString()} is` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Ongeldige tekst: moet met "${i.prefix}" beginnen` : i.format === "ends_with" ? `Ongeldige tekst: moet op "${i.suffix}" eindigen` : i.format === "includes" ? `Ongeldige tekst: moet "${i.includes}" bevatten` : i.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${i.pattern}` : `Ongeldig: ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`; case "unrecognized_keys": return `Onbekende key${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Ongeldige key in ${t.origin}`; case "invalid_union": return "Ongeldige invoer"; case "invalid_element": return `Ongeldige waarde in ${t.origin}`; default: return "Ongeldige invoer" } } }; function al() { return { localeError: sl() } } const El = () => { const e = { string: { unit: "tegn", verb: "å ha" }, file: { unit: "bytes", verb: "å ha" }, array: { unit: "elementer", verb: "å inneholde" }, set: { unit: "elementer", verb: "å inneholde" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "tall"; case "object": { if (Array.isArray(t)) return "liste"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "input", email: "e-postadresse", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO dato- og klokkeslett", date: "ISO-dato", time: "ISO-klokkeslett", duration: "ISO-varighet", ipv4: "IPv4-område", ipv6: "IPv6-område", cidrv4: "IPv4-spekter", cidrv6: "IPv6-spekter", base64: "base64-enkodet streng", base64url: "base64url-enkodet streng", json_string: "JSON-streng", e164: "E.164-nummer", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `Ugyldig input: forventet ${t.expected}, fikk ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ugyldig verdi: forventet ${L(t.values[0])}` : `Ugyldig valg: forventet en av ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `For stor(t): forventet ${t.origin ?? "value"} til å ha ${i}${t.maximum.toString()} ${n.unit ?? "elementer"}` : `For stor(t): forventet ${t.origin ?? "value"} til å ha ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `For lite(n): forventet ${t.origin} til å ha ${i}${t.minimum.toString()} ${n.unit}` : `For lite(n): forventet ${t.origin} til å ha ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Ugyldig streng: må starte med "${i.prefix}"` : i.format === "ends_with" ? `Ugyldig streng: må ende med "${i.suffix}"` : i.format === "includes" ? `Ugyldig streng: må inneholde "${i.includes}"` : i.format === "regex" ? `Ugyldig streng: må matche mønsteret ${i.pattern}` : `Ugyldig ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Ugyldig tall: må være et multiplum av ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Ugyldig nøkkel i ${t.origin}`; case "invalid_union": return "Ugyldig input"; case "invalid_element": return `Ugyldig verdi i ${t.origin}`; default: return "Ugyldig input" } } }; function cl() { return { localeError: El() } } const ul = () => { const e = { string: { unit: "harf", verb: "olmalıdır" }, file: { unit: "bayt", verb: "olmalıdır" }, array: { unit: "unsur", verb: "olmalıdır" }, set: { unit: "unsur", verb: "olmalıdır" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "numara"; case "object": { if (Array.isArray(t)) return "saf"; if (t === null) return "gayb"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "giren", email: "epostagâh", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO hengâmı", date: "ISO tarihi", time: "ISO zamanı", duration: "ISO müddeti", ipv4: "IPv4 nişânı", ipv6: "IPv6 nişânı", cidrv4: "IPv4 menzili", cidrv6: "IPv6 menzili", base64: "base64-şifreli metin", base64url: "base64url-şifreli metin", json_string: "JSON metin", e164: "E.164 sayısı", jwt: "JWT", template_literal: "giren" }; return t => { switch (t.code) { case "invalid_type": return `Fâsit giren: umulan ${t.expected}, alınan ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Fâsit giren: umulan ${L(t.values[0])}` : `Fâsit tercih: mûteberler ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Fazla büyük: ${t.origin ?? "value"}, ${i}${t.maximum.toString()} ${n.unit ?? "elements"} sahip olmalıydı.` : `Fazla büyük: ${t.origin ?? "value"}, ${i}${t.maximum.toString()} olmalıydı.` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Fazla küçük: ${t.origin}, ${i}${t.minimum.toString()} ${n.unit} sahip olmalıydı.` : `Fazla küçük: ${t.origin}, ${i}${t.minimum.toString()} olmalıydı.` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Fâsit metin: "${i.prefix}" ile başlamalı.` : i.format === "ends_with" ? `Fâsit metin: "${i.suffix}" ile bitmeli.` : i.format === "includes" ? `Fâsit metin: "${i.includes}" ihtivâ etmeli.` : i.format === "regex" ? `Fâsit metin: ${i.pattern} nakşına uymalı.` : `Fâsit ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Fâsit sayı: ${t.divisor} katı olmalıydı.`; case "unrecognized_keys": return `Tanınmayan anahtar ${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `${t.origin} için tanınmayan anahtar var.`; case "invalid_union": return "Giren tanınamadı."; case "invalid_element": return `${t.origin} için tanınmayan kıymet var.`; default: return "Kıymet tanınamadı." } } }; function hl() { return { localeError: ul() } } const ll = () => { const e = { string: { unit: "توکي", verb: "ولري" }, file: { unit: "بایټس", verb: "ولري" }, array: { unit: "توکي", verb: "ولري" }, set: { unit: "توکي", verb: "ولري" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "عدد"; case "object": { if (Array.isArray(t)) return "ارې"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ورودي", email: "بریښنالیک", url: "یو آر ال", emoji: "ایموجي", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "نیټه او وخت", date: "نېټه", time: "وخت", duration: "موده", ipv4: "د IPv4 پته", ipv6: "د IPv6 پته", cidrv4: "د IPv4 ساحه", cidrv6: "د IPv6 ساحه", base64: "base64-encoded متن", base64url: "base64url-encoded متن", json_string: "JSON متن", e164: "د E.164 شمېره", jwt: "JWT", template_literal: "ورودي" }; return t => { switch (t.code) { case "invalid_type": return `ناسم ورودي: باید ${t.expected} وای, مګر ${g(t.input)} ترلاسه شو`; case "invalid_value": return t.values.length === 1 ? `ناسم ورودي: باید ${L(t.values[0])} وای` : `ناسم انتخاب: باید یو له ${N(t.values, "|")} څخه وای`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `ډیر لوی: ${t.origin ?? "ارزښت"} باید ${i}${t.maximum.toString()} ${n.unit ?? "عنصرونه"} ولري` : `ډیر لوی: ${t.origin ?? "ارزښت"} باید ${i}${t.maximum.toString()} وي` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `ډیر کوچنی: ${t.origin} باید ${i}${t.minimum.toString()} ${n.unit} ولري` : `ډیر کوچنی: ${t.origin} باید ${i}${t.minimum.toString()} وي` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `ناسم متن: باید د "${i.prefix}" سره پیل شي` : i.format === "ends_with" ? `ناسم متن: باید د "${i.suffix}" سره پای ته ورسيږي` : i.format === "includes" ? `ناسم متن: باید "${i.includes}" ولري` : i.format === "regex" ? `ناسم متن: باید د ${i.pattern} سره مطابقت ولري` : `${I[i.format] ?? t.format} ناسم دی` } case "not_multiple_of": return `ناسم عدد: باید د ${t.divisor} مضرب وي`; case "unrecognized_keys": return `ناسم ${t.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${N(t.keys, ", ")}`; case "invalid_key": return `ناسم کلیډ په ${t.origin} کې`; case "invalid_union": return "ناسمه ورودي"; case "invalid_element": return `ناسم عنصر په ${t.origin} کې`; default: return "ناسمه ورودي" } } }; function wl() { return { localeError: ll() } } const dl = () => { const e = { string: { unit: "znaków", verb: "mieć" }, file: { unit: "bajtów", verb: "mieć" }, array: { unit: "elementów", verb: "mieć" }, set: { unit: "elementów", verb: "mieć" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "liczba"; case "object": { if (Array.isArray(t)) return "tablica"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "wyrażenie", email: "adres email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data i godzina w formacie ISO", date: "data w formacie ISO", time: "godzina w formacie ISO", duration: "czas trwania ISO", ipv4: "adres IPv4", ipv6: "adres IPv6", cidrv4: "zakres IPv4", cidrv6: "zakres IPv6", base64: "ciąg znaków zakodowany w formacie base64", base64url: "ciąg znaków zakodowany w formacie base64url", json_string: "ciąg znaków w formacie JSON", e164: "liczba E.164", jwt: "JWT", template_literal: "wejście" }; return t => { switch (t.code) { case "invalid_type": return `Nieprawidłowe dane wejściowe: oczekiwano ${t.expected}, otrzymano ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Nieprawidłowe dane wejściowe: oczekiwano ${L(t.values[0])}` : `Nieprawidłowa opcja: oczekiwano jednej z wartości ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Za duża wartość: oczekiwano, że ${t.origin ?? "wartość"} będzie mieć ${i}${t.maximum.toString()} ${n.unit ?? "elementów"}` : `Zbyt duż(y/a/e): oczekiwano, że ${t.origin ?? "wartość"} będzie wynosić ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Za mała wartość: oczekiwano, że ${t.origin ?? "wartość"} będzie mieć ${i}${t.minimum.toString()} ${n.unit ?? "elementów"}` : `Zbyt mał(y/a/e): oczekiwano, że ${t.origin ?? "wartość"} będzie wynosić ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Nieprawidłowy ciąg znaków: musi zaczynać się od "${i.prefix}"` : i.format === "ends_with" ? `Nieprawidłowy ciąg znaków: musi kończyć się na "${i.suffix}"` : i.format === "includes" ? `Nieprawidłowy ciąg znaków: musi zawierać "${i.includes}"` : i.format === "regex" ? `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${i.pattern}` : `Nieprawidłow(y/a/e) ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Nieprawidłowa liczba: musi być wielokrotnością ${t.divisor}`; case "unrecognized_keys": return `Nierozpoznane klucze${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Nieprawidłowy klucz w ${t.origin}`; case "invalid_union": return "Nieprawidłowe dane wejściowe"; case "invalid_element": return `Nieprawidłowa wartość w ${t.origin}`; default: return "Nieprawidłowe dane wejściowe" } } }; function Dl() { return { localeError: dl() } } const fl = () => { const e = { string: { unit: "caracteres", verb: "ter" }, file: { unit: "bytes", verb: "ter" }, array: { unit: "itens", verb: "ter" }, set: { unit: "itens", verb: "ter" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "número"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "nulo"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "padrão", email: "endereço de e-mail", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "data e hora ISO", date: "data ISO", time: "hora ISO", duration: "duração ISO", ipv4: "endereço IPv4", ipv6: "endereço IPv6", cidrv4: "faixa de IPv4", cidrv6: "faixa de IPv6", base64: "texto codificado em base64", base64url: "URL codificada em base64", json_string: "texto JSON", e164: "número E.164", jwt: "JWT", template_literal: "entrada" }; return t => { switch (t.code) { case "invalid_type": return `Tipo inválido: esperado ${t.expected}, recebido ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Entrada inválida: esperado ${L(t.values[0])}` : `Opção inválida: esperada uma das ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Muito grande: esperado que ${t.origin ?? "valor"} tivesse ${i}${t.maximum.toString()} ${n.unit ?? "elementos"}` : `Muito grande: esperado que ${t.origin ?? "valor"} fosse ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Muito pequeno: esperado que ${t.origin} tivesse ${i}${t.minimum.toString()} ${n.unit}` : `Muito pequeno: esperado que ${t.origin} fosse ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Texto inválido: deve começar com "${i.prefix}"` : i.format === "ends_with" ? `Texto inválido: deve terminar com "${i.suffix}"` : i.format === "includes" ? `Texto inválido: deve incluir "${i.includes}"` : i.format === "regex" ? `Texto inválido: deve corresponder ao padrão ${i.pattern}` : `${I[i.format] ?? t.format} inválido` } case "not_multiple_of": return `Número inválido: deve ser múltiplo de ${t.divisor}`; case "unrecognized_keys": return `Chave${t.keys.length > 1 ? "s" : ""} desconhecida${t.keys.length > 1 ? "s" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Chave inválida em ${t.origin}`; case "invalid_union": return "Entrada inválida"; case "invalid_element": return `Valor inválido em ${t.origin}`; default: return "Campo inválido" } } }; function yl() { return { localeError: fl() } } function ao(e, A, g, I) { const t = Math.abs(e), i = t % 10, n = t % 100; return n >= 11 && n <= 19 ? I : i === 1 ? A : i >= 2 && i <= 4 ? g : I } const pl = () => { const e = { string: { unit: { one: "символ", few: "символа", many: "символов" }, verb: "иметь" }, file: { unit: { one: "байт", few: "байта", many: "байт" }, verb: "иметь" }, array: { unit: { one: "элемент", few: "элемента", many: "элементов" }, verb: "иметь" }, set: { unit: { one: "элемент", few: "элемента", many: "элементов" }, verb: "иметь" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "число"; case "object": { if (Array.isArray(t)) return "массив"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ввод", email: "email адрес", url: "URL", emoji: "эмодзи", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO дата и время", date: "ISO дата", time: "ISO время", duration: "ISO длительность", ipv4: "IPv4 адрес", ipv6: "IPv6 адрес", cidrv4: "IPv4 диапазон", cidrv6: "IPv6 диапазон", base64: "строка в формате base64", base64url: "строка в формате base64url", json_string: "JSON строка", e164: "номер E.164", jwt: "JWT", template_literal: "ввод" }; return t => { switch (t.code) { case "invalid_type": return `Неверный ввод: ожидалось ${t.expected}, получено ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Неверный ввод: ожидалось ${L(t.values[0])}` : `Неверный вариант: ожидалось одно из ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); if (n) { const r = Number(t.maximum), o = ao(r, n.unit.one, n.unit.few, n.unit.many); return `Слишком большое значение: ожидалось, что ${t.origin ?? "значение"} будет иметь ${i}${t.maximum.toString()} ${o}` } return `Слишком большое значение: ожидалось, что ${t.origin ?? "значение"} будет ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); if (n) { const r = Number(t.minimum), o = ao(r, n.unit.one, n.unit.few, n.unit.many); return `Слишком маленькое значение: ожидалось, что ${t.origin} будет иметь ${i}${t.minimum.toString()} ${o}` } return `Слишком маленькое значение: ожидалось, что ${t.origin} будет ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Неверная строка: должна начинаться с "${i.prefix}"` : i.format === "ends_with" ? `Неверная строка: должна заканчиваться на "${i.suffix}"` : i.format === "includes" ? `Неверная строка: должна содержать "${i.includes}"` : i.format === "regex" ? `Неверная строка: должна соответствовать шаблону ${i.pattern}` : `Неверный ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Неверное число: должно быть кратным ${t.divisor}`; case "unrecognized_keys": return `Нераспознанн${t.keys.length > 1 ? "ые" : "ый"} ключ${t.keys.length > 1 ? "и" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Неверный ключ в ${t.origin}`; case "invalid_union": return "Неверные входные данные"; case "invalid_element": return `Неверное значение в ${t.origin}`; default: return "Неверные входные данные" } } }; function ml() { return { localeError: pl() } } const Nl = () => { const e = { string: { unit: "znakov", verb: "imeti" }, file: { unit: "bajtov", verb: "imeti" }, array: { unit: "elementov", verb: "imeti" }, set: { unit: "elementov", verb: "imeti" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "število"; case "object": { if (Array.isArray(t)) return "tabela"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "vnos", email: "e-poštni naslov", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datum in čas", date: "ISO datum", time: "ISO čas", duration: "ISO trajanje", ipv4: "IPv4 naslov", ipv6: "IPv6 naslov", cidrv4: "obseg IPv4", cidrv6: "obseg IPv6", base64: "base64 kodiran niz", base64url: "base64url kodiran niz", json_string: "JSON niz", e164: "E.164 številka", jwt: "JWT", template_literal: "vnos" }; return t => { switch (t.code) { case "invalid_type": return `Neveljaven vnos: pričakovano ${t.expected}, prejeto ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Neveljaven vnos: pričakovano ${L(t.values[0])}` : `Neveljavna možnost: pričakovano eno izmed ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Preveliko: pričakovano, da bo ${t.origin ?? "vrednost"} imelo ${i}${t.maximum.toString()} ${n.unit ?? "elementov"}` : `Preveliko: pričakovano, da bo ${t.origin ?? "vrednost"} ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Premajhno: pričakovano, da bo ${t.origin} imelo ${i}${t.minimum.toString()} ${n.unit}` : `Premajhno: pričakovano, da bo ${t.origin} ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Neveljaven niz: mora se začeti z "${i.prefix}"` : i.format === "ends_with" ? `Neveljaven niz: mora se končati z "${i.suffix}"` : i.format === "includes" ? `Neveljaven niz: mora vsebovati "${i.includes}"` : i.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${i.pattern}` : `Neveljaven ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Neveljavno število: mora biti večkratnik ${t.divisor}`; case "unrecognized_keys": return `Neprepoznan${t.keys.length > 1 ? "i ključi" : " ključ"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Neveljaven ključ v ${t.origin}`; case "invalid_union": return "Neveljaven vnos"; case "invalid_element": return `Neveljavna vrednost v ${t.origin}`; default: return "Neveljaven vnos" } } }; function kl() { return { localeError: Nl() } } const Gl = () => { const e = { string: { unit: "tecken", verb: "att ha" }, file: { unit: "bytes", verb: "att ha" }, array: { unit: "objekt", verb: "att innehålla" }, set: { unit: "objekt", verb: "att innehålla" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "antal"; case "object": { if (Array.isArray(t)) return "lista"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "reguljärt uttryck", email: "e-postadress", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO-datum och tid", date: "ISO-datum", time: "ISO-tid", duration: "ISO-varaktighet", ipv4: "IPv4-intervall", ipv6: "IPv6-intervall", cidrv4: "IPv4-spektrum", cidrv6: "IPv6-spektrum", base64: "base64-kodad sträng", base64url: "base64url-kodad sträng", json_string: "JSON-sträng", e164: "E.164-nummer", jwt: "JWT", template_literal: "mall-literal" }; return t => { switch (t.code) { case "invalid_type": return `Ogiltig inmatning: förväntat ${t.expected}, fick ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ogiltig inmatning: förväntat ${L(t.values[0])}` : `Ogiltigt val: förväntade en av ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `För stor(t): förväntade ${t.origin ?? "värdet"} att ha ${i}${t.maximum.toString()} ${n.unit ?? "element"}` : `För stor(t): förväntat ${t.origin ?? "värdet"} att ha ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `För lite(t): förväntade ${t.origin ?? "värdet"} att ha ${i}${t.minimum.toString()} ${n.unit}` : `För lite(t): förväntade ${t.origin ?? "värdet"} att ha ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Ogiltig sträng: måste börja med "${i.prefix}"` : i.format === "ends_with" ? `Ogiltig sträng: måste sluta med "${i.suffix}"` : i.format === "includes" ? `Ogiltig sträng: måste innehålla "${i.includes}"` : i.format === "regex" ? `Ogiltig sträng: måste matcha mönstret "${i.pattern}"` : `Ogiltig(t) ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Ogiltigt tal: måste vara en multipel av ${t.divisor}`; case "unrecognized_keys": return `${t.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${N(t.keys, ", ")}`; case "invalid_key": return `Ogiltig nyckel i ${t.origin ?? "värdet"}`; case "invalid_union": return "Ogiltig input"; case "invalid_element": return `Ogiltigt värde i ${t.origin ?? "värdet"}`; default: return "Ogiltig input" } } }; function Sl() { return { localeError: Gl() } } const Ml = () => { const e = { string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" }, file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" }, array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }, set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "எண் அல்லாதது" : "எண்"; case "object": { if (Array.isArray(t)) return "அணி"; if (t === null) return "வெறுமை"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "உள்ளீடு", email: "மின்னஞ்சல் முகவரி", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO தேதி நேரம்", date: "ISO தேதி", time: "ISO நேரம்", duration: "ISO கால அளவு", ipv4: "IPv4 முகவரி", ipv6: "IPv6 முகவரி", cidrv4: "IPv4 வரம்பு", cidrv6: "IPv6 வரம்பு", base64: "base64-encoded சரம்", base64url: "base64url-encoded சரம்", json_string: "JSON சரம்", e164: "E.164 எண்", jwt: "JWT", template_literal: "input" }; return t => { switch (t.code) { case "invalid_type": return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${t.expected}, பெறப்பட்டது ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${L(t.values[0])}` : `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${N(t.values, "|")} இல் ஒன்று`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${t.origin ?? "மதிப்பு"} ${i}${t.maximum.toString()} ${n.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்` : `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${t.origin ?? "மதிப்பு"} ${i}${t.maximum.toString()} ஆக இருக்க வேண்டும்` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${t.origin} ${i}${t.minimum.toString()} ${n.unit} ஆக இருக்க வேண்டும்` : `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${t.origin} ${i}${t.minimum.toString()} ஆக இருக்க வேண்டும்` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `தவறான சரம்: "${i.prefix}" இல் தொடங்க வேண்டும்` : i.format === "ends_with" ? `தவறான சரம்: "${i.suffix}" இல் முடிவடைய வேண்டும்` : i.format === "includes" ? `தவறான சரம்: "${i.includes}" ஐ உள்ளடக்க வேண்டும்` : i.format === "regex" ? `தவறான சரம்: ${i.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்` : `தவறான ${I[i.format] ?? t.format}` } case "not_multiple_of": return `தவறான எண்: ${t.divisor} இன் பலமாக இருக்க வேண்டும்`; case "unrecognized_keys": return `அடையாளம் தெரியாத விசை${t.keys.length > 1 ? "கள்" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `${t.origin} இல் தவறான விசை`; case "invalid_union": return "தவறான உள்ளீடு"; case "invalid_element": return `${t.origin} இல் தவறான மதிப்பு`; default: return "தவறான உள்ளீடு" } } }; function Fl() { return { localeError: Ml() } } const Ul = () => { const e = { string: { unit: "ตัวอักษร", verb: "ควรมี" }, file: { unit: "ไบต์", verb: "ควรมี" }, array: { unit: "รายการ", verb: "ควรมี" }, set: { unit: "รายการ", verb: "ควรมี" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข"; case "object": { if (Array.isArray(t)) return "อาร์เรย์ (Array)"; if (t === null) return "ไม่มีค่า (null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ข้อมูลที่ป้อน", email: "ที่อยู่อีเมล", url: "URL", emoji: "อิโมจิ", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "วันที่เวลาแบบ ISO", date: "วันที่แบบ ISO", time: "เวลาแบบ ISO", duration: "ช่วงเวลาแบบ ISO", ipv4: "ที่อยู่ IPv4", ipv6: "ที่อยู่ IPv6", cidrv4: "ช่วง IP แบบ IPv4", cidrv6: "ช่วง IP แบบ IPv6", base64: "ข้อความแบบ Base64", base64url: "ข้อความแบบ Base64 สำหรับ URL", json_string: "ข้อความแบบ JSON", e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)", jwt: "โทเคน JWT", template_literal: "ข้อมูลที่ป้อน" }; return t => { switch (t.code) { case "invalid_type": return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${t.expected} แต่ได้รับ ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `ค่าไม่ถูกต้อง: ควรเป็น ${L(t.values[0])}` : `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "ไม่เกิน" : "น้อยกว่า", n = A(t.origin); return n ? `เกินกำหนด: ${t.origin ?? "ค่า"} ควรมี${i} ${t.maximum.toString()} ${n.unit ?? "รายการ"}` : `เกินกำหนด: ${t.origin ?? "ค่า"} ควรมี${i} ${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? "อย่างน้อย" : "มากกว่า", n = A(t.origin); return n ? `น้อยกว่ากำหนด: ${t.origin} ควรมี${i} ${t.minimum.toString()} ${n.unit}` : `น้อยกว่ากำหนด: ${t.origin} ควรมี${i} ${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${i.prefix}"` : i.format === "ends_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${i.suffix}"` : i.format === "includes" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${i.includes}" อยู่ในข้อความ` : i.format === "regex" ? `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${i.pattern}` : `รูปแบบไม่ถูกต้อง: ${I[i.format] ?? t.format}` } case "not_multiple_of": return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${t.divisor} ได้ลงตัว`; case "unrecognized_keys": return `พบคีย์ที่ไม่รู้จัก: ${N(t.keys, ", ")}`; case "invalid_key": return `คีย์ไม่ถูกต้องใน ${t.origin}`; case "invalid_union": return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้"; case "invalid_element": return `ข้อมูลไม่ถูกต้องใน ${t.origin}`; default: return "ข้อมูลไม่ถูกต้อง" } } }; function Rl() { return { localeError: Ul() } } const bl = e => { const A = typeof e; switch (A) { case "number": return Number.isNaN(e) ? "NaN" : "number"; case "object": { if (Array.isArray(e)) return "array"; if (e === null) return "null"; if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor) return e.constructor.name } }return A }, Yl = () => { const e = { string: { unit: "karakter", verb: "olmalı" }, file: { unit: "bayt", verb: "olmalı" }, array: { unit: "öğe", verb: "olmalı" }, set: { unit: "öğe", verb: "olmalı" } }; function A(I) { return e[I] ?? null } const g = { regex: "girdi", email: "e-posta adresi", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO tarih ve saat", date: "ISO tarih", time: "ISO saat", duration: "ISO süre", ipv4: "IPv4 adresi", ipv6: "IPv6 adresi", cidrv4: "IPv4 aralığı", cidrv6: "IPv6 aralığı", base64: "base64 ile şifrelenmiş metin", base64url: "base64url ile şifrelenmiş metin", json_string: "JSON dizesi", e164: "E.164 sayısı", jwt: "JWT", template_literal: "Şablon dizesi" }; return I => { switch (I.code) { case "invalid_type": return `Geçersiz değer: beklenen ${I.expected}, alınan ${bl(I.input)}`; case "invalid_value": return I.values.length === 1 ? `Geçersiz değer: beklenen ${L(I.values[0])}` : `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${N(I.values, "|")}`; case "too_big": { const t = I.inclusive ? "<=" : "<", i = A(I.origin); return i ? `Çok büyük: beklenen ${I.origin ?? "değer"} ${t}${I.maximum.toString()} ${i.unit ?? "öğe"}` : `Çok büyük: beklenen ${I.origin ?? "değer"} ${t}${I.maximum.toString()}` } case "too_small": { const t = I.inclusive ? ">=" : ">", i = A(I.origin); return i ? `Çok küçük: beklenen ${I.origin} ${t}${I.minimum.toString()} ${i.unit}` : `Çok küçük: beklenen ${I.origin} ${t}${I.minimum.toString()}` } case "invalid_format": { const t = I; return t.format === "starts_with" ? `Geçersiz metin: "${t.prefix}" ile başlamalı` : t.format === "ends_with" ? `Geçersiz metin: "${t.suffix}" ile bitmeli` : t.format === "includes" ? `Geçersiz metin: "${t.includes}" içermeli` : t.format === "regex" ? `Geçersiz metin: ${t.pattern} desenine uymalı` : `Geçersiz ${g[t.format] ?? I.format}` } case "not_multiple_of": return `Geçersiz sayı: ${I.divisor} ile tam bölünebilmeli`; case "unrecognized_keys": return `Tanınmayan anahtar${I.keys.length > 1 ? "lar" : ""}: ${N(I.keys, ", ")}`; case "invalid_key": return `${I.origin} içinde geçersiz anahtar`; case "invalid_union": return "Geçersiz değer"; case "invalid_element": return `${I.origin} içinde geçersiz değer`; default: return "Geçersiz değer" } } }; function Kl() { return { localeError: Yl() } } const vl = () => { const e = { string: { unit: "символів", verb: "матиме" }, file: { unit: "байтів", verb: "матиме" }, array: { unit: "елементів", verb: "матиме" }, set: { unit: "елементів", verb: "матиме" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "число"; case "object": { if (Array.isArray(t)) return "масив"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "вхідні дані", email: "адреса електронної пошти", url: "URL", emoji: "емодзі", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "дата та час ISO", date: "дата ISO", time: "час ISO", duration: "тривалість ISO", ipv4: "адреса IPv4", ipv6: "адреса IPv6", cidrv4: "діапазон IPv4", cidrv6: "діапазон IPv6", base64: "рядок у кодуванні base64", base64url: "рядок у кодуванні base64url", json_string: "рядок JSON", e164: "номер E.164", jwt: "JWT", template_literal: "вхідні дані" }; return t => { switch (t.code) { case "invalid_type": return `Неправильні вхідні дані: очікується ${t.expected}, отримано ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Неправильні вхідні дані: очікується ${L(t.values[0])}` : `Неправильна опція: очікується одне з ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Занадто велике: очікується, що ${t.origin ?? "значення"} ${n.verb} ${i}${t.maximum.toString()} ${n.unit ?? "елементів"}` : `Занадто велике: очікується, що ${t.origin ?? "значення"} буде ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Занадто мале: очікується, що ${t.origin} ${n.verb} ${i}${t.minimum.toString()} ${n.unit}` : `Занадто мале: очікується, що ${t.origin} буде ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Неправильний рядок: повинен починатися з "${i.prefix}"` : i.format === "ends_with" ? `Неправильний рядок: повинен закінчуватися на "${i.suffix}"` : i.format === "includes" ? `Неправильний рядок: повинен містити "${i.includes}"` : i.format === "regex" ? `Неправильний рядок: повинен відповідати шаблону ${i.pattern}` : `Неправильний ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Неправильне число: повинно бути кратним ${t.divisor}`; case "unrecognized_keys": return `Нерозпізнаний ключ${t.keys.length > 1 ? "і" : ""}: ${N(t.keys, ", ")}`; case "invalid_key": return `Неправильний ключ у ${t.origin}`; case "invalid_union": return "Неправильні вхідні дані"; case "invalid_element": return `Неправильне значення у ${t.origin}`; default: return "Неправильні вхідні дані" } } }; function VQ() { return { localeError: vl() } } function Jl() { return VQ() } const Hl = () => { const e = { string: { unit: "حروف", verb: "ہونا" }, file: { unit: "بائٹس", verb: "ہونا" }, array: { unit: "آئٹمز", verb: "ہونا" }, set: { unit: "آئٹمز", verb: "ہونا" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "نمبر"; case "object": { if (Array.isArray(t)) return "آرے"; if (t === null) return "نل"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ان پٹ", email: "ای میل ایڈریس", url: "یو آر ایل", emoji: "ایموجی", uuid: "یو یو آئی ڈی", uuidv4: "یو یو آئی ڈی وی 4", uuidv6: "یو یو آئی ڈی وی 6", nanoid: "نینو آئی ڈی", guid: "جی یو آئی ڈی", cuid: "سی یو آئی ڈی", cuid2: "سی یو آئی ڈی 2", ulid: "یو ایل آئی ڈی", xid: "ایکس آئی ڈی", ksuid: "کے ایس یو آئی ڈی", datetime: "آئی ایس او ڈیٹ ٹائم", date: "آئی ایس او تاریخ", time: "آئی ایس او وقت", duration: "آئی ایس او مدت", ipv4: "آئی پی وی 4 ایڈریس", ipv6: "آئی پی وی 6 ایڈریس", cidrv4: "آئی پی وی 4 رینج", cidrv6: "آئی پی وی 6 رینج", base64: "بیس 64 ان کوڈڈ سٹرنگ", base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ", json_string: "جے ایس او این سٹرنگ", e164: "ای 164 نمبر", jwt: "جے ڈبلیو ٹی", template_literal: "ان پٹ" }; return t => { switch (t.code) { case "invalid_type": return `غلط ان پٹ: ${t.expected} متوقع تھا، ${g(t.input)} موصول ہوا`; case "invalid_value": return t.values.length === 1 ? `غلط ان پٹ: ${L(t.values[0])} متوقع تھا` : `غلط آپشن: ${N(t.values, "|")} میں سے ایک متوقع تھا`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `بہت بڑا: ${t.origin ?? "ویلیو"} کے ${i}${t.maximum.toString()} ${n.unit ?? "عناصر"} ہونے متوقع تھے` : `بہت بڑا: ${t.origin ?? "ویلیو"} کا ${i}${t.maximum.toString()} ہونا متوقع تھا` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `بہت چھوٹا: ${t.origin} کے ${i}${t.minimum.toString()} ${n.unit} ہونے متوقع تھے` : `بہت چھوٹا: ${t.origin} کا ${i}${t.minimum.toString()} ہونا متوقع تھا` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `غلط سٹرنگ: "${i.prefix}" سے شروع ہونا چاہیے` : i.format === "ends_with" ? `غلط سٹرنگ: "${i.suffix}" پر ختم ہونا چاہیے` : i.format === "includes" ? `غلط سٹرنگ: "${i.includes}" شامل ہونا چاہیے` : i.format === "regex" ? `غلط سٹرنگ: پیٹرن ${i.pattern} سے میچ ہونا چاہیے` : `غلط ${I[i.format] ?? t.format}` } case "not_multiple_of": return `غلط نمبر: ${t.divisor} کا مضاعف ہونا چاہیے`; case "unrecognized_keys": return `غیر تسلیم شدہ کی${t.keys.length > 1 ? "ز" : ""}: ${N(t.keys, "، ")}`; case "invalid_key": return `${t.origin} میں غلط کی`; case "invalid_union": return "غلط ان پٹ"; case "invalid_element": return `${t.origin} میں غلط ویلیو`; default: return "غلط ان پٹ" } } }; function Ll() { return { localeError: Hl() } } const ql = () => { const e = { string: { unit: "ký tự", verb: "có" }, file: { unit: "byte", verb: "có" }, array: { unit: "phần tử", verb: "có" }, set: { unit: "phần tử", verb: "có" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "số"; case "object": { if (Array.isArray(t)) return "mảng"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "đầu vào", email: "địa chỉ email", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ngày giờ ISO", date: "ngày ISO", time: "giờ ISO", duration: "khoảng thời gian ISO", ipv4: "địa chỉ IPv4", ipv6: "địa chỉ IPv6", cidrv4: "dải IPv4", cidrv6: "dải IPv6", base64: "chuỗi mã hóa base64", base64url: "chuỗi mã hóa base64url", json_string: "chuỗi JSON", e164: "số E.164", jwt: "JWT", template_literal: "đầu vào" }; return t => { switch (t.code) { case "invalid_type": return `Đầu vào không hợp lệ: mong đợi ${t.expected}, nhận được ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Đầu vào không hợp lệ: mong đợi ${L(t.values[0])}` : `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Quá lớn: mong đợi ${t.origin ?? "giá trị"} ${n.verb} ${i}${t.maximum.toString()} ${n.unit ?? "phần tử"}` : `Quá lớn: mong đợi ${t.origin ?? "giá trị"} ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Quá nhỏ: mong đợi ${t.origin} ${n.verb} ${i}${t.minimum.toString()} ${n.unit}` : `Quá nhỏ: mong đợi ${t.origin} ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Chuỗi không hợp lệ: phải bắt đầu bằng "${i.prefix}"` : i.format === "ends_with" ? `Chuỗi không hợp lệ: phải kết thúc bằng "${i.suffix}"` : i.format === "includes" ? `Chuỗi không hợp lệ: phải bao gồm "${i.includes}"` : i.format === "regex" ? `Chuỗi không hợp lệ: phải khớp với mẫu ${i.pattern}` : `${I[i.format] ?? t.format} không hợp lệ` } case "not_multiple_of": return `Số không hợp lệ: phải là bội số của ${t.divisor}`; case "unrecognized_keys": return `Khóa không được nhận dạng: ${N(t.keys, ", ")}`; case "invalid_key": return `Khóa không hợp lệ trong ${t.origin}`; case "invalid_union": return "Đầu vào không hợp lệ"; case "invalid_element": return `Giá trị không hợp lệ trong ${t.origin}`; default: return "Đầu vào không hợp lệ" } } }; function xl() { return { localeError: ql() } } const zl = () => { const e = { string: { unit: "字符", verb: "包含" }, file: { unit: "字节", verb: "包含" }, array: { unit: "项", verb: "包含" }, set: { unit: "项", verb: "包含" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "非数字(NaN)" : "数字"; case "object": { if (Array.isArray(t)) return "数组"; if (t === null) return "空值(null)"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "输入", email: "电子邮件", url: "URL", emoji: "表情符号", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO日期时间", date: "ISO日期", time: "ISO时间", duration: "ISO时长", ipv4: "IPv4地址", ipv6: "IPv6地址", cidrv4: "IPv4网段", cidrv6: "IPv6网段", base64: "base64编码字符串", base64url: "base64url编码字符串", json_string: "JSON字符串", e164: "E.164号码", jwt: "JWT", template_literal: "输入" }; return t => { switch (t.code) { case "invalid_type": return `无效输入：期望 ${t.expected}，实际接收 ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `无效输入：期望 ${L(t.values[0])}` : `无效选项：期望以下之一 ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `数值过大：期望 ${t.origin ?? "值"} ${i}${t.maximum.toString()} ${n.unit ?? "个元素"}` : `数值过大：期望 ${t.origin ?? "值"} ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `数值过小：期望 ${t.origin} ${i}${t.minimum.toString()} ${n.unit}` : `数值过小：期望 ${t.origin} ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `无效字符串：必须以 "${i.prefix}" 开头` : i.format === "ends_with" ? `无效字符串：必须以 "${i.suffix}" 结尾` : i.format === "includes" ? `无效字符串：必须包含 "${i.includes}"` : i.format === "regex" ? `无效字符串：必须满足正则表达式 ${i.pattern}` : `无效${I[i.format] ?? t.format}` } case "not_multiple_of": return `无效数字：必须是 ${t.divisor} 的倍数`; case "unrecognized_keys": return `出现未知的键(key): ${N(t.keys, ", ")}`; case "invalid_key": return `${t.origin} 中的键(key)无效`; case "invalid_union": return "无效输入"; case "invalid_element": return `${t.origin} 中包含无效值(value)`; default: return "无效输入" } } }; function Ol() { return { localeError: zl() } } const jl = () => { const e = { string: { unit: "字元", verb: "擁有" }, file: { unit: "位元組", verb: "擁有" }, array: { unit: "項目", verb: "擁有" }, set: { unit: "項目", verb: "擁有" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "number"; case "object": { if (Array.isArray(t)) return "array"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "輸入", email: "郵件地址", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO 日期時間", date: "ISO 日期", time: "ISO 時間", duration: "ISO 期間", ipv4: "IPv4 位址", ipv6: "IPv6 位址", cidrv4: "IPv4 範圍", cidrv6: "IPv6 範圍", base64: "base64 編碼字串", base64url: "base64url 編碼字串", json_string: "JSON 字串", e164: "E.164 數值", jwt: "JWT", template_literal: "輸入" }; return t => { switch (t.code) { case "invalid_type": return `無效的輸入值：預期為 ${t.expected}，但收到 ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `無效的輸入值：預期為 ${L(t.values[0])}` : `無效的選項：預期為以下其中之一 ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `數值過大：預期 ${t.origin ?? "值"} 應為 ${i}${t.maximum.toString()} ${n.unit ?? "個元素"}` : `數值過大：預期 ${t.origin ?? "值"} 應為 ${i}${t.maximum.toString()}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `數值過小：預期 ${t.origin} 應為 ${i}${t.minimum.toString()} ${n.unit}` : `數值過小：預期 ${t.origin} 應為 ${i}${t.minimum.toString()}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `無效的字串：必須以 "${i.prefix}" 開頭` : i.format === "ends_with" ? `無效的字串：必須以 "${i.suffix}" 結尾` : i.format === "includes" ? `無效的字串：必須包含 "${i.includes}"` : i.format === "regex" ? `無效的字串：必須符合格式 ${i.pattern}` : `無效的 ${I[i.format] ?? t.format}` } case "not_multiple_of": return `無效的數字：必須為 ${t.divisor} 的倍數`; case "unrecognized_keys": return `無法識別的鍵值${t.keys.length > 1 ? "們" : ""}：${N(t.keys, "、")}`; case "invalid_key": return `${t.origin} 中有無效的鍵值`; case "invalid_union": return "無效的輸入值"; case "invalid_element": return `${t.origin} 中有無效的值`; default: return "無效的輸入值" } } }; function Tl() { return { localeError: jl() } } const Zl = () => { const e = { string: { unit: "àmi", verb: "ní" }, file: { unit: "bytes", verb: "ní" }, array: { unit: "nkan", verb: "ní" }, set: { unit: "nkan", verb: "ní" } }; function A(t) { return e[t] ?? null } const g = t => { const i = typeof t; switch (i) { case "number": return Number.isNaN(t) ? "NaN" : "nọ́mbà"; case "object": { if (Array.isArray(t)) return "akopọ"; if (t === null) return "null"; if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor) return t.constructor.name } }return i }, I = { regex: "ẹ̀rọ ìbáwọlé", email: "àdírẹ́sì ìmẹ́lì", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "àkókò ISO", date: "ọjọ́ ISO", time: "àkókò ISO", duration: "àkókò tó pé ISO", ipv4: "àdírẹ́sì IPv4", ipv6: "àdírẹ́sì IPv6", cidrv4: "àgbègbè IPv4", cidrv6: "àgbègbè IPv6", base64: "ọ̀rọ̀ tí a kọ́ ní base64", base64url: "ọ̀rọ̀ base64url", json_string: "ọ̀rọ̀ JSON", e164: "nọ́mbà E.164", jwt: "JWT", template_literal: "ẹ̀rọ ìbáwọlé" }; return t => { switch (t.code) { case "invalid_type": return `Ìbáwọlé aṣìṣe: a ní láti fi ${t.expected}, àmọ̀ a rí ${g(t.input)}`; case "invalid_value": return t.values.length === 1 ? `Ìbáwọlé aṣìṣe: a ní láti fi ${L(t.values[0])}` : `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${N(t.values, "|")}`; case "too_big": { const i = t.inclusive ? "<=" : "<", n = A(t.origin); return n ? `Tó pọ̀ jù: a ní láti jẹ́ pé ${t.origin ?? "iye"} ${n.verb} ${i}${t.maximum} ${n.unit}` : `Tó pọ̀ jù: a ní láti jẹ́ ${i}${t.maximum}` } case "too_small": { const i = t.inclusive ? ">=" : ">", n = A(t.origin); return n ? `Kéré ju: a ní láti jẹ́ pé ${t.origin} ${n.verb} ${i}${t.minimum} ${n.unit}` : `Kéré ju: a ní láti jẹ́ ${i}${t.minimum}` } case "invalid_format": { const i = t; return i.format === "starts_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${i.prefix}"` : i.format === "ends_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${i.suffix}"` : i.format === "includes" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${i.includes}"` : i.format === "regex" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${i.pattern}` : `Aṣìṣe: ${I[i.format] ?? t.format}` } case "not_multiple_of": return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${t.divisor}`; case "unrecognized_keys": return `Bọtìnì àìmọ̀: ${N(t.keys, ", ")}`; case "invalid_key": return `Bọtìnì aṣìṣe nínú ${t.origin}`; case "invalid_union": return "Ìbáwọlé aṣìṣe"; case "invalid_element": return `Iye aṣìṣe nínú ${t.origin}`; default: return "Ìbáwọlé aṣìṣe" } } }; function Pl() { return { localeError: Zl() } } const WQ = Object.freeze(Object.defineProperty({ __proto__: null, ar: Qh, az: ah, be: ch, ca: hh, cs: wh, da: Dh, de: yh, en: ZQ, eo: Gh, es: Mh, fa: Uh, fi: bh, fr: Kh, frCA: Jh, he: Lh, hu: xh, id: Oh, is: Zh, it: Vh, ja: Xh, ka: Al, kh: gl, km: PQ, ko: Il, lt: rl, mk: Cl, ms: Ql, nl: al, no: cl, ota: hl, pl: Dl, ps: wl, pt: yl, ru: ml, sl: kl, sv: Sl, ta: Fl, th: Rl, tr: Kl, ua: Jl, uk: VQ, ur: Ll, vi: xl, yo: Pl, zhCN: Ol, zhTW: Tl }, Symbol.toStringTag, { value: "Module" })), XQ = Symbol("ZodOutput"), _Q = Symbol("ZodInput"); class An { constructor() { this._map = new WeakMap, this._idmap = new Map } add(A, ...g) { const I = g[0]; if (this._map.set(A, I), I && typeof I == "object" && "id" in I) { if (this._idmap.has(I.id)) throw new Error(`ID ${I.id} already exists in the registry`); this._idmap.set(I.id, A) } return this } clear() { return this._map = new WeakMap, this._idmap = new Map, this } remove(A) { const g = this._map.get(A); return g && typeof g == "object" && "id" in g && this._idmap.delete(g.id), this._map.delete(A), this } get(A) { const g = A._zod.parent; if (g) { const I = { ...this.get(g) ?? {} }; delete I.id; const t = { ...I, ...this._map.get(A) }; return Object.keys(t).length ? t : void 0 } return this._map.get(A) } has(A) { return this._map.has(A) } } function en() { return new An } const Ye = en(); function $Q(e, A) { return new e({ type: "string", ...y(A) }) } function As(e, A) { return new e({ type: "string", coerce: !0, ...y(A) }) } function gn(e, A) { return new e({ type: "string", format: "email", check: "string_format", abort: !1, ...y(A) }) } function zt(e, A) { return new e({ type: "string", format: "guid", check: "string_format", abort: !1, ...y(A) }) } function tn(e, A) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, ...y(A) }) } function In(e, A) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v4", ...y(A) }) } function nn(e, A) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v6", ...y(A) }) } function rn(e, A) { return new e({ type: "string", format: "uuid", check: "string_format", abort: !1, version: "v7", ...y(A) }) } function hI(e, A) { return new e({ type: "string", format: "url", check: "string_format", abort: !1, ...y(A) }) } function on(e, A) { return new e({ type: "string", format: "emoji", check: "string_format", abort: !1, ...y(A) }) } function Cn(e, A) { return new e({ type: "string", format: "nanoid", check: "string_format", abort: !1, ...y(A) }) } function Bn(e, A) { return new e({ type: "string", format: "cuid", check: "string_format", abort: !1, ...y(A) }) } function Qn(e, A) { return new e({ type: "string", format: "cuid2", check: "string_format", abort: !1, ...y(A) }) } function sn(e, A) { return new e({ type: "string", format: "ulid", check: "string_format", abort: !1, ...y(A) }) } function an(e, A) { return new e({ type: "string", format: "xid", check: "string_format", abort: !1, ...y(A) }) } function En(e, A) { return new e({ type: "string", format: "ksuid", check: "string_format", abort: !1, ...y(A) }) } function cn(e, A) { return new e({ type: "string", format: "ipv4", check: "string_format", abort: !1, ...y(A) }) } function un(e, A) { return new e({ type: "string", format: "ipv6", check: "string_format", abort: !1, ...y(A) }) } function hn(e, A) { return new e({ type: "string", format: "cidrv4", check: "string_format", abort: !1, ...y(A) }) } function ln(e, A) { return new e({ type: "string", format: "cidrv6", check: "string_format", abort: !1, ...y(A) }) } function wn(e, A) { return new e({ type: "string", format: "base64", check: "string_format", abort: !1, ...y(A) }) } function dn(e, A) { return new e({ type: "string", format: "base64url", check: "string_format", abort: !1, ...y(A) }) } function Dn(e, A) { return new e({ type: "string", format: "e164", check: "string_format", abort: !1, ...y(A) }) } function fn(e, A) { return new e({ type: "string", format: "jwt", check: "string_format", abort: !1, ...y(A) }) } const es = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 }; function gs(e, A) { return new e({ type: "string", format: "datetime", check: "string_format", offset: !1, local: !1, precision: null, ...y(A) }) } function ts(e, A) { return new e({ type: "string", format: "date", check: "string_format", ...y(A) }) } function Is(e, A) { return new e({ type: "string", format: "time", check: "string_format", precision: null, ...y(A) }) } function is(e, A) { return new e({ type: "string", format: "duration", check: "string_format", ...y(A) }) } function ns(e, A) { return new e({ type: "number", checks: [], ...y(A) }) } function rs(e, A) { return new e({ type: "number", coerce: !0, checks: [], ...y(A) }) } function os(e, A) { return new e({ type: "number", check: "number_format", abort: !1, format: "safeint", ...y(A) }) } function Cs(e, A) { return new e({ type: "number", check: "number_format", abort: !1, format: "float32", ...y(A) }) } function Bs(e, A) { return new e({ type: "number", check: "number_format", abort: !1, format: "float64", ...y(A) }) } function Qs(e, A) { return new e({ type: "number", check: "number_format", abort: !1, format: "int32", ...y(A) }) } function ss(e, A) { return new e({ type: "number", check: "number_format", abort: !1, format: "uint32", ...y(A) }) } function as(e, A) { return new e({ type: "boolean", ...y(A) }) } function Es(e, A) { return new e({ type: "boolean", coerce: !0, ...y(A) }) } function cs(e, A) { return new e({ type: "bigint", ...y(A) }) } function us(e, A) { return new e({ type: "bigint", coerce: !0, ...y(A) }) } function hs(e, A) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "int64", ...y(A) }) } function ls(e, A) { return new e({ type: "bigint", check: "bigint_format", abort: !1, format: "uint64", ...y(A) }) } function ws(e, A) { return new e({ type: "symbol", ...y(A) }) } function ds(e, A) { return new e({ type: "undefined", ...y(A) }) } function Ds(e, A) { return new e({ type: "null", ...y(A) }) } function fs(e) { return new e({ type: "any" }) } function ys(e) { return new e({ type: "unknown" }) } function ps(e, A) { return new e({ type: "never", ...y(A) }) } function ms(e, A) { return new e({ type: "void", ...y(A) }) } function Ns(e, A) { return new e({ type: "date", ...y(A) }) } function ks(e, A) { return new e({ type: "date", coerce: !0, ...y(A) }) } function Gs(e, A) { return new e({ type: "nan", ...y(A) }) } function ze(e, A) { return new Ti({ check: "less_than", ...y(A), value: e, inclusive: !1 }) } function zA(e, A) { return new Ti({ check: "less_than", ...y(A), value: e, inclusive: !0 }) } function Oe(e, A) { return new Zi({ check: "greater_than", ...y(A), value: e, inclusive: !1 }) } function GA(e, A) { return new Zi({ check: "greater_than", ...y(A), value: e, inclusive: !0 }) } function Ss(e) { return Oe(0, e) } function Ms(e) { return ze(0, e) } function Fs(e) { return zA(0, e) } function Us(e) { return GA(0, e) } function xg(e, A) { return new uB({ check: "multiple_of", ...y(A), value: e }) } function lI(e, A) { return new wB({ check: "max_size", ...y(A), maximum: e }) } function zg(e, A) { return new dB({ check: "min_size", ...y(A), minimum: e }) } function yn(e, A) { return new DB({ check: "size_equals", ...y(A), size: e }) } function wI(e, A) { return new fB({ check: "max_length", ...y(A), maximum: e }) } function ag(e, A) { return new yB({ check: "min_length", ...y(A), minimum: e }) } function dI(e, A) { return new pB({ check: "length_equals", ...y(A), length: e }) } function pn(e, A) { return new mB({ check: "string_format", format: "regex", ...y(A), pattern: e }) } function mn(e) { return new NB({ check: "string_format", format: "lowercase", ...y(e) }) } function Nn(e) { return new kB({ check: "string_format", format: "uppercase", ...y(e) }) } function kn(e, A) { return new GB({ check: "string_format", format: "includes", ...y(A), includes: e }) } function Gn(e, A) { return new SB({ check: "string_format", format: "starts_with", ...y(A), prefix: e }) } function Sn(e, A) { return new MB({ check: "string_format", format: "ends_with", ...y(A), suffix: e }) } function Rs(e, A, g) { return new FB({ check: "property", property: e, schema: A, ...y(g) }) } function Mn(e, A) { return new UB({ check: "mime_type", mime: e, ...y(A) }) } function We(e) { return new RB({ check: "overwrite", tx: e }) } function Fn(e) { return We(A => A.normalize(e)) } function Un() { return We(e => e.trim()) } function Rn() { return We(e => e.toLowerCase()) } function bn() { return We(e => e.toUpperCase()) } function bs(e, A, g) { return new e({ type: "array", element: A, ...y(g) }) } function Vl(e, A, g) { return new e({ type: "union", options: A, ...y(g) }) } function Wl(e, A, g, I) { return new e({ type: "union", options: g, discriminator: A, ...y(I) }) } function Xl(e, A, g) { return new e({ type: "intersection", left: A, right: g }) } function _l(e, A, g, I) { const t = g instanceof z, i = t ? I : g, n = t ? g : null; return new e({ type: "tuple", items: A, rest: n, ...y(i) }) } function $l(e, A, g, I) { return new e({ type: "record", keyType: A, valueType: g, ...y(I) }) } function Aw(e, A, g, I) { return new e({ type: "map", keyType: A, valueType: g, ...y(I) }) } function ew(e, A, g) { return new e({ type: "set", valueType: A, ...y(g) }) } function gw(e, A, g) { const I = Array.isArray(A) ? Object.fromEntries(A.map(t => [t, t])) : A; return new e({ type: "enum", entries: I, ...y(g) }) } function tw(e, A, g) { return new e({ type: "enum", entries: A, ...y(g) }) } function Iw(e, A, g) { return new e({ type: "literal", values: Array.isArray(A) ? A : [A], ...y(g) }) } function Ys(e, A) { return new e({ type: "file", ...y(A) }) } function iw(e, A) { return new e({ type: "transform", transform: A }) } function nw(e, A) { return new e({ type: "optional", innerType: A }) } function rw(e, A) { return new e({ type: "nullable", innerType: A }) } function ow(e, A, g) { return new e({ type: "default", innerType: A, get defaultValue() { return typeof g == "function" ? g() : aI(g) } }) } function Cw(e, A, g) { return new e({ type: "nonoptional", innerType: A, ...y(g) }) } function Bw(e, A) { return new e({ type: "success", innerType: A }) } function Qw(e, A, g) { return new e({ type: "catch", innerType: A, catchValue: typeof g == "function" ? g : () => g }) } function sw(e, A, g) { return new e({ type: "pipe", in: A, out: g }) } function aw(e, A) { return new e({ type: "readonly", innerType: A }) } function Ew(e, A, g) { return new e({ type: "template_literal", parts: A, ...y(g) }) } function cw(e, A) { return new e({ type: "lazy", getter: A }) } function uw(e, A) { return new e({ type: "promise", innerType: A }) } function Ks(e, A, g) { const I = y(g); return I.abort ?? (I.abort = !0), new e({ type: "custom", check: "custom", fn: A, ...I }) } function vs(e, A, g) { return new e({ type: "custom", check: "custom", fn: A, ...y(g) }) } function Js(e) { const A = Hs(g => (g.addIssue = I => { if (typeof I == "string") g.issues.push(Qg(I, g.value, A._zod.def)); else { const t = I; t.fatal && (t.continue = !1), t.code ?? (t.code = "custom"), t.input ?? (t.input = g.value), t.inst ?? (t.inst = A), t.continue ?? (t.continue = !A._zod.def.abort), g.issues.push(Qg(t)) } }, e(g.value, g))); return A } function Hs(e, A) { const g = new rA({ check: "custom", ...y(A) }); return g._zod.check = e, g } function Ls(e, A) { const g = y(A); let I = g.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], t = g.falsy ?? ["false", "0", "no", "off", "n", "disabled"]; g.case !== "sensitive" && (I = I.map(E => typeof E == "string" ? E.toLowerCase() : E), t = t.map(E => typeof E == "string" ? E.toLowerCase() : E)); const i = new Set(I), n = new Set(t), r = e.Codec ?? $i, o = e.Boolean ?? Wi, C = e.String ?? ot, B = new C({ type: "string", error: g.error }), Q = new o({ type: "boolean", error: g.error }), s = new r({ type: "pipe", in: B, out: Q, transform: ((E, a) => { let c = E; return g.case !== "sensitive" && (c = c.toLowerCase()), i.has(c) ? !0 : n.has(c) ? !1 : (a.issues.push({ code: "invalid_value", expected: "stringbool", values: [...i, ...n], input: a.value, inst: s, continue: !1 }), {}) }), reverseTransform: ((E, a) => E === !0 ? I[0] || "true" : t[0] || "false"), error: g.error }); return s } function Ct(e, A, g, I = {}) { const t = y(I), i = { ...y(I), check: "string_format", type: "string", format: A, fn: typeof g == "function" ? g : r => g.test(r), ...t }; return g instanceof RegExp && (i.pattern = g), new e(i) } class Qi {
      constructor(A) { this.counter = 0, this.metadataRegistry = A?.metadata ?? Ye, this.target = A?.target ?? "draft-2020-12", this.unrepresentable = A?.unrepresentable ?? "throw", this.override = A?.override ?? (() => { }), this.io = A?.io ?? "output", this.seen = new Map } process(A, g = { path: [], schemaPath: [] }) { var I; const t = A._zod.def, i = { guid: "uuid", url: "uri", datetime: "date-time", json_string: "json-string", regex: "" }, n = this.seen.get(A); if (n) return n.count++, g.schemaPath.includes(A) && (n.cycle = g.path), n.schema; const r = { schema: {}, count: 1, cycle: void 0, path: g.path }; this.seen.set(A, r); const o = A._zod.toJSONSchema?.(); if (o) r.schema = o; else { const Q = { ...g, schemaPath: [...g.schemaPath, A], path: g.path }, s = A._zod.parent; if (s) r.ref = s, this.process(s, Q), this.seen.get(s).isParent = !0; else { const E = r.schema; switch (t.type) { case "string": { const a = E; a.type = "string"; const { minimum: c, maximum: u, format: h, patterns: d, contentEncoding: w } = A._zod.bag; if (typeof c == "number" && (a.minLength = c), typeof u == "number" && (a.maxLength = u), h && (a.format = i[h] ?? h, a.format === "" && delete a.format), w && (a.contentEncoding = w), d && d.size > 0) { const f = [...d]; f.length === 1 ? a.pattern = f[0].source : f.length > 1 && (r.schema.allOf = [...f.map(F => ({ ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {}, pattern: F.source }))]) } break } case "number": { const a = E, { minimum: c, maximum: u, format: h, multipleOf: d, exclusiveMaximum: w, exclusiveMinimum: f } = A._zod.bag; typeof h == "string" && h.includes("int") ? a.type = "integer" : a.type = "number", typeof f == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (a.minimum = f, a.exclusiveMinimum = !0) : a.exclusiveMinimum = f), typeof c == "number" && (a.minimum = c, typeof f == "number" && this.target !== "draft-4" && (f >= c ? delete a.minimum : delete a.exclusiveMinimum)), typeof w == "number" && (this.target === "draft-4" || this.target === "openapi-3.0" ? (a.maximum = w, a.exclusiveMaximum = !0) : a.exclusiveMaximum = w), typeof u == "number" && (a.maximum = u, typeof w == "number" && this.target !== "draft-4" && (w <= u ? delete a.maximum : delete a.exclusiveMaximum)), typeof d == "number" && (a.multipleOf = d); break } case "boolean": { const a = E; a.type = "boolean"; break } case "bigint": { if (this.unrepresentable === "throw") throw new Error("BigInt cannot be represented in JSON Schema"); break } case "symbol": { if (this.unrepresentable === "throw") throw new Error("Symbols cannot be represented in JSON Schema"); break } case "null": { this.target === "openapi-3.0" ? (E.type = "string", E.nullable = !0, E.enum = [null]) : E.type = "null"; break } case "any": break; case "unknown": break; case "undefined": { if (this.unrepresentable === "throw") throw new Error("Undefined cannot be represented in JSON Schema"); break } case "void": { if (this.unrepresentable === "throw") throw new Error("Void cannot be represented in JSON Schema"); break } case "never": { E.not = {}; break } case "date": { if (this.unrepresentable === "throw") throw new Error("Date cannot be represented in JSON Schema"); break } case "array": { const a = E, { minimum: c, maximum: u } = A._zod.bag; typeof c == "number" && (a.minItems = c), typeof u == "number" && (a.maxItems = u), a.type = "array", a.items = this.process(t.element, { ...Q, path: [...Q.path, "items"] }); break } case "object": { const a = E; a.type = "object", a.properties = {}; const c = t.shape; for (const d in c) a.properties[d] = this.process(c[d], { ...Q, path: [...Q.path, "properties", d] }); const u = new Set(Object.keys(c)), h = new Set([...u].filter(d => { const w = t.shape[d]._zod; return this.io === "input" ? w.optin === void 0 : w.optout === void 0 })); h.size > 0 && (a.required = Array.from(h)), t.catchall?._zod.def.type === "never" ? a.additionalProperties = !1 : t.catchall ? t.catchall && (a.additionalProperties = this.process(t.catchall, { ...Q, path: [...Q.path, "additionalProperties"] })) : this.io === "output" && (a.additionalProperties = !1); break } case "union": { const a = E, c = t.options.map((u, h) => this.process(u, { ...Q, path: [...Q.path, "anyOf", h] })); a.anyOf = c; break } case "intersection": { const a = E, c = this.process(t.left, { ...Q, path: [...Q.path, "allOf", 0] }), u = this.process(t.right, { ...Q, path: [...Q.path, "allOf", 1] }), h = w => "allOf" in w && Object.keys(w).length === 1, d = [...h(c) ? c.allOf : [c], ...h(u) ? u.allOf : [u]]; a.allOf = d; break } case "tuple": { const a = E; a.type = "array"; const c = this.target === "draft-2020-12" ? "prefixItems" : "items", u = this.target === "draft-2020-12" || this.target === "openapi-3.0" ? "items" : "additionalItems", h = t.items.map((F, Y) => this.process(F, { ...Q, path: [...Q.path, c, Y] })), d = t.rest ? this.process(t.rest, { ...Q, path: [...Q.path, u, ...this.target === "openapi-3.0" ? [t.items.length] : []] }) : null; this.target === "draft-2020-12" ? (a.prefixItems = h, d && (a.items = d)) : this.target === "openapi-3.0" ? (a.items = { anyOf: h }, d && a.items.anyOf.push(d), a.minItems = h.length, d || (a.maxItems = h.length)) : (a.items = h, d && (a.additionalItems = d)); const { minimum: w, maximum: f } = A._zod.bag; typeof w == "number" && (a.minItems = w), typeof f == "number" && (a.maxItems = f); break } case "record": { const a = E; a.type = "object", (this.target === "draft-7" || this.target === "draft-2020-12") && (a.propertyNames = this.process(t.keyType, { ...Q, path: [...Q.path, "propertyNames"] })), a.additionalProperties = this.process(t.valueType, { ...Q, path: [...Q.path, "additionalProperties"] }); break } case "map": { if (this.unrepresentable === "throw") throw new Error("Map cannot be represented in JSON Schema"); break } case "set": { if (this.unrepresentable === "throw") throw new Error("Set cannot be represented in JSON Schema"); break } case "enum": { const a = E, c = Mi(t.entries); c.every(u => typeof u == "number") && (a.type = "number"), c.every(u => typeof u == "string") && (a.type = "string"), a.enum = c; break } case "literal": { const a = E, c = []; for (const u of t.values) if (u === void 0) { if (this.unrepresentable === "throw") throw new Error("Literal `undefined` cannot be represented in JSON Schema") } else if (typeof u == "bigint") { if (this.unrepresentable === "throw") throw new Error("BigInt literals cannot be represented in JSON Schema"); c.push(Number(u)) } else c.push(u); if (c.length !== 0) if (c.length === 1) { const u = c[0]; a.type = u === null ? "null" : typeof u, this.target === "draft-4" || this.target === "openapi-3.0" ? a.enum = [u] : a.const = u } else c.every(u => typeof u == "number") && (a.type = "number"), c.every(u => typeof u == "string") && (a.type = "string"), c.every(u => typeof u == "boolean") && (a.type = "string"), c.every(u => u === null) && (a.type = "null"), a.enum = c; break } case "file": { const a = E, c = { type: "string", format: "binary", contentEncoding: "binary" }, { minimum: u, maximum: h, mime: d } = A._zod.bag; u !== void 0 && (c.minLength = u), h !== void 0 && (c.maxLength = h), d ? d.length === 1 ? (c.contentMediaType = d[0], Object.assign(a, c)) : a.anyOf = d.map(w => ({ ...c, contentMediaType: w })) : Object.assign(a, c); break } case "transform": { if (this.unrepresentable === "throw") throw new Error("Transforms cannot be represented in JSON Schema"); break } case "nullable": { const a = this.process(t.innerType, Q); this.target === "openapi-3.0" ? (r.ref = t.innerType, E.nullable = !0) : E.anyOf = [a, { type: "null" }]; break } case "nonoptional": { this.process(t.innerType, Q), r.ref = t.innerType; break } case "success": { const a = E; a.type = "boolean"; break } case "default": { this.process(t.innerType, Q), r.ref = t.innerType, E.default = JSON.parse(JSON.stringify(t.defaultValue)); break } case "prefault": { this.process(t.innerType, Q), r.ref = t.innerType, this.io === "input" && (E._prefault = JSON.parse(JSON.stringify(t.defaultValue))); break } case "catch": { this.process(t.innerType, Q), r.ref = t.innerType; let a; try { a = t.catchValue(void 0) } catch { throw new Error("Dynamic catch values are not supported in JSON Schema") } E.default = a; break } case "nan": { if (this.unrepresentable === "throw") throw new Error("NaN cannot be represented in JSON Schema"); break } case "template_literal": { const a = E, c = A._zod.pattern; if (!c) throw new Error("Pattern not found in template literal"); a.type = "string", a.pattern = c.source; break } case "pipe": { const a = this.io === "input" ? t.in._zod.def.type === "transform" ? t.out : t.in : t.out; this.process(a, Q), r.ref = a; break } case "readonly": { this.process(t.innerType, Q), r.ref = t.innerType, E.readOnly = !0; break } case "promise": { this.process(t.innerType, Q), r.ref = t.innerType; break } case "optional": { this.process(t.innerType, Q), r.ref = t.innerType; break } case "lazy": { const a = A._zod.innerType; this.process(a, Q), r.ref = a; break } case "custom": { if (this.unrepresentable === "throw") throw new Error("Custom types cannot be represented in JSON Schema"); break } case "function": { if (this.unrepresentable === "throw") throw new Error("Function types cannot be represented in JSON Schema"); break } } } } const C = this.metadataRegistry.get(A); return C && Object.assign(r.schema, C), this.io === "input" && CA(A) && (delete r.schema.examples, delete r.schema.default), this.io === "input" && r.schema._prefault && ((I = r.schema).default ?? (I.default = r.schema._prefault)), delete r.schema._prefault, this.seen.get(A).schema } emit(A, g) {
        const I = { cycles: g?.cycles ?? "ref", reused: g?.reused ?? "inline", external: g?.external ?? void 0 }, t = this.seen.get(A); if (!t) throw new Error("Unprocessed schema. This is a bug in Zod."); const i = B => { const Q = this.target === "draft-2020-12" ? "$defs" : "definitions"; if (I.external) { const c = I.external.registry.get(B[0])?.id, u = I.external.uri ?? (d => d); if (c) return { ref: u(c) }; const h = B[1].defId ?? B[1].schema.id ?? `schema${this.counter++}`; return B[1].defId = h, { defId: h, ref: `${u("__shared")}#/${Q}/${h}` } } if (B[1] === t) return { ref: "#" }; const E = `#/${Q}/`, a = B[1].schema.id ?? `__schema${this.counter++}`; return { defId: a, ref: E + a } }, n = B => { if (B[1].schema.$ref) return; const Q = B[1], { ref: s, defId: E } = i(B); Q.def = { ...Q.schema }, E && (Q.defId = E); const a = Q.schema; for (const c in a) delete a[c]; a.$ref = s }; if (I.cycles === "throw") for (const B of this.seen.entries()) {
          const Q = B[1]; if (Q.cycle) throw new Error(`Cycle detected: #/${Q.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`)
        } for (const B of this.seen.entries()) { const Q = B[1]; if (A === B[0]) { n(B); continue } if (I.external) { const E = I.external.registry.get(B[0])?.id; if (A !== B[0] && E) { n(B); continue } } if (this.metadataRegistry.get(B[0])?.id) { n(B); continue } if (Q.cycle) { n(B); continue } if (Q.count > 1 && I.reused === "ref") { n(B); continue } } const r = (B, Q) => { const s = this.seen.get(B), E = s.def ?? s.schema, a = { ...E }; if (s.ref === null) return; const c = s.ref; if (s.ref = null, c) { r(c, Q); const u = this.seen.get(c).schema; u.$ref && (Q.target === "draft-7" || Q.target === "draft-4" || Q.target === "openapi-3.0") ? (E.allOf = E.allOf ?? [], E.allOf.push(u)) : (Object.assign(E, u), Object.assign(E, a)) } s.isParent || this.override({ zodSchema: B, jsonSchema: E, path: s.path ?? [] }) }; for (const B of [...this.seen.entries()].reverse()) r(B[0], { target: this.target }); const o = {}; if (this.target === "draft-2020-12" ? o.$schema = "https://json-schema.org/draft/2020-12/schema" : this.target === "draft-7" ? o.$schema = "http://json-schema.org/draft-07/schema#" : this.target === "draft-4" ? o.$schema = "http://json-schema.org/draft-04/schema#" : this.target === "openapi-3.0" || console.warn(`Invalid target: ${this.target}`), I.external?.uri) { const B = I.external.registry.get(A)?.id; if (!B) throw new Error("Schema is missing an `id` property"); o.$id = I.external.uri(B) } Object.assign(o, t.def); const C = I.external?.defs ?? {}; for (const B of this.seen.entries()) { const Q = B[1]; Q.def && Q.defId && (C[Q.defId] = Q.def) } I.external || Object.keys(C).length > 0 && (this.target === "draft-2020-12" ? o.$defs = C : o.definitions = C); try { return JSON.parse(JSON.stringify(o)) } catch { throw new Error("Error converting schema to JSON.") }
      }
    } function qs(e, A) { if (e instanceof An) { const I = new Qi(A), t = {}; for (const r of e._idmap.entries()) { const [o, C] = r; I.process(C) } const i = {}, n = { registry: e, uri: A?.uri, defs: t }; for (const r of e._idmap.entries()) { const [o, C] = r; i[o] = I.emit(C, { ...A, external: n }) } if (Object.keys(t).length > 0) { const r = I.target === "draft-2020-12" ? "$defs" : "definitions"; i.__shared = { [r]: t } } return { schemas: i } } const g = new Qi(A); return g.process(e), g.emit(e, A) } function CA(e, A) { const g = A ?? { seen: new Set }; if (g.seen.has(e)) return !1; g.seen.add(e); const t = e._zod.def; switch (t.type) { case "string": case "number": case "bigint": case "boolean": case "date": case "symbol": case "undefined": case "null": case "any": case "unknown": case "never": case "void": case "literal": case "enum": case "nan": case "file": case "template_literal": return !1; case "array": return CA(t.element, g); case "object": { for (const i in t.shape) if (CA(t.shape[i], g)) return !0; return !1 } case "union": { for (const i of t.options) if (CA(i, g)) return !0; return !1 } case "intersection": return CA(t.left, g) || CA(t.right, g); case "tuple": { for (const i of t.items) if (CA(i, g)) return !0; return !!(t.rest && CA(t.rest, g)) } case "record": return CA(t.keyType, g) || CA(t.valueType, g); case "map": return CA(t.keyType, g) || CA(t.valueType, g); case "set": return CA(t.valueType, g); case "promise": case "optional": case "nonoptional": case "nullable": case "readonly": return CA(t.innerType, g); case "lazy": return CA(t.getter(), g); case "default": return CA(t.innerType, g); case "prefault": return CA(t.innerType, g); case "custom": return !1; case "transform": return !0; case "pipe": return CA(t.in, g) || CA(t.out, g); case "success": return !1; case "catch": return !1; case "function": return !1 }throw new Error(`Unknown schema type: ${t.type}`) } const hw = Object.freeze(Object.defineProperty({ __proto__: null }, Symbol.toStringTag, { value: "Module" })), lw = Object.freeze(Object.defineProperty({ __proto__: null, $ZodAny: aQ, $ZodArray: lQ, $ZodAsyncError: He, $ZodBase64: eQ, $ZodBase64URL: tQ, $ZodBigInt: Xi, $ZodBigIntFormat: CQ, $ZodBoolean: Wi, $ZodCIDRv4: $B, $ZodCIDRv6: AQ, $ZodCUID: xB, $ZodCUID2: zB, $ZodCatch: JQ, $ZodCheck: rA, $ZodCheckBigIntFormat: lB, $ZodCheckEndsWith: MB, $ZodCheckGreaterThan: Zi, $ZodCheckIncludes: GB, $ZodCheckLengthEquals: pB, $ZodCheckLessThan: Ti, $ZodCheckLowerCase: NB, $ZodCheckMaxLength: fB, $ZodCheckMaxSize: wB, $ZodCheckMimeType: UB, $ZodCheckMinLength: yB, $ZodCheckMinSize: dB, $ZodCheckMultipleOf: uB, $ZodCheckNumberFormat: hB, $ZodCheckOverwrite: RB, $ZodCheckProperty: FB, $ZodCheckRegex: mB, $ZodCheckSizeEquals: DB, $ZodCheckStartsWith: SB, $ZodCheckStringFormat: rt, $ZodCheckUpperCase: kB, $ZodCodec: $i, $ZodCustom: TQ, $ZodCustomStringFormat: rQ, $ZodDate: hQ, $ZodDefault: bQ, $ZodDiscriminatedUnion: yQ, $ZodE164: IQ, $ZodEmail: JB, $ZodEmoji: LB, $ZodEncodeError: QI, $ZodEnum: GQ, $ZodError: Ui, $ZodFile: MQ, $ZodFunction: zQ, $ZodGUID: KB, $ZodIPv4: XB, $ZodIPv6: _B, $ZodISODate: PB, $ZodISODateTime: ZB, $ZodISODuration: WB, $ZodISOTime: VB, $ZodIntersection: pQ, $ZodJWT: nQ, $ZodKSUID: TB, $ZodLazy: jQ, $ZodLiteral: SQ, $ZodMap: NQ, $ZodNaN: HQ, $ZodNanoID: qB, $ZodNever: cQ, $ZodNonOptional: KQ, $ZodNull: sQ, $ZodNullable: RQ, $ZodNumber: Vi, $ZodNumberFormat: oQ, $ZodObject: DQ, $ZodObjectJIT: fQ, $ZodOptional: UQ, $ZodPipe: LQ, $ZodPrefault: YQ, $ZodPromise: OQ, $ZodReadonly: qQ, $ZodRealError: FA, $ZodRecord: mQ, $ZodRegistry: An, $ZodSet: kQ, $ZodString: ot, $ZodStringFormat: tA, $ZodSuccess: vQ, $ZodSymbol: BQ, $ZodTemplateLiteral: xQ, $ZodTransform: FQ, $ZodTuple: _i, $ZodType: z, $ZodULID: OB, $ZodURL: HB, $ZodUUID: vB, $ZodUndefined: QQ, $ZodUnion: uI, $ZodUnknown: EQ, $ZodVoid: uQ, $ZodXID: jB, $brand: aC, $constructor: l, $input: _Q, $output: XQ, Doc: bB, JSONSchema: hw, JSONSchemaGenerator: Qi, NEVER: sC, TimePrecision: es, _any: fs, _array: bs, _base64: wn, _base64url: dn, _bigint: cs, _boolean: as, _catch: Qw, _check: Hs, _cidrv4: hn, _cidrv6: ln, _coercedBigint: us, _coercedBoolean: Es, _coercedDate: ks, _coercedNumber: rs, _coercedString: As, _cuid: Bn, _cuid2: Qn, _custom: Ks, _date: Ns, _decode: Ki, _decodeAsync: Ji, _default: ow, _discriminatedUnion: Wl, _e164: Dn, _email: gn, _emoji: on, _encode: Yi, _encodeAsync: vi, _endsWith: Sn, _enum: gw, _file: Ys, _float32: Cs, _float64: Bs, _gt: Oe, _gte: GA, _guid: zt, _includes: kn, _int: os, _int32: Qs, _int64: hs, _intersection: Xl, _ipv4: cn, _ipv6: un, _isoDate: ts, _isoDateTime: gs, _isoDuration: is, _isoTime: Is, _jwt: fn, _ksuid: En, _lazy: cw, _length: dI, _literal: Iw, _lowercase: mn, _lt: ze, _lte: zA, _map: Aw, _max: zA, _maxLength: wI, _maxSize: lI, _mime: Mn, _min: GA, _minLength: ag, _minSize: zg, _multipleOf: xg, _nan: Gs, _nanoid: Cn, _nativeEnum: tw, _negative: Ms, _never: ps, _nonnegative: Us, _nonoptional: Cw, _nonpositive: Fs, _normalize: Fn, _null: Ds, _nullable: rw, _number: ns, _optional: nw, _overwrite: We, _parse: et, _parseAsync: gt, _pipe: sw, _positive: Ss, _promise: uw, _property: Rs, _readonly: aw, _record: $l, _refine: vs, _regex: pn, _safeDecode: Li, _safeDecodeAsync: xi, _safeEncode: Hi, _safeEncodeAsync: qi, _safeParse: tt, _safeParseAsync: It, _set: ew, _size: yn, _startsWith: Gn, _string: $Q, _stringFormat: Ct, _stringbool: Ls, _success: Bw, _superRefine: Js, _symbol: ws, _templateLiteral: Ew, _toLowerCase: Rn, _toUpperCase: bn, _transform: iw, _trim: Un, _tuple: _l, _uint32: ss, _uint64: ls, _ulid: sn, _undefined: ds, _union: Vl, _unknown: ys, _uppercase: Nn, _url: hI, _uuid: tn, _uuidv4: In, _uuidv6: nn, _uuidv7: rn, _void: ms, _xid: an, clone: JA, config: DA, decode: Ru, decodeAsync: Yu, encode: Uu, encodeAsync: bu, flattenError: Ri, formatError: bi, globalConfig: Ht, globalRegistry: Ye, isValidBase64: Pi, isValidBase64URL: gQ, isValidJWT: iQ, locales: WQ, parse: oi, parseAsync: Ci, prettifyError: RC, regexes: ji, registry: en, safeDecode: vu, safeDecodeAsync: Hu, safeEncode: Ku, safeEncodeAsync: Ju, safeParse: bC, safeParseAsync: YC, toDotPath: UC, toJSONSchema: qs, treeifyError: FC, util: SC, version: YB }, Symbol.toStringTag, { value: "Module" })), Yn = l("ZodISODateTime", (e, A) => { ZB.init(e, A), IA.init(e, A) }); function xs(e) { return gs(Yn, e) } const Kn = l("ZodISODate", (e, A) => { PB.init(e, A), IA.init(e, A) }); function zs(e) { return ts(Kn, e) } const vn = l("ZodISOTime", (e, A) => { VB.init(e, A), IA.init(e, A) }); function Os(e) { return Is(vn, e) } const Jn = l("ZodISODuration", (e, A) => { WB.init(e, A), IA.init(e, A) }); function js(e) { return is(Jn, e) } const Ts = Object.freeze(Object.defineProperty({ __proto__: null, ZodISODate: Kn, ZodISODateTime: Yn, ZodISODuration: Jn, ZodISOTime: vn, date: zs, datetime: xs, duration: js, time: Os }, Symbol.toStringTag, { value: "Module" })), Zs = (e, A) => { Ui.init(e, A), e.name = "ZodError", Object.defineProperties(e, { format: { value: g => bi(e, g) }, flatten: { value: g => Ri(e, g) }, addIssue: { value: g => { e.issues.push(g), e.message = JSON.stringify(e.issues, Lt, 2) } }, addIssues: { value: g => { e.issues.push(...g), e.message = JSON.stringify(e.issues, Lt, 2) } }, isEmpty: { get() { return e.issues.length === 0 } } }) }, ww = l("ZodError", Zs), UA = l("ZodError", Zs, { Parent: Error }), Ps = et(UA), Vs = gt(UA), Ws = tt(UA), Xs = It(UA), _s = Yi(UA), $s = Ki(UA), Aa = vi(UA), ea = Ji(UA), ga = Hi(UA), ta = Li(UA), Ia = qi(UA), ia = xi(UA), P = l("ZodType", (e, A) => (z.init(e, A), e.def = A, e.type = A.type, Object.defineProperty(e, "_def", { value: A }), e.check = (...g) => e.clone(ae(A, { checks: [...A.checks ?? [], ...g.map(I => typeof I == "function" ? { _zod: { check: I, def: { check: "custom" }, onattach: [] } } : I)] })), e.clone = (g, I) => JA(e, g, I), e.brand = () => e, e.register = ((g, I) => (g.add(e, I), e)), e.parse = (g, I) => Ps(e, g, I, { callee: e.parse }), e.safeParse = (g, I) => Ws(e, g, I), e.parseAsync = async (g, I) => Vs(e, g, I, { callee: e.parseAsync }), e.safeParseAsync = async (g, I) => Xs(e, g, I), e.spa = e.safeParseAsync, e.encode = (g, I) => _s(e, g, I), e.decode = (g, I) => $s(e, g, I), e.encodeAsync = async (g, I) => Aa(e, g, I), e.decodeAsync = async (g, I) => ea(e, g, I), e.safeEncode = (g, I) => ga(e, g, I), e.safeDecode = (g, I) => ta(e, g, I), e.safeEncodeAsync = async (g, I) => Ia(e, g, I), e.safeDecodeAsync = async (g, I) => ia(e, g, I), e.refine = (g, I) => e.check(oE(g, I)), e.superRefine = g => e.check(CE(g)), e.overwrite = g => e.check(We(g)), e.optional = () => ee(e), e.nullable = () => Tt(e), e.nullish = () => ee(Tt(e)), e.nonoptional = g => Pa(e, g), e.array = () => Qt(e), e.or = g => GI([e, g]), e.and = g => nr(e, g), e.transform = g => Zt(e, Cr(g)), e.default = g => ja(e, g), e.prefault = g => Za(e, g), e.catch = g => Xa(e, g), e.pipe = g => Zt(e, g), e.readonly = () => eE(e), e.describe = g => { const I = e.clone(); return Ye.add(I, { description: g }), I }, Object.defineProperty(e, "description", { get() { return Ye.get(e)?.description }, configurable: !0 }), e.meta = (...g) => { if (g.length === 0) return Ye.get(e); const I = e.clone(); return Ye.add(I, g[0]), I }, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Hn = l("_ZodString", (e, A) => { ot.init(e, A), P.init(e, A); const g = e._zod.bag; e.format = g.format ?? null, e.minLength = g.minimum ?? null, e.maxLength = g.maximum ?? null, e.regex = (...I) => e.check(pn(...I)), e.includes = (...I) => e.check(kn(...I)), e.startsWith = (...I) => e.check(Gn(...I)), e.endsWith = (...I) => e.check(Sn(...I)), e.min = (...I) => e.check(ag(...I)), e.max = (...I) => e.check(wI(...I)), e.length = (...I) => e.check(dI(...I)), e.nonempty = (...I) => e.check(ag(1, ...I)), e.lowercase = I => e.check(mn(I)), e.uppercase = I => e.check(Nn(I)), e.trim = () => e.check(Un()), e.normalize = (...I) => e.check(Fn(...I)), e.toLowerCase = () => e.check(Rn()), e.toUpperCase = () => e.check(bn()) }), DI = l("ZodString", (e, A) => { ot.init(e, A), Hn.init(e, A), e.email = g => e.check(gn(Ln, g)), e.url = g => e.check(hI(fI, g)), e.jwt = g => e.check(fn(er, g)), e.emoji = g => e.check(on(qn, g)), e.guid = g => e.check(zt(Ot, g)), e.uuid = g => e.check(tn(Be, g)), e.uuidv4 = g => e.check(In(Be, g)), e.uuidv6 = g => e.check(nn(Be, g)), e.uuidv7 = g => e.check(rn(Be, g)), e.nanoid = g => e.check(Cn(xn, g)), e.guid = g => e.check(zt(Ot, g)), e.cuid = g => e.check(Bn(zn, g)), e.cuid2 = g => e.check(Qn(On, g)), e.ulid = g => e.check(sn(jn, g)), e.base64 = g => e.check(wn(_n, g)), e.base64url = g => e.check(dn($n, g)), e.xid = g => e.check(an(Tn, g)), e.ksuid = g => e.check(En(Zn, g)), e.ipv4 = g => e.check(cn(Pn, g)), e.ipv6 = g => e.check(un(Vn, g)), e.cidrv4 = g => e.check(hn(Wn, g)), e.cidrv6 = g => e.check(ln(Xn, g)), e.e164 = g => e.check(Dn(Ar, g)), e.datetime = g => e.check(xs(g)), e.date = g => e.check(zs(g)), e.time = g => e.check(Os(g)), e.duration = g => e.check(js(g)) }); function bA(e) { return $Q(DI, e) } const IA = l("ZodStringFormat", (e, A) => { tA.init(e, A), Hn.init(e, A) }), Ln = l("ZodEmail", (e, A) => { JB.init(e, A), IA.init(e, A) }); function na(e) { return gn(Ln, e) } const Ot = l("ZodGUID", (e, A) => { KB.init(e, A), IA.init(e, A) }); function dw(e) { return zt(Ot, e) } const Be = l("ZodUUID", (e, A) => { vB.init(e, A), IA.init(e, A) }); function ra(e) { return tn(Be, e) } function Dw(e) { return In(Be, e) } function fw(e) { return nn(Be, e) } function yw(e) { return rn(Be, e) } const fI = l("ZodURL", (e, A) => { HB.init(e, A), IA.init(e, A) }); function oa(e) { return hI(fI, e) } function pw(e) { return hI(fI, { protocol: /^https?$/, hostname: _C, ...y(e) }) } const qn = l("ZodEmoji", (e, A) => { LB.init(e, A), IA.init(e, A) }); function Ca(e) { return on(qn, e) } const xn = l("ZodNanoID", (e, A) => { qB.init(e, A), IA.init(e, A) }); function Ba(e) { return Cn(xn, e) } const zn = l("ZodCUID", (e, A) => { xB.init(e, A), IA.init(e, A) }); function Qa(e) { return Bn(zn, e) } const On = l("ZodCUID2", (e, A) => { zB.init(e, A), IA.init(e, A) }); function sa(e) { return Qn(On, e) } const jn = l("ZodULID", (e, A) => { OB.init(e, A), IA.init(e, A) }); function aa(e) { return sn(jn, e) } const Tn = l("ZodXID", (e, A) => { jB.init(e, A), IA.init(e, A) }); function mw(e) { return an(Tn, e) } const Zn = l("ZodKSUID", (e, A) => { TB.init(e, A), IA.init(e, A) }); function Nw(e) { return En(Zn, e) } const Pn = l("ZodIPv4", (e, A) => { XB.init(e, A), IA.init(e, A) }); function Ea(e) { return cn(Pn, e) } const Vn = l("ZodIPv6", (e, A) => { _B.init(e, A), IA.init(e, A) }); function ca(e) { return un(Vn, e) } const Wn = l("ZodCIDRv4", (e, A) => { $B.init(e, A), IA.init(e, A) }); function ua(e) { return hn(Wn, e) } const Xn = l("ZodCIDRv6", (e, A) => { AQ.init(e, A), IA.init(e, A) }); function ha(e) { return ln(Xn, e) } const _n = l("ZodBase64", (e, A) => { eQ.init(e, A), IA.init(e, A) }); function la(e) { return wn(_n, e) } const $n = l("ZodBase64URL", (e, A) => { tQ.init(e, A), IA.init(e, A) }); function wa(e) { return dn($n, e) } const Ar = l("ZodE164", (e, A) => { IQ.init(e, A), IA.init(e, A) }); function kw(e) { return Dn(Ar, e) } const er = l("ZodJWT", (e, A) => { nQ.init(e, A), IA.init(e, A) }); function Gw(e) { return fn(er, e) } const Bt = l("ZodCustomStringFormat", (e, A) => { rQ.init(e, A), IA.init(e, A) }); function Sw(e, A, g = {}) { return Ct(Bt, e, A, g) } function Mw(e) { return Ct(Bt, "hostname", Oi, e) } function Fw(e) { return Ct(Bt, "hex", EB, e) } function Uw(e, A) { const g = A?.enc ?? "hex", I = `${e}_${g}`, t = ji[I]; if (!t) throw new Error(`Unrecognized hash format: ${I}`); return Ct(Bt, I, t, A) } const yI = l("ZodNumber", (e, A) => { Vi.init(e, A), P.init(e, A), e.gt = (I, t) => e.check(Oe(I, t)), e.gte = (I, t) => e.check(GA(I, t)), e.min = (I, t) => e.check(GA(I, t)), e.lt = (I, t) => e.check(ze(I, t)), e.lte = (I, t) => e.check(zA(I, t)), e.max = (I, t) => e.check(zA(I, t)), e.int = I => e.check(jt(I)), e.safe = I => e.check(jt(I)), e.positive = I => e.check(Oe(0, I)), e.nonnegative = I => e.check(GA(0, I)), e.negative = I => e.check(ze(0, I)), e.nonpositive = I => e.check(zA(0, I)), e.multipleOf = (I, t) => e.check(xg(I, t)), e.step = (I, t) => e.check(xg(I, t)), e.finite = () => e; const g = e._zod.bag; e.minValue = Math.max(g.minimum ?? Number.NEGATIVE_INFINITY, g.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(g.maximum ?? Number.POSITIVE_INFINITY, g.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (g.format ?? "").includes("int") || Number.isSafeInteger(g.multipleOf ?? .5), e.isFinite = !0, e.format = g.format ?? null }); function Og(e) { return ns(yI, e) } const wg = l("ZodNumberFormat", (e, A) => { oQ.init(e, A), yI.init(e, A) }); function jt(e) { return os(wg, e) } function Rw(e) { return Cs(wg, e) } function bw(e) { return Bs(wg, e) } function da(e) { return Qs(wg, e) } function Yw(e) { return ss(wg, e) } const pI = l("ZodBoolean", (e, A) => { Wi.init(e, A), P.init(e, A) }); function mI(e) { return as(pI, e) } const NI = l("ZodBigInt", (e, A) => { Xi.init(e, A), P.init(e, A), e.gte = (I, t) => e.check(GA(I, t)), e.min = (I, t) => e.check(GA(I, t)), e.gt = (I, t) => e.check(Oe(I, t)), e.gte = (I, t) => e.check(GA(I, t)), e.min = (I, t) => e.check(GA(I, t)), e.lt = (I, t) => e.check(ze(I, t)), e.lte = (I, t) => e.check(zA(I, t)), e.max = (I, t) => e.check(zA(I, t)), e.positive = I => e.check(Oe(BigInt(0), I)), e.negative = I => e.check(ze(BigInt(0), I)), e.nonpositive = I => e.check(zA(BigInt(0), I)), e.nonnegative = I => e.check(GA(BigInt(0), I)), e.multipleOf = (I, t) => e.check(xg(I, t)); const g = e._zod.bag; e.minValue = g.minimum ?? null, e.maxValue = g.maximum ?? null, e.format = g.format ?? null }); function Kw(e) { return cs(NI, e) } const gr = l("ZodBigIntFormat", (e, A) => { CQ.init(e, A), NI.init(e, A) }); function vw(e) { return hs(gr, e) } function Jw(e) { return ls(gr, e) } const Da = l("ZodSymbol", (e, A) => { BQ.init(e, A), P.init(e, A) }); function Hw(e) { return ws(Da, e) } const fa = l("ZodUndefined", (e, A) => { QQ.init(e, A), P.init(e, A) }); function Lw(e) { return ds(fa, e) } const ya = l("ZodNull", (e, A) => { sQ.init(e, A), P.init(e, A) }); function pa(e) { return Ds(ya, e) } const ma = l("ZodAny", (e, A) => { aQ.init(e, A), P.init(e, A) }); function qw() { return fs(ma) } const Na = l("ZodUnknown", (e, A) => { EQ.init(e, A), P.init(e, A) }); function Eg() { return ys(Na) } const ka = l("ZodNever", (e, A) => { cQ.init(e, A), P.init(e, A) }); function tr(e) { return ps(ka, e) } const Ga = l("ZodVoid", (e, A) => { uQ.init(e, A), P.init(e, A) }); function xw(e) { return ms(Ga, e) } const Ir = l("ZodDate", (e, A) => { hQ.init(e, A), P.init(e, A), e.min = (I, t) => e.check(GA(I, t)), e.max = (I, t) => e.check(zA(I, t)); const g = e._zod.bag; e.minDate = g.minimum ? new Date(g.minimum) : null, e.maxDate = g.maximum ? new Date(g.maximum) : null }); function Sa(e) { return Ns(Ir, e) } const Ma = l("ZodArray", (e, A) => { lQ.init(e, A), P.init(e, A), e.element = A.element, e.min = (g, I) => e.check(ag(g, I)), e.nonempty = g => e.check(ag(1, g)), e.max = (g, I) => e.check(wI(g, I)), e.length = (g, I) => e.check(dI(g, I)), e.unwrap = () => e.element }); function Qt(e, A) { return bs(Ma, e, A) } function zw(e) { const A = e._zod.def.shape; return MI(Object.keys(A)) } const kI = l("ZodObject", (e, A) => { fQ.init(e, A), P.init(e, A), V(e, "shape", () => A.shape), e.keyof = () => MI(Object.keys(e._zod.def.shape)), e.catchall = g => e.clone({ ...e._zod.def, catchall: g }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Eg() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Eg() }), e.strict = () => e.clone({ ...e._zod.def, catchall: tr() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = g => fC(e, g), e.safeExtend = g => yC(e, g), e.merge = g => pC(e, g), e.pick = g => dC(e, g), e.omit = g => DC(e, g), e.partial = (...g) => mC(Br, e, g[0]), e.required = (...g) => NC(Qr, e, g[0]) }); function Fa(e, A) { const g = { type: "object", shape: e ?? {}, ...y(A) }; return new kI(g) } function Ua(e, A) { return new kI({ type: "object", shape: e, catchall: tr(), ...y(A) }) } function Ow(e, A) { return new kI({ type: "object", shape: e, catchall: Eg(), ...y(A) }) } const ir = l("ZodUnion", (e, A) => { uI.init(e, A), P.init(e, A), e.options = A.options }); function GI(e, A) { return new ir({ type: "union", options: e, ...y(A) }) } const Ra = l("ZodDiscriminatedUnion", (e, A) => { ir.init(e, A), yQ.init(e, A) }); function ba(e, A, g) { return new Ra({ type: "union", options: A, discriminator: e, ...y(g) }) } const Ya = l("ZodIntersection", (e, A) => { pQ.init(e, A), P.init(e, A) }); function nr(e, A) { return new Ya({ type: "intersection", left: e, right: A }) } const Ka = l("ZodTuple", (e, A) => { _i.init(e, A), P.init(e, A), e.rest = g => e.clone({ ...e._zod.def, rest: g }) }); function SI(e, A, g) { const I = A instanceof z, t = I ? g : A, i = I ? A : null; return new Ka({ type: "tuple", items: e, rest: i, ...y(t) }) } const rr = l("ZodRecord", (e, A) => { mQ.init(e, A), P.init(e, A), e.keyType = A.keyType, e.valueType = A.valueType }); function or(e, A, g) { return new rr({ type: "record", keyType: e, valueType: A, ...y(g) }) } function jw(e, A, g) { const I = JA(e); return I._zod.values = void 0, new rr({ type: "record", keyType: I, valueType: A, ...y(g) }) } const va = l("ZodMap", (e, A) => { NQ.init(e, A), P.init(e, A), e.keyType = A.keyType, e.valueType = A.valueType }); function Tw(e, A, g) { return new va({ type: "map", keyType: e, valueType: A, ...y(g) }) } const Ja = l("ZodSet", (e, A) => { kQ.init(e, A), P.init(e, A), e.min = (...g) => e.check(zg(...g)), e.nonempty = g => e.check(zg(1, g)), e.max = (...g) => e.check(lI(...g)), e.size = (...g) => e.check(yn(...g)) }); function Zw(e, A) { return new Ja({ type: "set", valueType: e, ...y(A) }) } const jg = l("ZodEnum", (e, A) => { GQ.init(e, A), P.init(e, A), e.enum = A.entries, e.options = Object.values(A.entries); const g = new Set(Object.keys(A.entries)); e.extract = (I, t) => { const i = {}; for (const n of I) if (g.has(n)) i[n] = A.entries[n]; else throw new Error(`Key ${n} not found in enum`); return new jg({ ...A, checks: [], ...y(t), entries: i }) }, e.exclude = (I, t) => { const i = { ...A.entries }; for (const n of I) if (g.has(n)) delete i[n]; else throw new Error(`Key ${n} not found in enum`); return new jg({ ...A, checks: [], ...y(t), entries: i }) } }); function MI(e, A) { const g = Array.isArray(e) ? Object.fromEntries(e.map(I => [I, I])) : e; return new jg({ type: "enum", entries: g, ...y(A) }) } function Pw(e, A) { return new jg({ type: "enum", entries: e, ...y(A) }) } const Ha = l("ZodLiteral", (e, A) => { SQ.init(e, A), P.init(e, A), e.values = new Set(A.values), Object.defineProperty(e, "value", { get() { if (A.values.length > 1) throw new Error("This schema contains multiple valid literal values. Use `.values` instead."); return A.values[0] } }) }); function La(e, A) { return new Ha({ type: "literal", values: Array.isArray(e) ? e : [e], ...y(A) }) } const qa = l("ZodFile", (e, A) => { MQ.init(e, A), P.init(e, A), e.min = (g, I) => e.check(zg(g, I)), e.max = (g, I) => e.check(lI(g, I)), e.mime = (g, I) => e.check(Mn(Array.isArray(g) ? g : [g], I)) }); function Vw(e) { return Ys(qa, e) } const xa = l("ZodTransform", (e, A) => { FQ.init(e, A), P.init(e, A), e._zod.parse = (g, I) => { if (I.direction === "backward") throw new QI(e.constructor.name); g.addIssue = i => { if (typeof i == "string") g.issues.push(Qg(i, g.value, A)); else { const n = i; n.fatal && (n.continue = !1), n.code ?? (n.code = "custom"), n.input ?? (n.input = g.value), n.inst ?? (n.inst = e), g.issues.push(Qg(n)) } }; const t = A.transform(g.value, g); return t instanceof Promise ? t.then(i => (g.value = i, g)) : (g.value = t, g) } }); function Cr(e) { return new xa({ type: "transform", transform: e }) } const Br = l("ZodOptional", (e, A) => { UQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function ee(e) { return new Br({ type: "optional", innerType: e }) } const za = l("ZodNullable", (e, A) => { RQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function Tt(e) { return new za({ type: "nullable", innerType: e }) } function Ww(e) { return ee(Tt(e)) } const Oa = l("ZodDefault", (e, A) => { bQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap }); function ja(e, A) { return new Oa({ type: "default", innerType: e, get defaultValue() { return typeof A == "function" ? A() : aI(A) } }) } const Ta = l("ZodPrefault", (e, A) => { YQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function Za(e, A) { return new Ta({ type: "prefault", innerType: e, get defaultValue() { return typeof A == "function" ? A() : aI(A) } }) } const Qr = l("ZodNonOptional", (e, A) => { KQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function Pa(e, A) { return new Qr({ type: "nonoptional", innerType: e, ...y(A) }) } const Va = l("ZodSuccess", (e, A) => { vQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function Xw(e) { return new Va({ type: "success", innerType: e }) } const Wa = l("ZodCatch", (e, A) => { JQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap }); function Xa(e, A) { return new Wa({ type: "catch", innerType: e, catchValue: typeof A == "function" ? A : () => A }) } const _a = l("ZodNaN", (e, A) => { HQ.init(e, A), P.init(e, A) }); function _w(e) { return Gs(_a, e) } const sr = l("ZodPipe", (e, A) => { LQ.init(e, A), P.init(e, A), e.in = A.in, e.out = A.out }); function Zt(e, A) { return new sr({ type: "pipe", in: e, out: A }) } const ar = l("ZodCodec", (e, A) => { sr.init(e, A), $i.init(e, A) }); function $a(e, A, g) { return new ar({ type: "pipe", in: e, out: A, transform: g.decode, reverseTransform: g.encode }) } const AE = l("ZodReadonly", (e, A) => { qQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function eE(e) { return new AE({ type: "readonly", innerType: e }) } const gE = l("ZodTemplateLiteral", (e, A) => { xQ.init(e, A), P.init(e, A) }); function tE(e, A) { return new gE({ type: "template_literal", parts: e, ...y(A) }) } const IE = l("ZodLazy", (e, A) => { jQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.getter() }); function iE(e) { return new IE({ type: "lazy", getter: e }) } const nE = l("ZodPromise", (e, A) => { OQ.init(e, A), P.init(e, A), e.unwrap = () => e._zod.def.innerType }); function $w(e) { return new nE({ type: "promise", innerType: e }) } const rE = l("ZodFunction", (e, A) => { zQ.init(e, A), P.init(e, A) }); function Eo(e) { return new rE({ type: "function", input: Array.isArray(e?.input) ? SI(e?.input) : e?.input ?? Qt(Eg()), output: e?.output ?? Eg() }) } const FI = l("ZodCustom", (e, A) => { TQ.init(e, A), P.init(e, A) }); function Ad(e) { const A = new rA({ check: "custom" }); return A._zod.check = e, A } function ed(e, A) { return Ks(FI, e ?? (() => !0), A) } function oE(e, A = {}) { return vs(FI, e, A) } function CE(e) { return Js(e) } function gd(e, A = { error: `Input not instance of ${e.name}` }) { const g = new FI({ type: "custom", check: "custom", fn: I => I instanceof e, abort: !0, ...y(A) }); return g._zod.bag.Class = e, g } const td = (...e) => Ls({ Codec: ar, Boolean: pI, String: DI }, ...e); function BE(e) { const A = iE(() => GI([bA(e), Og(), mI(), pa(), Qt(A), or(bA(), A)])); return A } function Id(e, A) { return Zt(Cr(e), A) } const id = { invalid_type: "invalid_type", too_big: "too_big", too_small: "too_small", invalid_format: "invalid_format", not_multiple_of: "not_multiple_of", unrecognized_keys: "unrecognized_keys", invalid_union: "invalid_union", invalid_key: "invalid_key", invalid_element: "invalid_element", invalid_value: "invalid_value", custom: "custom" }; function nd(e) { DA({ customError: e }) } function rd() { return DA().customError } var si; si || (si = {}); function od(e) { return As(DI, e) } function Cd(e) { return rs(yI, e) } function Bd(e) { return Es(pI, e) } function Qd(e) { return us(NI, e) } function sd(e) { return ks(Ir, e) } const ad = Object.freeze(Object.defineProperty({ __proto__: null, bigint: Qd, boolean: Bd, date: sd, number: Cd, string: od }, Symbol.toStringTag, { value: "Module" })); DA(ZQ()); const we = Object.freeze(Object.defineProperty({ __proto__: null, $brand: aC, $input: _Q, $output: XQ, NEVER: sC, TimePrecision: es, ZodAny: ma, ZodArray: Ma, ZodBase64: _n, ZodBase64URL: $n, ZodBigInt: NI, ZodBigIntFormat: gr, ZodBoolean: pI, ZodCIDRv4: Wn, ZodCIDRv6: Xn, ZodCUID: zn, ZodCUID2: On, ZodCatch: Wa, ZodCodec: ar, ZodCustom: FI, ZodCustomStringFormat: Bt, ZodDate: Ir, ZodDefault: Oa, ZodDiscriminatedUnion: Ra, ZodE164: Ar, ZodEmail: Ln, ZodEmoji: qn, ZodEnum: jg, ZodError: ww, ZodFile: qa, get ZodFirstPartyTypeKind() { return si }, ZodFunction: rE, ZodGUID: Ot, ZodIPv4: Pn, ZodIPv6: Vn, ZodISODate: Kn, ZodISODateTime: Yn, ZodISODuration: Jn, ZodISOTime: vn, ZodIntersection: Ya, ZodIssueCode: id, ZodJWT: er, ZodKSUID: Zn, ZodLazy: IE, ZodLiteral: Ha, ZodMap: va, ZodNaN: _a, ZodNanoID: xn, ZodNever: ka, ZodNonOptional: Qr, ZodNull: ya, ZodNullable: za, ZodNumber: yI, ZodNumberFormat: wg, ZodObject: kI, ZodOptional: Br, ZodPipe: sr, ZodPrefault: Ta, ZodPromise: nE, ZodReadonly: AE, ZodRealError: UA, ZodRecord: rr, ZodSet: Ja, ZodString: DI, ZodStringFormat: IA, ZodSuccess: Va, ZodSymbol: Da, ZodTemplateLiteral: gE, ZodTransform: xa, ZodTuple: Ka, ZodType: P, ZodULID: jn, ZodURL: fI, ZodUUID: Be, ZodUndefined: fa, ZodUnion: ir, ZodUnknown: Na, ZodVoid: Ga, ZodXID: Tn, _ZodString: Hn, _default: ja, _function: Eo, any: qw, array: Qt, base64: la, base64url: wa, bigint: Kw, boolean: mI, catch: Xa, check: Ad, cidrv4: ua, cidrv6: ha, clone: JA, codec: $a, coerce: ad, config: DA, core: lw, cuid: Qa, cuid2: sa, custom: ed, date: Sa, decode: $s, decodeAsync: ea, discriminatedUnion: ba, e164: kw, email: na, emoji: Ca, encode: _s, encodeAsync: Aa, endsWith: Sn, enum: MI, file: Vw, flattenError: Ri, float32: Rw, float64: bw, formatError: bi, function: Eo, getErrorMap: rd, globalRegistry: Ye, gt: Oe, gte: GA, guid: dw, hash: Uw, hex: Fw, hostname: Mw, httpUrl: pw, includes: kn, instanceof: gd, int: jt, int32: da, int64: vw, intersection: nr, ipv4: Ea, ipv6: ca, iso: Ts, json: BE, jwt: Gw, keyof: zw, ksuid: Nw, lazy: iE, length: dI, literal: La, locales: WQ, looseObject: Ow, lowercase: mn, lt: ze, lte: zA, map: Tw, maxLength: wI, maxSize: lI, mime: Mn, minLength: ag, minSize: zg, multipleOf: xg, nan: _w, nanoid: Ba, nativeEnum: Pw, negative: Ms, never: tr, nonnegative: Us, nonoptional: Pa, nonpositive: Fs, normalize: Fn, null: pa, nullable: Tt, nullish: Ww, number: Og, object: Fa, optional: ee, overwrite: We, parse: Ps, parseAsync: Vs, partialRecord: jw, pipe: Zt, positive: Ss, prefault: Za, preprocess: Id, prettifyError: RC, promise: $w, property: Rs, readonly: eE, record: or, refine: oE, regex: pn, regexes: ji, registry: en, safeDecode: ta, safeDecodeAsync: ia, safeEncode: ga, safeEncodeAsync: Ia, safeParse: Ws, safeParseAsync: Xs, set: Zw, setErrorMap: nd, size: yn, startsWith: Gn, strictObject: Ua, string: bA, stringFormat: Sw, stringbool: td, success: Xw, superRefine: CE, symbol: Hw, templateLiteral: tE, toJSONSchema: qs, toLowerCase: Rn, toUpperCase: bn, transform: Cr, treeifyError: FC, trim: Un, tuple: SI, uint32: Yw, uint64: Jw, ulid: aa, undefined: Lw, union: GI, unknown: Eg, uppercase: Nn, url: oa, util: SC, uuid: ra, uuidv4: Dw, uuidv6: fw, uuidv7: yw, void: xw, xid: mw }, Symbol.toStringTag, { value: "Module" })), Ed = new TextEncoder, cd = new TextDecoder; function cg(e) { e = e.replace(/=/g, ""); const A = e.length, g = A % 4, I = g && g - 1, t = (A >> 2) * 3 + I, i = new Uint8Array(A + 3); Ed.encodeInto(e + "===", i); for (let n = 0, r = 0; n < A; n += 4, r += 3) { const o = (ng[i[n]] << 18) + (ng[i[n + 1]] << 12) + (ng[i[n + 2]] << 6) + ng[i[n + 3]]; i[r] = o >> 16, i[r + 1] = o >> 8 & 255, i[r + 2] = o & 255 } return new Uint8Array(i.buffer, 0, t) } function ug(e) { const A = e.length, g = A % 3, I = Math.floor(A / 3) * 4 + (g && g + 1), t = Math.ceil(A / 3) * 4, i = new Uint8Array(t); for (let r = 0, o = 0; o < A; r += 4, o += 3) { const C = (e[o] << 16) + (e[o + 1] << 8) + (e[o + 2] | 0); i[r] = Ug[C >> 18], i[r + 1] = Ug[C >> 12 & 63], i[r + 2] = Ug[C >> 6 & 63], i[r + 3] = Ug[C & 63] } let n = cd.decode(new Uint8Array(i.buffer, 0, I)); return g === 1 && (n += "=="), g === 2 && (n += "="), n } const QE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", ng = new Uint8Array(128); for (const [e, A] of Array.from(QE).entries()) ng[A.charCodeAt(0)] = e; ng[61] = 0; const Ug = new Uint8Array(64); for (const [e, A] of Array.from(QE).entries()) Ug[e] = A.charCodeAt(0); var ud = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof global == "object" ? global : {}, Ke = "1.9.0", co = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/; function hd(e) { var A = new Set([e]), g = new Set, I = e.match(co); if (!I) return function () { return !1 }; var t = { major: +I[1], minor: +I[2], patch: +I[3], prerelease: I[4] }; if (t.prerelease != null) return function (o) { return o === e }; function i(r) { return g.add(r), !1 } function n(r) { return A.add(r), !0 } return function (o) { if (A.has(o)) return !0; if (g.has(o)) return !1; var C = o.match(co); if (!C) return i(o); var B = { major: +C[1], minor: +C[2], patch: +C[3], prerelease: C[4] }; return B.prerelease != null || t.major !== B.major ? i(o) : t.major === 0 ? t.minor === B.minor && t.patch <= B.patch ? n(o) : i(o) : t.minor <= B.minor ? n(o) : i(o) } } var ld = hd(Ke), wd = Ke.split(".")[0], Tg = Symbol.for("opentelemetry.js.api." + wd), Zg = ud; function sE(e, A, g, I) { var t; I === void 0 && (I = !1); var i = Zg[Tg] = (t = Zg[Tg]) !== null && t !== void 0 ? t : { version: Ke }; if (!I && i[e]) { var n = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + e); return g.error(n.stack || n.message), !1 } if (i.version !== Ke) { var n = new Error("@opentelemetry/api: Registration of version v" + i.version + " for " + e + " does not match previously registered API v" + Ke); return g.error(n.stack || n.message), !1 } return i[e] = A, g.debug("@opentelemetry/api: Registered a global for " + e + " v" + Ke + "."), !0 } function Pt(e) { var A, g, I = (A = Zg[Tg]) === null || A === void 0 ? void 0 : A.version; if (!(!I || !ld(I))) return (g = Zg[Tg]) === null || g === void 0 ? void 0 : g[e] } function aE(e, A) { A.debug("@opentelemetry/api: Unregistering a global for " + e + " v" + Ke + "."); var g = Zg[Tg]; g && delete g[e] } var dd = function (e, A) { var g = typeof Symbol == "function" && e[Symbol.iterator]; if (!g) return e; var I = g.call(e), t, i = [], n; try { for (; (A === void 0 || A-- > 0) && !(t = I.next()).done;)i.push(t.value) } catch (r) { n = { error: r } } finally { try { t && !t.done && (g = I.return) && g.call(I) } finally { if (n) throw n.error } } return i }, Dd = function (e, A, g) { if (g || arguments.length === 2) for (var I = 0, t = A.length, i; I < t; I++)(i || !(I in A)) && (i || (i = Array.prototype.slice.call(A, 0, I)), i[I] = A[I]); return e.concat(i || Array.prototype.slice.call(A)) }, fd = (function () { function e(A) { this._namespace = A.namespace || "DiagComponentLogger" } return e.prototype.debug = function () { for (var A = [], g = 0; g < arguments.length; g++)A[g] = arguments[g]; return pg("debug", this._namespace, A) }, e.prototype.error = function () { for (var A = [], g = 0; g < arguments.length; g++)A[g] = arguments[g]; return pg("error", this._namespace, A) }, e.prototype.info = function () { for (var A = [], g = 0; g < arguments.length; g++)A[g] = arguments[g]; return pg("info", this._namespace, A) }, e.prototype.warn = function () { for (var A = [], g = 0; g < arguments.length; g++)A[g] = arguments[g]; return pg("warn", this._namespace, A) }, e.prototype.verbose = function () { for (var A = [], g = 0; g < arguments.length; g++)A[g] = arguments[g]; return pg("verbose", this._namespace, A) }, e })(); function pg(e, A, g) { var I = Pt("diag"); if (I) return g.unshift(A), I[e].apply(I, Dd([], dd(g), !1)) } var NA; (function (e) { e[e.NONE = 0] = "NONE", e[e.ERROR = 30] = "ERROR", e[e.WARN = 50] = "WARN", e[e.INFO = 60] = "INFO", e[e.DEBUG = 70] = "DEBUG", e[e.VERBOSE = 80] = "VERBOSE", e[e.ALL = 9999] = "ALL" })(NA || (NA = {})); function yd(e, A) { e < NA.NONE ? e = NA.NONE : e > NA.ALL && (e = NA.ALL), A = A || {}; function g(I, t) { var i = A[I]; return typeof i == "function" && e >= t ? i.bind(A) : function () { } } return { error: g("error", NA.ERROR), warn: g("warn", NA.WARN), info: g("info", NA.INFO), debug: g("debug", NA.DEBUG), verbose: g("verbose", NA.VERBOSE) } } var pd = function (e, A) { var g = typeof Symbol == "function" && e[Symbol.iterator]; if (!g) return e; var I = g.call(e), t, i = [], n; try { for (; (A === void 0 || A-- > 0) && !(t = I.next()).done;)i.push(t.value) } catch (r) { n = { error: r } } finally { try { t && !t.done && (g = I.return) && g.call(I) } finally { if (n) throw n.error } } return i }, md = function (e, A, g) { if (g || arguments.length === 2) for (var I = 0, t = A.length, i; I < t; I++)(i || !(I in A)) && (i || (i = Array.prototype.slice.call(A, 0, I)), i[I] = A[I]); return e.concat(i || Array.prototype.slice.call(A)) }, Nd = "diag", uo = (function () { function e() { function A(t) { return function () { for (var i = [], n = 0; n < arguments.length; n++)i[n] = arguments[n]; var r = Pt("diag"); if (r) return r[t].apply(r, md([], pd(i), !1)) } } var g = this, I = function (t, i) { var n, r, o; if (i === void 0 && (i = { logLevel: NA.INFO }), t === g) { var C = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation"); return g.error((n = C.stack) !== null && n !== void 0 ? n : C.message), !1 } typeof i == "number" && (i = { logLevel: i }); var B = Pt("diag"), Q = yd((r = i.logLevel) !== null && r !== void 0 ? r : NA.INFO, t); if (B && !i.suppressOverrideMessage) { var s = (o = new Error().stack) !== null && o !== void 0 ? o : "<failed to generate stacktrace>"; B.warn("Current logger will be overwritten from " + s), Q.warn("Current logger will overwrite one already registered from " + s) } return sE("diag", Q, g, !0) }; g.setLogger = I, g.disable = function () { aE(Nd, g) }, g.createComponentLogger = function (t) { return new fd(t) }, g.verbose = A("verbose"), g.debug = A("debug"), g.info = A("info"), g.warn = A("warn"), g.error = A("error") } return e.instance = function () { return this._instance || (this._instance = new e), this._instance }, e })(), Xe = (function () { var e = function (A, g) { return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (I, t) { I.__proto__ = t } || function (I, t) { for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (I[i] = t[i]) }, e(A, g) }; return function (A, g) { if (typeof g != "function" && g !== null) throw new TypeError("Class extends value " + String(g) + " is not a constructor or null"); e(A, g); function I() { this.constructor = A } A.prototype = g === null ? Object.create(g) : (I.prototype = g.prototype, new I) } })(), kd = (function () { function e() { } return e.prototype.createGauge = function (A, g) { return vd }, e.prototype.createHistogram = function (A, g) { return Jd }, e.prototype.createCounter = function (A, g) { return Kd }, e.prototype.createUpDownCounter = function (A, g) { return Hd }, e.prototype.createObservableGauge = function (A, g) { return qd }, e.prototype.createObservableCounter = function (A, g) { return Ld }, e.prototype.createObservableUpDownCounter = function (A, g) { return xd }, e.prototype.addBatchObservableCallback = function (A, g) { }, e.prototype.removeBatchObservableCallback = function (A) { }, e })(), UI = (function () { function e() { } return e })(), Gd = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A.prototype.add = function (g, I) { }, A })(UI), Sd = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A.prototype.add = function (g, I) { }, A })(UI), Md = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A.prototype.record = function (g, I) { }, A })(UI), Fd = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A.prototype.record = function (g, I) { }, A })(UI), Er = (function () { function e() { } return e.prototype.addCallback = function (A) { }, e.prototype.removeCallback = function (A) { }, e })(), Ud = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A })(Er), Rd = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A })(Er), bd = (function (e) { Xe(A, e); function A() { return e !== null && e.apply(this, arguments) || this } return A })(Er), Yd = new kd, Kd = new Gd, vd = new Md, Jd = new Fd, Hd = new Sd, Ld = new Ud, qd = new Rd, xd = new bd, jA; (function (e) { e[e.INT = 0] = "INT", e[e.DOUBLE = 1] = "DOUBLE" })(jA || (jA = {})); var zd = (function () { function e() { } return e.prototype.getMeter = function (A, g, I) { return Yd }, e })(), Od = new zd, qI = "metrics", jd = (function () { function e() { } return e.getInstance = function () { return this._instance || (this._instance = new e), this._instance }, e.prototype.setGlobalMeterProvider = function (A) { return sE(qI, A, uo.instance()) }, e.prototype.getMeterProvider = function () { return Pt(qI) || Od }, e.prototype.getMeter = function (A, g, I) { return this.getMeterProvider().getMeter(A, g, I) }, e.prototype.disable = function () { aE(qI, uo.instance()) }, e })(), se = jd.getInstance(); const je = { MAX_RECOMMENDED_TX_SIZE: 100 * 1024, MAX_TX_SIZE_BYTES: 1 * 1024 * 1024 }; function Td(e) { je.MAX_RECOMMENDED_TX_SIZE = e } const Pg = { MAX_RETRIES: 1, TIMEOUT: 3e4, RETRY_DELAY: 3e3 }; function Zd(e) { Pg.RETRY_DELAY = e } const EE = { INCOMING_MESSAGES_TIME_BUDGET: 50 }; function Pd(e) { EE.INCOMING_MESSAGES_TIME_BUDGET = e } const ho = { MAX_AGE: 1e3 * 60 * 10, INTERVAL: 1e3 * 60 * 5 }; function Te(e) { return { id: e, header: !1, sessions: {} } } function xI(e) { return { id: e.id, header: e.header, sessions: e.sessions } } function zI(e, A) { return Vg(e.sessions, A.sessions), A.header && !e.header && (e.header = !0), e } function Vg(e, A) { for (const [g, I] of Object.entries(A)) { const t = e[g] || 0; I > t && (e[g] = I) } return e } function OI(e, A, g) { e[A] = g } function lo(e, A, g) { e[A] = Math.max(e[A] || 0, g) } function ig(e) { return { id: e.id, header: e.header, sessions: { ...e.sessions } } } function cE(e, A) { for (const [g, I] of Object.entries(e)) { const t = A[g] ?? 0; if (I !== t) return !1 } return !0 } function wo(e, A) { for (const [g, I] of Object.entries(e)) { const t = A[g] ?? 0; if (I > t) return !1 } return !0 } function uE(e, A) { const g = {}; for (const [I, t] of Object.entries(e)) { const i = A[I] ?? 0; t > i && (g[I] = t) } return g } const RA = { HIGH: 0, MEDIUM: 3, LOW: 6 }; function hE(e) { return typeof e == "boolean" || !e ? RA.MEDIUM : e.meta?.type === "account" || e.ruleset.type === "group" ? RA.HIGH : e.type === "costream" && e.meta?.type === "binary" ? RA.LOW : RA.MEDIUM } function Lg(e, A, g = !0) { return { action: "content", id: e, header: g ? A : void 0, priority: hE(A), new: {} } } function jI(e, A, g, I, t) { const i = e.new[g]; i ? (i.newTransactions.push(A), i.lastSignature = I) : e.new[g] = { after: t, newTransactions: [A], lastSignature: I } } function st(e) { return e.privacy === "private" ? e.encryptedChanges.length : e.changes.length } function Vt(e, A) { return A === void 0 ? e > je.MAX_RECOMMENDED_TX_SIZE : e + A > je.MAX_RECOMMENDED_TX_SIZE } const Vd = new TextEncoder; function Wd(e) { const A = Vd.encode(JSON.stringify(e)).length; if (A > je.MAX_TX_SIZE_BYTES) throw new Error(`Transaction is too large to be synced: ${A} > ${je.MAX_TX_SIZE_BYTES} bytes. Consider breaking your transaction into smaller chunks.`) } function TI(e) { const A = Te(e.id); A.header = !!e.header; for (const [g, I] of Object.entries(e.new)) A.sessions[g] = I.after + I.newTransactions.length; return A } function Xd(e) { return Object.values(e.new).reduce((A, g) => A + g.newTransactions.reduce((I, t) => I + st(t), 0), 0) } function ZI(e) { return Object.entries(e.new).map(([A, g]) => `Session: ${A} After: ${g.after} New: ${g.newTransactions.length}`) } function _d(e, A, g) { const I = A.sessions[g] ?? 0, t = e.after; if (I < t) return; const i = I - t; return e.newTransactions.slice(i) } function $d(e) { return Object.entries(e.new) } class AD { constructor(A) { this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A } get type() { return this.core.verified.header.type } get headerMeta() { return this.core.verified.header.meta } get group() { return this.core.getGroup() } toJSON() { return {} } atTime() { return this } subscribe(A) { return this.core.subscribe(g => { A(g.getCurrentContent()) }) } processNewTransactions() { } rebuildFromCore() { } } const mg = { DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3 }; class eD { debug(A, g) { console.debug(A, g) } info(A, g) { console.info(A, g) } warn(A, g) { console.warn(A, g) } error(A, g) { console.error(A, g) } } class gD { constructor(A = mg.INFO, g = new eD) { this.level = A, this.logSystem = g } setLevel(A) { this.level = A } setLogSystem(A) { this.logSystem = A } debug(A, g) { this.level <= mg.DEBUG && this.logSystem.debug(A, g) } info(A, g) { this.level <= mg.INFO && this.logSystem.info(A, g) } warn(A, g) { this.level <= mg.WARN && this.logSystem.warn(A, g) } error(A, g) { this.level <= mg.ERROR && this.logSystem.error(A, g) } } const x = new gD; function YA(e) { const A = e.indexOf("_session"); return e.slice(0, A) } class cr { resetInternalState() { this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this._cachedEntries = void 0, this.knownTransactions = { [this.core.id]: 0 }, this.lastValidTransaction = void 0, this.totalValidTransactions = 0 } constructor(A) { this.type = "colist", this.afterStart = [], this.beforeEnd = [], this.insertions = {}, this.deletionsByInsertion = {}, this.knownTransactions = {}, this.version = 0, this.totalValidTransactions = 0, this.id = A.id, this.core = A, this.processNewTransactions() } getInsertionsEntry(A) { const g = yt(A), I = this.insertions[g]; if (!I) return; const t = I[A.txIndex]; if (t) return t[A.changeIdx] } createInsertionsEntry(A, g) { const I = yt(A); let t = this.insertions[I]; t || (t = {}, this.insertions[I] = t); let i = t[A.txIndex]; return i || (i = {}, t[A.txIndex] = i), i[A.changeIdx] ? !1 : (i[A.changeIdx] = g, !0) } isDeleted(A) { const g = yt(A), I = this.deletionsByInsertion[g]; if (!I) return !1; const t = I[A.txIndex]; return t ? !!t[A.changeIdx]?.length : !1 } pushDeletionsByInsertionEntry(A, g) { const I = yt(A); let t = this.deletionsByInsertion[I]; t || (t = {}, this.deletionsByInsertion[I] = t); let i = t[A.txIndex]; i || (i = {}, t[A.txIndex] = i); let n = i[A.changeIdx]; n || (n = [], i[A.changeIdx] = n), n.push(g) } processNewTransactions() { const A = this.core.getValidSortedTransactions({ ignorePrivateTransactions: !1, knownTransactions: this.knownTransactions }); if (A.length === 0) return; let g, I; this._cachedEntries = void 0; for (const { txID: t, changes: i, madeAt: n } of A) { g = Math.max(g ?? 0, n), I = Math.min(I ?? 1 / 0, n); for (const [r, o] of i.entries()) { const C = o, B = { sessionID: t.sessionID, txIndex: t.txIndex, branch: t.branch, changeIdx: r }; if (C.op === "pre" || C.op === "app") { if (!this.createInsertionsEntry(B, { madeAt: n, predecessors: [], successors: [], change: C })) continue; if (C.op === "pre") if (C.before === "end") this.beforeEnd.push(B); else { const s = this.getInsertionsEntry(C.before); if (!s) continue; s.predecessors.push(B) } else if (C.after === "start") this.afterStart.push(B); else { const s = this.getInsertionsEntry(C.after); if (!s) continue; s.successors.push(B) } } else if (C.op === "del") this.pushDeletionsByInsertionEntry(C.insertion, { madeAt: n, deletionID: B, change: C }); else throw new Error("Unknown list operation " + C.op) } } this.lastValidTransaction && I && I < this.lastValidTransaction ? this.rebuildFromCore() : this.lastValidTransaction = g, this.totalValidTransactions += A.length } rebuildFromCore() { this.version += 1, this.resetInternalState(), this.processNewTransactions() } get headerMeta() { return this.core.verified.header.meta } get group() { return this.core.getGroup() } atTime(A) { throw new Error("Not yet implemented") } get(A) { const g = this.entries()[A]; if (g) return g.value } asArray() { return this.entries().map(A => A.value) } entries() { if (this._cachedEntries) return this._cachedEntries; const A = this.entriesUncached(); return this._cachedEntries = A, A } entriesUncached() { const A = []; for (const g of this.afterStart) this.fillArrayFromOpID(g, A); for (const g of this.beforeEnd) this.fillArrayFromOpID(g, A); return A } fillArrayFromOpID(A, g) { const I = [A], t = new Set; for (; I.length > 0;) { const i = I[I.length - 1], n = this.getInsertionsEntry(i); if (!n) throw new Error("Missing op " + i); if (n.predecessors.length > 0 && !t.has(i)) { for (const o of n.predecessors) I.push(o); t.add(i) } else { I.pop(), this.isDeleted(i) || g.push({ value: n.change.value, madeAt: n.madeAt, opID: i }); for (const C of n.successors) I.push(C) } } } toJSON() { return this.asArray() } editAt(A) { const g = this.entries()[A]; if (!g) return; const I = new Date(g.madeAt), t = YA(g.opID.sessionID), i = g.value; return { by: t, tx: { sessionID: g.opID.sessionID, txIndex: g.opID.txIndex }, at: I, value: i } } deletionEdits() { const A = []; for (const g in this.deletionsByInsertion) { const I = this.deletionsByInsertion[g]; for (const t in I) { const i = I[Number(t)]; for (const n in i) { const r = i[Number(n)]; for (const o of r || []) { const C = new Date(o.madeAt), B = YA(o.deletionID.sessionID); A.push({ by: B, tx: o.deletionID, at: C }) } } } } return A } subscribe(A) { return this.core.subscribe(g => { A(g.getCurrentContent()) }) } append(A, g, I = "private") { this.appendItems([A], g, I) } appendItems(A, g, I = "private") { const t = this.entries(); g = g === void 0 ? t.length > 0 ? t.length - 1 : 0 : Math.max(0, g); let i; if (t.length > 0) { const r = t[g]; if (!r) throw new Error("Invalid index " + g); i = r.opID } else { if (g !== 0) throw new Error("Invalid index " + g); i = "start" } const n = A.map(r => ({ op: "app", value: og(r) ? r.id : r, after: i })); i !== "start" && n.reverse(), this.core.makeTransaction(n, I), this.processNewTransactions() } prepend(A, g, I = "private") { const t = this.entries(); g = g === void 0 ? 0 : g; let i; if (t.length > 0) { const n = t[g]; if (n) i = n.opID; else { if (g !== t.length) throw new Error("Invalid index " + g); i = "end" } } else { if (g !== 0) throw new Error("Invalid index " + g); i = "end" } this.core.makeTransaction([{ op: "pre", value: og(A) ? A.id : A, before: i }], I), this.processNewTransactions() } delete(A, g = "private") { const t = this.entries()[A]; if (!t) throw new Error("Invalid index " + A); this.core.makeTransaction([{ op: "del", insertion: t.opID }], g), this.processNewTransactions() } replace(A, g, I = "private") { const i = this.entries()[A]; if (!i) throw new Error("Invalid index " + A); this.core.makeTransaction([{ op: "app", value: og(g) ? g.id : g, after: i.opID }, { op: "del", insertion: i.opID }], I), this.processNewTransactions() } } function yt(e) { return e.branch ? `${e.sessionID}_branch_${e.branch}` : e.sessionID } function RI(e) { return e.startsWith("co_") } class lE { resetInternalState() { this.items = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0 } constructor(A) { this.type = "costream", this.totalValidTransactions = 0, this.version = 0, this.id = A.id, this.core = A, this.items = {}, this.knownTransactions = { [A.id]: 0 }, this.processNewTransactions() } rebuildFromCore() { this.version++, this.resetInternalState(), this.processNewTransactions() } get headerMeta() { return this.core.verified.header.meta } get group() { return this.core.getGroup() } atTime(A) { throw new Error("Not yet implemented") } compareStreamItems(A, g) { return A.madeAt - g.madeAt || (A.tx.sessionID === g.tx.sessionID ? 0 : A.tx.sessionID < g.tx.sessionID ? -1 : 1) || A.tx.txIndex - g.tx.txIndex } processNewTransactions() { const A = new Set, g = this.core.getValidTransactions({ ignorePrivateTransactions: !1, knownTransactions: this.knownTransactions }); if (g.length !== 0) { for (const { txID: I, madeAt: t, changes: i } of g) for (const n of i) { const r = n; let o = this.items[I.sessionID]; o || (o = [], this.items[I.sessionID] = o), o.push({ value: r, madeAt: t, tx: I }), A.add(o) } for (const I of A) I.sort(this.compareStreamItems); this.totalValidTransactions += g.length } } getSingleStream() { const A = Object.values(this.items), g = A[0]; if (g) { if (A.length > 1) throw new Error("CoStream.getSingleStream() can only be called when there is exactly one stream"); return g.map(I => I.value) } } sessions() { return Object.keys(this.items) } accounts() { return new Set(this.sessions().map(YA).filter(RI)) } nthItemIn(A, g) { const I = this.items[A]; if (!I) return; const t = I[g]; if (t) return { by: YA(A), tx: t.tx, at: new Date(t.madeAt), value: t.value } } lastItemIn(A) { const g = this.items[A]; if (g) return this.nthItemIn(A, g.length - 1) } *itemsIn(A) { const g = this.items[A]; if (g) for (const I of g) yield { by: YA(A), tx: I.tx, at: new Date(I.madeAt), value: I.value } } lastItemBy(A) { let g; for (const I of Object.keys(this.items)) if (I.startsWith(A)) { const t = this.lastItemIn(I); if (!t) continue; (!g || t.at > g.at) && (g = { by: t.by, tx: t.tx, at: t.at, value: t.value }) } return g } *itemsBy(A) { const g = [...Object.keys(this.items).flatMap(I => I.startsWith(A) ? [...this.itemsIn(I)].map(t => ({ in: I, ...t })) : [])]; g.sort((I, t) => I.at.getTime() - t.at.getTime()); for (const I of g) yield I } toJSON() { return Object.fromEntries(Object.entries(this.items).map(([A, g]) => [A, g.map(I => I.value)])) } subscribe(A) { return this.core.subscribe(g => { A(g.getCurrentContent()) }) } } class wE extends lE { push(A, g = "private") { this.core.makeTransaction([og(A) ? A.id : A], g), this.processNewTransactions() } } const tD = 8; class ID extends lE { isBinaryStreamEnded() { const A = this.getSingleStream(); return !A || A.length === 0 ? !1 : A[A.length - 1]?.type === "end" } getBinaryStreamInfo() { const A = this.getSingleStream(); if (!A) return; const g = A[0]; if (g?.type !== "start") { x.error("Invalid binary stream start", g); return } return { mimeType: g.mimeType, fileName: g.fileName, totalSizeBytes: g.totalSizeBytes } } getBinaryChunks(A) { const g = this.getSingleStream(); if (!g) return; const I = this.getBinaryStreamInfo(); if (!I || g[g.length - 1]?.type !== "end" && !A) return; const i = []; let n = !1; for (const r of g.slice(1)) { if (r.type === "end") { n = !0; break } if (r.type !== "chunk") { x.error("Invalid binary stream chunk", r); return } const o = cg(r.chunk.slice(tD)); i.push(o) } return { ...I, chunks: i, finished: n } } } class dE extends ID { push(A, g = "private", I = !0) { this.core.makeTransaction([A], g), I && this.processNewTransactions() } startBinaryStream(A, g = "private") { this.push({ type: "start", ...A }, g, !1) } pushBinaryStreamChunk(A, g = "private") { this.push({ type: "chunk", chunk: `binary_U${ug(A)}` }, g, !1) } endBinaryStream(A = "private") { this.push({ type: "end" }, A, !0) } } function og(e) { return e instanceof ur || e instanceof cr || e instanceof wE || e instanceof dE } class ur { get latestTxMadeAt() { return this.core.latestTxMadeAt } get earliestTxMadeAt() { return this.core.earliestTxMadeAt } resetInternalState() { this.ops = {}, this.latest = {}, this.knownTransactions = { [this.core.id]: 0 }, this.totalValidTransactions = 0 } constructor(A, g) { this.type = "comap", this.ops = {}, this.latest = {}, this.knownTransactions = {}, this.totalValidTransactions = 0, this.version = 0, this.atTimeFilter = void 0, this.id = A.id, this.core = A, this.ignorePrivateTransactions = g?.ignorePrivateTransactions ?? !1, this.processNewTransactions() } processNewTransactions() { if (this.isTimeTravelEntity()) throw new Error("Cannot process transactions on a time travel entity"); const A = this.core.getValidTransactions({ ignorePrivateTransactions: this.ignorePrivateTransactions, knownTransactions: this.knownTransactions }); if (A.length === 0) return; const { ops: g } = this, I = new Map; for (const { txID: t, changes: i, madeAt: n, tx: r } of A) for (let o = 0; o < i.length; o++) { const C = i[o], B = { txID: t, madeAt: n, changeIdx: o, change: C, trusting: r.privacy === "trusting" }, Q = g[C.key]; if (Q) Q.push(B), I.set(C.key, Q); else { const s = [B]; g[C.key] = s, I.set(C.key, s) } } for (const t of I.values()) t.sort(this.core.compareTransactions); for (const [t, i] of I.entries()) this.latest[t] = i[i.length - 1]; this.totalValidTransactions += A.length } rebuildFromCore() { this.version += 1, this.resetInternalState(), this.processNewTransactions() } isTimeTravelEntity() { return !!this.atTimeFilter } get headerMeta() { return this.core.verified.header.meta } get group() { return this.core.getGroup() } atTime(A) { if (A >= this.latestTxMadeAt) return this; { const g = Object.create(this); return g.atTimeFilter = A, g.latest = {}, g } } timeFilteredOps(A) { if (A === "constructor") return; const g = this.atTimeFilter; return g ? this.ops[A]?.filter(I => I.madeAt <= g) : this.ops[A] } keys() { return Object.keys(this.ops).filter(A => { const g = this.getRaw(A); return !(g === void 0 || g.change.op === "del") }) } getRaw(A) { let g = this.latest[A]; if (g === void 0) { const I = this.ops[A]; if (I && !(A in this.latest)) { const t = this.atTimeFilter; t ? g = I.findLast(i => i.madeAt <= t) : g = I[I.length - 1], this.latest[A] = g } if (g === void 0) return } return g } get(A) { const g = this.getRaw(A); if (g?.change !== void 0 && g.change.op !== "del") return g.change.value } asObject() { const A = {}; for (const g of Object.keys(this.ops)) { const I = this.get(g); I !== void 0 && (A[g] = I) } return A } toJSON() { return this.asObject() } nthEditAt(A, g) { const I = this.ops[A], t = this.atTimeFilter, i = I?.[g]; if (i && !(t && i.madeAt > t)) return PI(i) } lastEditAt(A) { const g = this.getRaw(A); if (g) return PI(g) } *editsAt(A) { const g = this.ops[A]; if (!g) return; const I = this.atTimeFilter; for (const t of g) { if (I && t.madeAt > I) return; yield PI(t) } } subscribe(A) { return this.core.subscribe(g => { A(g.getCurrentContent()) }) } set(A, g, I = "private") { if (this.isTimeTravelEntity()) throw new Error("Cannot set value on a time travel entity"); this.core.makeTransaction([{ op: "set", key: A, value: og(g) ? g.id : g }], I), this.processNewTransactions() } assign(A, g = "private") { if (this.isTimeTravelEntity()) throw new Error("Cannot set value on a time travel entity"); this.core.makeTransaction(Object.entries(A).map(([I, t]) => ({ op: "set", key: I, value: og(t) ? t.id : t })), g), this.processNewTransactions() } delete(A, g = "private") { if (this.isTimeTravelEntity()) throw new Error("Cannot delete value on a time travel entity"); this.core.makeTransaction([{ op: "del", key: A }], g), this.processNewTransactions() } } function PI(e) { return { by: YA(e.txID.sessionID), tx: e.txID, at: new Date(e.madeAt), value: e.change.op === "del" ? void 0 : e.change.value } } function iD(e) { return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array" } function DE(e, A) { return Array.isArray(A) ? A.length === 0 ? !0 : e ? A.every(g => typeof g == "string") : A.every(g => Number.isSafeInteger(g)) : !1 } function ai(e, A) { if (typeof A != "string") throw new Error(`${e}: string expected`); return !0 } function fE(e) { if (!Number.isSafeInteger(e)) throw new Error(`invalid integer: ${e}`) } function Ei(e) { if (!Array.isArray(e)) throw new Error("array expected") } function yE(e, A) { if (!DE(!0, A)) throw new Error(`${e}: array of strings expected`) } function nD(e, A) { if (!DE(!1, A)) throw new Error(`${e}: array of numbers expected`) } function rD(...e) { const A = i => i, g = (i, n) => r => i(n(r)), I = e.map(i => i.encode).reduceRight(g, A), t = e.map(i => i.decode).reduce(g, A); return { encode: I, decode: t } } function oD(e) { const A = typeof e == "string" ? e.split("") : e, g = A.length; yE("alphabet", A); const I = new Map(A.map((t, i) => [t, i])); return { encode: t => (Ei(t), t.map(i => { if (!Number.isSafeInteger(i) || i < 0 || i >= g) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${e}`); return A[i] })), decode: t => (Ei(t), t.map(i => { ai("alphabet.decode", i); const n = I.get(i); if (n === void 0) throw new Error(`Unknown letter: "${i}". Allowed: ${e}`); return n })) } } function CD(e = "") { return ai("join", e), { encode: A => (yE("join.decode", A), A.join(e)), decode: A => (ai("join.decode", A), A.split(e)) } } function Do(e, A, g) { if (A < 2) throw new Error(`convertRadix: invalid from=${A}, base cannot be less than 2`); if (g < 2) throw new Error(`convertRadix: invalid to=${g}, base cannot be less than 2`); if (Ei(e), !e.length) return []; let I = 0; const t = [], i = Array.from(e, r => { if (fE(r), r < 0 || r >= A) throw new Error(`invalid integer: ${r}`); return r }), n = i.length; for (; ;) { let r = 0, o = !0; for (let C = I; C < n; C++) { const B = i[C], Q = A * r, s = Q + B; if (!Number.isSafeInteger(s) || Q / A !== r || s - B !== Q) throw new Error("convertRadix: carry overflow"); const E = s / g; r = s % g; const a = Math.floor(E); if (i[C] = a, !Number.isSafeInteger(a) || a * g + r !== s) throw new Error("convertRadix: carry overflow"); if (o) a ? o = !1 : I = C; else continue } if (t.push(r), o) break } for (let r = 0; r < e.length - 1 && e[r] === 0; r++)t.push(0); return t.reverse() } function BD(e) { fE(e); const A = 2 ** 8; return { encode: g => { if (!iD(g)) throw new Error("radix.encode input should be Uint8Array"); return Do(Array.from(g), A, e) }, decode: g => (nD("radix.decode", g), Uint8Array.from(Do(g, e, A))) } } const QD = e => rD(BD(58), oD(e), CD("")), _ = QD("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"); function $(e) { const A = []; let g = e; if (g && g.toJSON && typeof g.toJSON == "function" && (g = g.toJSON()), g === void 0) return; if (typeof g == "number") return isFinite(g) ? "" + g : "null"; if (typeof g != "object") return typeof g == "string" && (g.startsWith("encrypted_U") || g.startsWith("binary_U")) ? `"${g}"` : JSON.stringify(g); let I, t; if (Array.isArray(g)) { for (t = "[", I = 0; I < g.length; I++)I && (t += ","), t += $(g[I]) || "null"; return t + "]" } if (g === null) return "null"; if (A.indexOf(g) !== -1) throw new TypeError("Converting circular structure to JSON"); const i = A.push(g) - 1, n = Object.keys(g).sort(); for (t = "", I = 0; I < n.length; I++) { const r = n[I], o = $(g[r]); o && (t && (t += ","), t += JSON.stringify(r) + ":" + o) } return A.splice(i, 1), "{" + t + "}" } function Wg(e) { return JSON.parse(e) } function fo(e) { try { return JSON.parse(e) } catch { return } } function sD(e = 32) { return crypto.getRandomValues(new Uint8Array(e)) } const gA = new TextEncoder, Xg = new TextDecoder; class pE { constructor() { this.agentIdCache = new Map } randomBytes(A) { return sD(A) } newRandomSigner() { return `signerSecret_z${_.encode(this.newEd25519SigningKey())}` } newRandomSealer() { return `sealerSecret_z${_.encode(this.newX25519StaticSecret())}` } newRandomAgentSecret() { return `${this.newRandomSealer()}/${this.newRandomSigner()}` } getAgentID(A) { const g = A; let I = this.agentIdCache.get(g); if (!I) { const [t, i] = A.split("/"); I = `${this.getSealerID(t)}/${this.getSignerID(i)}`, this.agentIdCache.set(g, I) } return I } getAgentSignerID(A) { return A.split("/")[1] } getAgentSignerSecret(A) { return A.split("/")[1] } getAgentSealerID(A) { return A.split("/")[0] } getAgentSealerSecret(A) { return A.split("/")[0] } secureHash(A) { return `hash_z${_.encode(this.blake3HashOnce(gA.encode($(A))))}` } shortHash(A) { return `shortHash_z${_.encode(this.blake3HashOnce(gA.encode($(A))).slice(0, hr))}` } decrypt(A, g, I) { try { return Wg(this.decryptRaw(A, g, I)) } catch (t) { x.error("Decryption error", { err: t }); return } } newRandomKeySecret() { return { secret: `keySecret_z${_.encode(this.randomBytes(32))}`, id: `key_z${_.encode(this.randomBytes(12))}` } } encryptKeySecret(A) { const g = { encryptedID: A.toEncrypt.id, encryptingID: A.encrypting.id }; return { encryptedID: A.toEncrypt.id, encryptingID: A.encrypting.id, encrypted: this.encrypt(A.toEncrypt.secret, A.encrypting.secret, g) } } decryptKeySecret(A, g) { const I = { encryptedID: A.encryptedID, encryptingID: A.encryptingID }; return this.decrypt(A.encrypted, g, I) } uniquenessForHeader() { return `z${_.encode(this.randomBytes(12))}` } createdNowUnique() { return { createdAt: new Date().toISOString(), uniqueness: this.uniquenessForHeader() } } newRandomSecretSeed() { return this.randomBytes(Rt) } agentSecretFromSecretSeed(A) { if (A.length !== Rt) throw new Error(`Secret seed needs to be ${Rt} bytes long`); return `sealerSecret_z${_.encode(this.blake3HashOnceWithContext(A, { context: gA.encode("seal") }))}/signerSecret_z${_.encode(this.blake3HashOnceWithContext(A, { context: gA.encode("sign") }))}` } newRandomSessionID(A) { return `${A}_session_z${_.encode(this.randomBytes(8))}` } } const hr = 19, Rt = 32; function aD(e) { return typeof e == "string" && e.startsWith("co_z") } function ED(e) { return _.decode(e.substring(4)) } function cD(e) { return `co_z${_.encode(e.slice(0, hr))}` } function bt(e) { return typeof e == "string" && e.startsWith("sealer_") && e.includes("/signer_") } function Yt(e) { return e.startsWith("parent_") } function Wt(e) { return e.slice(7) } function lr(e) { if (typeof e == "string") { if (Yt(e)) return Wt(e); if (e.startsWith("co_")) return e } } function uD(e) { const A = []; for (const g of e) { const I = lr(g); I && A.push(I) } return A } function wA(e) { if (e.type !== "comap") throw new Error("Expected group"); if (e.core.verified.header.ruleset.type !== "group") throw new Error("Expected group ruleset in group"); if (!(e instanceof wr)) throw new Error("Expected group"); return e } function Xt(e) { return e === "manager" || e === "admin" || e === "writer" || e === "reader" || e === "writeOnly" } function Ng(e) { return e === "admin" || e === "manager" } function hD(e) { if (!e.isAvailable()) throw new Error("determineValidTransactions CoValue is not available"); if (e.verified.header.ruleset.type === "group") { const A = e.verified.header.ruleset.initialAdmin; if (!A) throw new Error("Group must have initialAdmin"); dD(e, A); return } if (e.verified.header.ruleset.type === "ownedByGroup") { const A = wA(e.node.expectCoValueLoaded(e.verified.header.ruleset.group, "Determining valid transaction in owned object but its group wasn't loaded").getCurrentContent()); if (A.type !== "comap") throw new Error("Group must be a map"); for (const g of e.toValidateTransactions) { const I = A.atTime(g.currentMadeAt), t = DD(g.author, I); if (!t) { g.markInvalid("Transactor not found in group", { transactor: g.author, group: I.toJSON() }); continue } const i = I.roleOfInternal(t); if (i === "reader" && g.meta?.branch && g.meta?.ownerId) { g.meta = { branch: g.meta.branch, ownerId: g.meta.ownerId }, g.changes = [], g.markValid(); continue } if (i !== "admin" && i !== "manager" && i !== "writer" && i !== "writeOnly") { g.markInvalid("Transactor has no write permissions", { transactor: g.author, transactorRole: i ?? "undefined" }); continue } g.markValid() } return } if (e.verified.header.ruleset.type === "unsafeAllowAll") { for (const A of e.toValidateTransactions) A.markValid(); return } throw new Error("Unknown ruleset type " + e.verified.header.ruleset.type) } function lD(e, A) { return e === void 0 || e === "revoked" ? !1 : A === void 0 || A === "revoked" ? !0 : A === "admin" ? !1 : e === "admin" ? !0 : A === "manager" ? !1 : e === "manager" ? !0 : e === "writer" && A === "reader" } class wD { constructor() { this.parentGroups = new Map, this.memberRoles = new Map } setDirectRole(A, g) { this.memberRoles.set(A, g) } removeMember(A) { this.memberRoles.delete(A) } addParentGroup(A, g) { this.parentGroups.set(A, g) } removeParentGroup(A) { this.parentGroups.delete(A) } getDirectRole(A) { return this.memberRoles.get(A) } getRoleAtTime(A, g) { let I = this.memberRoles.get(A); for (const [t, i] of this.parentGroups.entries()) { const n = t.atTime(g).roleOfInternal(A); if (!n || !mE(n)) continue; const r = i === "extend" ? n : i; lD(r, I) && (I = r) } return I } } function dD(e, A) { e.verifiedTransactions.sort(e.compareTransactions); const g = {}, I = new Set, t = new wD; for (const i of e.verifiedTransactions) { let E = function (c) { if (c.op !== "set") throw new Error("Expected set operation"); t.setDirectRole(c.key, c.value), i.markValid() }; const n = i.author, r = t.getRoleAtTime(n, i.currentMadeAt); if (i.tx.privacy === "private") if (r === "admin") { i.markValid(); continue } else { i.markInvalid("Only admins can make private transactions in groups"); continue } const C = i.changes; if (!C) continue; const B = C[0]; if (C.length !== 1) { i.markInvalid("Group transaction must have exactly one change"); continue } if (B.op !== "set") { i.markInvalid("Group transaction must set a role or readKey"); continue } if (B.key === "readKey") { if (!Ng(r)) { i.markInvalid("Only admins can set readKeys"); continue } i.markValid(); continue } else if (B.key === "profile") { if (!Ng(r)) { i.markInvalid("Only admins can set profile"); continue } i.markValid(); continue } else if (B.key === "root") { if (!Ng(r)) { i.markInvalid("Only admins can set root"); continue } i.markValid(); continue } else if (ci(B.key) || pD(B.key)) { if (r !== "admin" && r !== "adminInvite" && r !== "manager" && r !== "managerInvite" && r !== "writerInvite" && r !== "readerInvite" && r !== "writeOnlyInvite" && !kD(B.key, n, g)) { i.markInvalid("Only admins and managers can reveal keys"); continue } i.markValid(); continue } else if (mD(B.key)) { if (!Ng(r)) { i.markInvalid("Only admins and managers can set parent extensions"); continue } const c = Wt(B.key), u = e.node.expectCoValueLoaded(c, "Expected parent group to be loaded"); if (!u.isGroup()) { i.markInvalid("Parent group is not a group"); continue } const h = wA(u.getCurrentContent()); if (NE(e, h)) { i.markInvalid("Parent group is a circular dependency"); continue } const d = B.value; d === "revoked" ? t.removeParentGroup(h) : t.addParentGroup(h, d), i.markValid(); continue } else if (ND(B.key)) { i.markInvalid("Child extensions are not allowed anymore"); continue } else if (fD(B.key)) { const c = yD(B.key); if (r !== "admin" && r !== "manager" && r !== "writeOnlyInvite" && c !== n) { i.markInvalid("Only admins and managers can set writeKeys"); continue } if (g[c] = B.value, I.has(B.key) && !Ng(r)) { i.markInvalid("Write key already exists and can't be overridden by invite"); continue } I.add(B.key), i.markValid(); continue } const Q = B.key, s = B.value; if (s !== "admin" && s !== "manager" && s !== "writer" && s !== "reader" && s !== "writeOnly" && s !== "revoked" && s !== "managerInvite" && s !== "adminInvite" && s !== "writerInvite" && s !== "readerInvite" && s !== "writeOnlyInvite") { i.markInvalid("Group transaction must set a valid role"); continue } if (Q === $A && !(s === "reader" || s === "writer" || s === "writeOnly" || s === "revoked")) { i.markInvalid("Everyone can only be set to reader, writer, writeOnly or revoked"); continue } if (r === void 0 && n === A && Q === n && s === "admin") { E(B); continue } if (n === B.key && B.value === "revoked") { E(B); continue } const a = t.getRoleAtTime(Q, i.currentMadeAt); if (r === "admin") { if (a === "admin" && s !== "admin" && Q !== n) { i.markInvalid("Admins can't demote admins."); continue } E(B); continue } if (r === "manager") { if (a === "admin") { i.markInvalid("Managers can't demote admins."); continue } if (B.value === "admin") { i.markInvalid("Managers can't promote to admin."); continue } if (B.value === "adminInvite") { i.markInvalid("Managers can't invite admins."); continue } if (B.value === "managerInvite") { i.markInvalid("Managers can't invite managers."); continue } E(B); continue } if (r === "adminInvite") { if (B.value !== "admin") { i.markInvalid("AdminInvites can only create admins."); continue } } else if (r === "managerInvite") { if (B.value !== "manager") { i.markInvalid("managerInvite can only create managers."); continue } } else if (r === "writerInvite") { if (B.value !== "writer") { i.markInvalid("WriterInvites can only create writers."); continue } } else if (r === "readerInvite") { if (B.value !== "reader") { i.markInvalid("ReaderInvites can only create reader."); continue } } else if (r === "writeOnlyInvite") { if (B.value !== "writeOnly") { i.markInvalid("WriteOnlyInvites can only create writeOnly."); continue } } else { i.markInvalid("Group transaction must be made by current admin, manager, or invite"); continue } t.setDirectRole(Q, B.value), i.markValid() } } function DD(e, A) { return e === A.id && A instanceof at ? A.currentAgentID() : e } function fD(e) { return e.startsWith("writeKeyFor_") } function yD(e) { return e.slice(12) } function ci(e) { return e.startsWith("key_") && e.includes("_for_key") } function pD(e) { return e.startsWith("key_") && (e.includes("_for_sealer") || e.includes("_for_co")) || e.includes("_for_everyone") } function mD(e) { return e.startsWith("parent_") } function ND(e) { return e.startsWith("child_") } function kD(e, A, g) { if (Object.keys(g).length === 0) return !1; const I = e.slice(0, e.indexOf("_for_")); return g[A] === I } const $A = "everyone"; function GD(e) { const A = e.get("readKey"); if (!A || !_t(e, $A) || e.get(`${A}_for_${$A}`)) return; if (_t(e, e.core.node.getCurrentAgent().id)) { const i = e.getReadKey(A); i && e.set(`${A}_for_${$A}`, i, "trusting"); return } const I = e.keys().filter(i => i.startsWith("key_") && i.endsWith("_for_everyone")); let t = I[0]; for (const i of I) { if (!t) { t = i; continue } const n = e.getRaw(i), r = e.getRaw(t); n && r && n.madeAt > r.madeAt && (t = i) } t && (e._lastReadableKeyId = t.replace("_for_everyone", "")) } class wr extends ur { constructor(A, g) { super(A, g), this.crypto = A.node.crypto, this.migrate() } migrate() { if (!this.core.isGroup()) return; const A = () => { GD(this) }; this.core.isCompletelyDownloaded() ? A() : this.core.waitFor({ predicate: g => g.isCompletelyDownloaded(), onSuccess: A }) } roleOf(A) { return this.roleOfInternal(A) } roleOfInternal(A) { let g = this.get(A); g === "revoked" && (g = void 0); let I = g; for (const t of Object.keys(this.ops)) { if (!Yt(t)) continue; const i = this.getParentGroupFromKey(t, this.atTimeFilter); if (!i) continue; const n = this.get(t) ?? "extend", r = i.roleOfInternal(A); if (!mE(r)) continue; const o = n !== "extend" ? n : r; SD(o, I) && (I = o) } if (!I && A !== "everyone") { const t = this.get("everyone"); if (t && t !== "revoked") return t } return I } getParentGroupFromKey(A, g) { if (this.get(A) === "revoked") return null; const I = this.core.node.expectCoValueLoaded(Wt(A), "Expected parent group to be loaded"), t = wA(I.getCurrentContent()); return g ? t.atTime(g) : t } getParentGroups(A) { const g = []; for (const I of Object.keys(this.ops)) { if (!Yt(I)) continue; const t = this.getParentGroupFromKey(I, A); t && (A ? g.push(t.atTime(A)) : g.push(t)) } return g } forEachChildGroup(A) { for (const g of this.core.dependant) { const I = this.core.node.getCoValue(g); if (!I.isGroup()) continue; const t = wA(I.getCurrentContent()), i = t.get(`parent_${this.id}`); i && i !== "revoked" && A(t) } } myRole() { return this.roleOfInternal(this.core.node.getCurrentAccountOrAgentID()) } addMember(A, g) { this.addMemberInternal(A, g) } addMemberInternal(A, g) { const I = typeof A == "string" ? A : A.id, t = this.get(I); if (t === g) return; if (I === $A) { if (!(g === "reader" || g === "writer" || g === "writeOnly")) throw new Error("Can't make everyone something other than reader, writer or writeOnly"); const n = this.getCurrentReadKey(); if (!n.secret) throw new Error("Can't add member without read key secret"); const r = this.get(I); if (this.set(I, g, "trusting"), this.get(I) !== g) throw new Error(`Failed to set role ${g} to ${I} (role of current account is ${this.myRole()})`); g === "writeOnly" ? ((r === "reader" || r === "writer") && this.rotateReadKey("everyone"), this.delete(`${n.id}_for_${$A}`)) : this.set(`${n.id}_for_${$A}`, n.secret, "trusting"); return } const i = typeof A == "string" ? A : A.currentAgentID(); if (i === $A) throw new Error("Agent should not be everyone"); if (g === "writeOnly" || g === "writeOnlyInvite") { if ((t === "reader" || t === "writer" || t === "manager" || t === "admin") && this.rotateReadKey(I), this.set(I, g, "trusting"), this.get(I) !== g) throw new Error(`Failed to set role ${g} to ${I} (role of current account is ${this.myRole()})`); this.internalCreateWriteOnlyKeyForMember(I, i) } else { const n = this.getCurrentReadKey(); if (!n.secret) throw new Error("Can't add member without read key secret"); if (this.set(I, g, "trusting"), this.get(I) !== g) throw new Error(`Failed to set role ${g} to ${I} (role of current account is ${this.myRole()})`); this.storeKeyRevelationForMember(I, i, n.id, n.secret); for (const r of this.getWriteOnlyKeys()) { const o = this.core.getReadKey(r); if (!o) { x.error("Can't find key " + r); continue } this.storeKeyRevelationForMember(I, i, r, o) } } } internalCreateWriteOnlyKeyForMember(A, g) { const I = this.crypto.newRandomKeySecret(); this.set(`writeKeyFor_${A}`, I.id, "trusting"), this.storeKeyRevelationForMember(A, g, I.id, I.secret); for (const t of this.getMemberKeys()) { const i = this.get(t); if (i === "reader" || i === "writer" || i === "admin" || i === "manager" || i === "readerInvite" || i === "writerInvite" || i === "adminInvite") { const n = this.core.node.resolveAccountAgent(t, "Expected member agent to be loaded").value; if (!n) throw new Error("Expected member agent to be loaded"); this.storeKeyRevelationForMember(t, n, I.id, I.secret) } } for (const t of this.getParentGroups()) this.revealReadKeyToParentGroup(t, I.id, I.secret, { revealAllWriteOnlyKeys: !1 }); return I.id } storeKeyRevelationForMember(A, g, I, t) { this.set(`${I}_for_${A}`, this.crypto.seal({ message: t, from: this.core.node.getCurrentAgent().currentSealerSecret(), to: this.crypto.getAgentSealerID(g), nOnceMaterial: { in: this.id, tx: this.core.nextTransactionID() } }), "trusting") } storeKeyRevelationForParentGroup(A, g, I, t) { this.set(`${I}_for_${A}`, this.crypto.encryptKeySecret({ encrypting: { id: A, secret: g }, toEncrypt: { id: I, secret: t } }).encrypted, "trusting") } getWriteOnlyKeys() { const A = []; for (const g of this.keys()) g.startsWith("writeKeyFor_") && A.push(this.get(g)); return A } getCurrentReadKeyId() { if (this._lastReadableKeyId) return this._lastReadableKeyId; const A = this.myRole(); if (A === "writeOnly") { const g = this.core.node.getCurrentAgent().id, I = this.get(`writeKeyFor_${g}`); return !I && this.get("everyone") === "writeOnly" ? (this.internalCreateWriteOnlyKeyForMember(g, this.core.node.getCurrentAgent().currentAgentID()), this.get(`writeKeyFor_${g}`)) : I } if (!A) { const g = this.core.node.getCurrentAgent().id, I = this.get(`writeKeyFor_${g}`); if (I) return I } return this.get("readKey") } getMemberKeys() { return this.keys().filter(A => A.startsWith("co_") || bt(A)) } getAllMemberKeysSet() { const A = new Set(this.getMemberKeys()); for (const g of this.getParentGroups()) for (const I of g.getAllMemberKeysSet()) A.add(I); return A } getReadKey(A) { const g = this.core.readKeyCache; let I = g.get(A); return I || (I = this.getUncachedReadKey(A), I && g.set(A, I)), I } getUncachedReadKey(A) { const g = this.core, I = this.get(`${A}_for_everyone`); if (I) return I; const t = YA(g.node.currentSessionID), i = RI(t) && g.id === t ? g.node.crypto.getAgentID(g.node.agentSecret) : t, n = this.lastEditAt(`${A}_for_${i}`); if (n?.value) { const r = n.by, o = g.node.resolveAccountAgent(r, "Expected to know revealer").value; if (!o) throw new Error("Expected to know revealer"); const C = this.crypto.unseal(n.value, this.crypto.getAgentSealerSecret(g.node.agentSecret), this.crypto.getAgentSealerID(o), { in: this.id, tx: n.tx }); if (C) return C } for (const r of this.keys()) if (ci(r) && r.startsWith(A)) { const o = r.split("_for_")[1], C = this.getReadKey(o); if (!C) continue; const B = this.get(r), Q = this.crypto.decryptKeySecret({ encryptedID: A, encryptingID: o, encrypted: B }, C); if (Q) return Q; x.warn(`Encrypting ${o} key didn't decrypt ${A}`) } for (const r of this.keys()) if (Yt(r)) { const o = Wt(r), C = g.node.expectCoValueLoaded(o, "Expected parent group to be loaded"), B = this.findValidParentKeys(A, C); for (const Q of B) { const s = this.get(`${A}_for_${Q.id}`); if (s) { const E = C.node.crypto.decryptKeySecret({ encryptedID: A, encryptingID: Q.id, encrypted: s }, Q.secret); if (E) return E; x.warn(`Encrypting parent ${Q.id} key didn't decrypt ${A}`) } } } } findValidParentKeys(A, g) { const I = []; for (const t of this.keys()) if (ci(t) && t.startsWith(A)) { const i = t.split("_for_")[1], n = g.getReadKey(i); if (!n) continue; I.push({ id: i, secret: n }) } return I } rotateReadKey(A) { if (A !== $A && _t(this, $A)) return; const g = this.getMemberKeys().filter(C => C !== A), I = g.filter(C => _t(this, C)), t = g.filter(C => { const B = this.get(C); return B === "writeOnly" || B === "writeOnlyInvite" }), i = this.getParentGroups(), n = this.getCurrentReadKey(); if (!n.secret) throw new yo("Can't rotate read key secret we don't have access to"); const r = { id: n.id, secret: n.secret }, o = this.crypto.newRandomKeySecret(); for (const C of I) { const B = this.core.node.resolveAccountAgent(C, "Expected to know currently permitted reader").value; if (!B) throw new Error("Expected to know currently permitted reader"); this.storeKeyRevelationForMember(C, B, o.id, o.secret) } for (const C of t) { const B = this.core.node.resolveAccountAgent(C, "Expected to know writeOnly member").value; if (!B) throw new Error("Expected to know writeOnly member"); const Q = this.crypto.newRandomKeySecret(); this.storeKeyRevelationForMember(C, B, Q.id, Q.secret), this.set(`writeKeyFor_${C}`, Q.id, "trusting"); for (const s of I) { const E = this.core.node.resolveAccountAgent(s, "Expected to know currently permitted reader").value; if (!E) throw new Error("Expected to know currently permitted reader"); this.storeKeyRevelationForMember(s, E, Q.id, Q.secret) } for (const s of this.getParentGroups()) this.revealReadKeyToParentGroup(s, Q.id, Q.secret, { revealAllWriteOnlyKeys: !1 }) } this.set(`${r.id}_for_${o.id}`, this.crypto.encryptKeySecret({ encrypting: o, toEncrypt: r }).encrypted, "trusting"), this.set("readKey", o.id, "trusting"); for (const C of i) { const { id: B, secret: Q } = C.getCurrentReadKey(); if (!Q) { x.warn("Can't reveal new child key to parent where we don't have access to the parent read key"); continue } this.storeKeyRevelationForParentGroup(B, Q, o.id, o.secret) } this.forEachChildGroup(C => { if (!C.isSelfExtension(this)) try { C.rotateReadKey(A) } catch (B) { if (B instanceof yo) x.warn(`Can't rotate read key on child ${C.id} because we don't have access to the read key`); else throw B } }) } isSelfExtension(A) { return NE(this.core, A) } getCurrentReadKey() { const A = this.getCurrentReadKeyId(); if (!A) throw new Error("No readKey set"); return { secret: this.getReadKey(A), id: A } } extend(A, g = "inherit") { if (this.isSelfExtension(A)) return; if (this.myRole() !== "admin") throw new Error("To extend a group, the current account must be an admin in the child group"); const I = g === "inherit" ? "extend" : g; this.set(`parent_${A.id}`, I, "trusting"); const { id: t, secret: i } = this.getCurrentReadKey(); if (i === void 0) throw new Error("Can't extend group without child read key secret"); this.revealReadKeyToParentGroup(A, t, i, { revealAllWriteOnlyKeys: !0 }) } revealReadKeyToParentGroup(A, g, I, { revealAllWriteOnlyKeys: t }) { let i; Xt(A.myRole()) || (i = A.internalCreateWriteOnlyKeyForMember(this.core.node.getCurrentAgent().id, this.core.node.getCurrentAgent().currentAgentID())); let { id: n, secret: r } = A.getCurrentReadKey(); if (!r) throw new Error("Can't extend group without parent read key secret"); if (this.storeKeyRevelationForParentGroup(n, r, g, I), t) for (const o of this.getWriteOnlyKeys()) { if (o === i) continue; const C = this.core.getReadKey(o); if (!C) { x.error("Can't find key " + o); continue } this.storeKeyRevelationForParentGroup(n, r, o, C) } } revokeExtend(A) { if (this.myRole() !== "admin") throw new Error("To unextend a group, the current account must be an admin in the child group"); if (!Xt(A.myRole())) throw new Error("To unextend a group, the current account must be a member of the parent group"); !this.get(`parent_${A.id}`) || this.get(`parent_${A.id}`) === "revoked" || (this.set(`parent_${A.id}`, "revoked", "trusting"), A.get(`child_${this.id}`) && A.set(`child_${this.id}`, "revoked", "trusting"), this.rotateReadKey()) } removeMember(A) { const g = typeof A == "string" ? A : A.id; (this.myRole() === "admin" || this.myRole() === "manager") && this.rotateReadKey(g), this.set(g, "revoked", "trusting") } createInvite(A) { const g = this.crypto.newRandomSecretSeed(), I = this.crypto.agentSecretFromSecretSeed(g), t = this.crypto.getAgentID(I); return this.addMemberInternal(t, `${A}Invite`), MD(g) } createMap(A, g, I = "private", t = this.crypto.createdNowUnique()) { const i = this.core.node.createCoValue({ type: "comap", ruleset: { type: "ownedByGroup", group: this.id }, meta: g || null, ...t }).getCurrentContent(); return A ? i.assign(A, I) : t.createdAt || i.core.makeTransaction([], "trusting"), i } createList(A, g, I = "private", t = this.crypto.createdNowUnique()) { const i = this.core.node.createCoValue({ type: "colist", ruleset: { type: "ownedByGroup", group: this.id }, meta: g || null, ...t }).getCurrentContent(); return A?.length ? i.appendItems(A, void 0, I) : t.createdAt || i.core.makeTransaction([], "trusting"), i } createPlainText(A, g, I = "private") { const t = this.core.node.createCoValue({ type: "coplaintext", ruleset: { type: "ownedByGroup", group: this.id }, meta: g || null, ...this.crypto.createdNowUnique() }).getCurrentContent(); return A && t.insertAfter(0, A, I), t } createStream(A, g = this.crypto.createdNowUnique()) { const I = this.core.node.createCoValue({ type: "costream", ruleset: { type: "ownedByGroup", group: this.id }, meta: A || null, ...g }).getCurrentContent(); return g.createdAt || I.core.makeTransaction([], "trusting"), I } createBinaryStream(A = { type: "binary" }, g = this.crypto.createdNowUnique()) { return this.core.node.createCoValue({ type: "costream", ruleset: { type: "ownedByGroup", group: this.id }, meta: A, ...g }).getCurrentContent() } } function mE(e) { return e === "revoked" || e === "admin" || e === "manager" || e === "writer" || e === "reader" } function SD(e, A) { return e === "revoked" ? !0 : e === "manager" ? !A || A !== "manager" && A !== "admin" : e === "admin" ? !A || A !== "admin" : e === "writer" ? !A || A === "reader" || A === "writeOnly" : e === "reader" ? !A : !1 } function MD(e) { return `inviteSecret_z${_.encode(e)}` } function FD(e) { if (!e.startsWith("inviteSecret_z")) throw new Error("Invalid invite secret"); return _.decode(e.slice(14)) } const _t = (e, A) => { const g = e.get(A); return g === "admin" || g === "manager" || g === "writer" || g === "reader" || g === "adminInvite" || g === "writerInvite" || g === "readerInvite" }; class yo extends Error { constructor(A) { super(A), this.name = "NoReadKeyAccessError" } } function NE(e, A) { const g = new Set, I = [A]; for (; ;) { const t = I.pop(); if (!t) return !1; if (t.id === e.id) return !0; g.add(t.id); const i = t.getParentGroups(); for (const n of i) g.has(n.id) || I.push(n) } } function kE(e, A) { return { type: "comap", ruleset: { type: "group", initialAdmin: A.getAgentID(e) }, meta: { type: "account" }, createdAt: null, uniqueness: null } } class at extends wr { currentAgentID() { if (this._cachedCurrentAgentID) return this._cachedCurrentAgentID; const A = this.keys().filter(g => g.startsWith("sealer_")).sort((g, I) => (this.lastEditAt(g)?.at.getTime() || 0) - (this.lastEditAt(I)?.at.getTime() || 0)); return A.length !== 1 && x.warn("Account has " + A.length + " agents", { id: this.id }), this._cachedCurrentAgentID = A[0], A[0] } createInvite(A) { throw new Error("Cannot create invite from an account") } roleOfInternal(A) { return A === this.id ? "admin" : super.roleOfInternal(A) } addMember(A, g) { throw new Error("Cannot add a member to an account") } removeMember(A) { throw new Error("Cannot remove a member from an account") } extend(A, g = "inherit") { throw new Error("Cannot extend an account") } revokeExtend(A) { throw new Error("Cannot unextend an account") } } class dr { constructor(A, g) { this.account = A, this.agentSecret = g, this.crypto = A.core.node.crypto } get id() { return this.account.id } currentAgentID() { return this.crypto.getAgentID(this.agentSecret) } currentSignerID() { return this.crypto.getAgentSignerID(this.currentAgentID()) } currentSignerSecret() { return this.crypto.getAgentSignerSecret(this.agentSecret) } currentSealerID() { return this.crypto.getAgentSealerID(this.currentAgentID()) } currentSealerSecret() { return this.crypto.getAgentSealerSecret(this.agentSecret) } } class po { constructor(A, g) { this.agentSecret = A, this.crypto = g } get id() { return this.crypto.getAgentID(this.agentSecret) } currentAgentID() { return this.crypto.getAgentID(this.agentSecret) } currentSignerID() { return this.crypto.getAgentSignerID(this.currentAgentID()) } currentSignerSecret() { return this.crypto.getAgentSignerSecret(this.agentSecret) } currentSealerID() { return this.crypto.getAgentSealerID(this.currentAgentID()) } currentSealerSecret() { return this.crypto.getAgentSealerSecret(this.agentSecret) } } function mo(e) { if (!(e instanceof at)) throw new Error("Expected an account"); return e } function GE(e, A = "") { let g = [], I = e.split(",").map(i => i ? parseInt(i, 36) : 0), t = 0; for (let i = 0; i < I.length; i++)i % 2 ? g.push([t, t + I[i], A ? parseInt(A[i >> 1], 36) : 0]) : t = I[i]; return g } function SE(e, A) { let g = 0, I = A.length - 1; for (; g <= I;) { let t = g + I >> 1, i = A[t], n = i[0], r = i[1]; if (n <= e && e <= r) return t; e > r ? g = t + 1 : I = t - 1 } return -1 } function UD(e) { return e <= 65535 } const No = GE(",9,a,,b,1,d,,e,h,3j,w,4p,,4t,,4u,,lc,33,w3,6,13l,18,14v,,14x,1,150,1,153,,16o,5,174,a,17g,,18r,k,19s,,1cm,6,1ct,,1cv,5,1d3,1,1d6,3,1e7,,1e9,,1f4,q,1ie,a,1kb,8,1kt,,1li,3,1ln,8,1lx,2,1m1,4,1nd,2,1ow,1,1p3,8,1qi,n,1r6,,1r7,v,1s3,,1tm,,1tn,,1to,,1tq,2,1tt,7,1u1,3,1u5,,1u6,1,1u9,6,1uq,1,1vl,,1vm,1,1x8,,1xa,,1xb,1,1xd,3,1xj,1,1xn,1,1xp,,1xz,,1ya,1,1z2,,1z5,1,1z7,,20s,,20u,2,20x,1,213,1,217,2,21d,,228,1,22d,,22p,1,22r,,24c,,24e,2,24h,4,24n,1,24p,,24r,1,24t,,25e,1,262,5,269,,26a,1,27w,,27y,1,280,,281,3,287,1,28b,1,28d,,28l,2,28y,1,29u,,2bi,,2bj,,2bk,,2bl,1,2bq,2,2bu,2,2bx,,2c7,,2dc,,2dd,2,2dg,,2f0,,2f2,2,2f5,3,2fa,2,2fe,3,2fp,1,2g2,1,2gx,,2gy,1,2ik,,2im,,2in,1,2ip,,2iq,,2ir,1,2iu,2,2iy,3,2j9,1,2jm,1,2k3,,2kg,1,2ki,1,2m3,1,2m6,,2m7,1,2m9,3,2me,2,2mi,2,2ml,,2mm,,2mv,,2n6,1,2o1,,2o2,1,2q2,,2q7,,2q8,1,2qa,2,2qe,,2qg,6,2qn,,2r6,1,2sx,,2sz,,2t0,6,2tj,7,2wh,,2wj,,2wk,8,2x4,6,2zc,1,305,,307,,309,,30e,1,31t,d,327,,328,4,32e,1,32l,a,32x,z,346,,371,3,375,,376,5,37d,1,37f,1,37h,1,386,1,388,1,38e,2,38x,3,39e,,39g,,39h,1,39p,,3a5,,3cw,2n,3fk,1z,3hk,2f,3tp,2,4k2,3,4ky,2,4lu,1,4mq,1,4ok,1,4om,,4on,6,4ou,7,4p2,,4p3,1,4p5,a,4pp,,4qz,2,4r2,,4r3,,4ud,1,4vd,,4yo,2,4yr,3,4yv,1,4yx,2,4z4,1,4z6,,4z7,5,4zd,2,55j,1,55l,1,55n,,579,,57a,,57b,,57c,6,57k,,57m,,57p,7,57x,5,583,9,58f,,59s,u,5c0,3,5c4,,5dg,9,5dq,3,5du,2,5ez,8,5fk,1,5fm,,5gh,,5gi,3,5gm,1,5go,5,5ie,,5if,,5ig,1,5ii,2,5il,,5im,,5in,4,5k4,7,5kc,7,5kk,1,5km,1,5ow,2,5p0,c,5pd,,5pe,6,5pp,,5pw,,5pz,,5q0,1,5vk,1r,6bv,,6bw,,6bx,,6by,1,6co,6,6d8,,6dl,,6e8,f,6hc,w,6jm,,6k9,,6ms,5,6nd,1,6xm,1,6y0,,70o,,72n,,73d,a,73s,2,79e,,7fu,1,7g6,,7gg,,7i3,3,7i8,5,7if,b,7is,35,7m8,39,7pk,a,7pw,,7py,,7q5,,7q9,,7qg,,7qr,1,7r8,,7rb,,7rg,,7ri,,7rn,2,7rr,,7s3,4,7th,2,7tt,,7u8,,7un,,850,1,8hx,2,8ij,1,8k0,,8k5,,8vj,2,8zj,,928,v,9ii,5,9io,,9j1,,9ll,1,9zr,,9zt,,wvj,3,wvo,9,wwu,1,wz4,1,x6q,,x6u,,x6z,,x7n,1,x7p,1,x7r,,x7w,,xa8,1,xbo,f,xc4,1,xcw,h,xdr,,xeu,7,xfr,a,xg2,,xg3,,xgg,s,xhc,2,xhf,,xir,,xis,1,xiu,3,xiy,1,xj0,1,xj2,1,xj4,,xk5,,xm1,5,xm7,1,xm9,1,xmb,1,xmd,1,xmr,,xn0,,xn1,,xoc,,xps,,xpu,2,xpz,1,xq6,1,xq9,,xrf,,xrg,1,xri,1,xrp,,xrq,,xyb,1,xyd,,xye,1,xyg,,xyh,1,xyk,,xyl,,xz4,,xz5,q,xzw,,xzx,q,y0o,,y0p,q,y1g,,y1h,q,y28,,y29,q,y30,,y31,q,y3s,,y3t,q,y4k,,y4l,q,y5c,,y5d,q,y64,,y65,q,y6w,,y6x,q,y7o,,y7p,q,y8g,,y8h,q,y98,,y99,q,ya0,,ya1,q,yas,,yat,q,ybk,,ybl,q,ycc,,ycd,q,yd4,,yd5,q,ydw,,ydx,q,yeo,,yep,q,yfg,,yfh,q,yg8,,yg9,q,yh0,,yh1,q,yhs,,yht,q,yik,,yil,q,yjc,,yjd,q,yk4,,yk5,q,ykw,,ykx,q,ylo,,ylp,q,ymg,,ymh,q,yn8,,yn9,q,yo0,,yo1,q,yos,,yot,q,ypk,,ypl,q,yqc,,yqd,q,yr4,,yr5,q,yrw,,yrx,q,yso,,ysp,q,ytg,,yth,q,yu8,,yu9,q,yv0,,yv1,q,yvs,,yvt,q,ywk,,ywl,q,yxc,,yxd,q,yy4,,yy5,q,yyw,,yyx,q,yzo,,yzp,q,z0g,,z0h,q,z18,,z19,q,z20,,z21,q,z2s,,z2t,q,z3k,,z3l,q,z4c,,z4d,q,z54,,z55,q,z5w,,z5x,q,z6o,,z6p,q,z7g,,z7h,q,z88,,z89,q,z90,,z91,q,z9s,,z9t,q,zak,,zal,q,zbc,,zbd,q,zc4,,zc5,q,zcw,,zcx,q,zdo,,zdp,q,zeg,,zeh,q,zf8,,zf9,q,zg0,,zg1,q,zgs,,zgt,q,zhk,,zhl,q,zic,,zid,q,zj4,,zj5,q,zjw,,zjx,q,zko,,zkp,q,zlg,,zlh,q,zm8,,zm9,q,zn0,,zn1,q,zns,,znt,q,zok,,zol,q,zpc,,zpd,q,zq4,,zq5,q,zqw,,zqx,q,zro,,zrp,q,zsg,,zsh,q,zt8,,zt9,q,zu0,,zu1,q,zus,,zut,q,zvk,,zvl,q,zwc,,zwd,q,zx4,,zx5,q,zxw,,zxx,q,zyo,,zyp,q,zzg,,zzh,q,1008,,1009,q,1010,,1011,q,101s,,101t,q,102k,,102l,q,103c,,103d,q,1044,,1045,q,104w,,104x,q,105o,,105p,q,106g,,106h,q,1078,,1079,q,1080,,1081,q,108s,,108t,q,109k,,109l,q,10ac,,10ad,q,10b4,,10b5,q,10bw,,10bx,q,10co,,10cp,q,10dg,,10dh,q,10e8,,10e9,q,10f0,,10f1,q,10fs,,10ft,q,10gk,,10gl,q,10hc,,10hd,q,10i4,,10i5,q,10iw,,10ix,q,10jo,,10jp,q,10kg,,10kh,q,10l8,,10l9,q,10m0,,10m1,q,10ms,,10mt,q,10nk,,10nl,q,10oc,,10od,q,10p4,,10p5,q,10pw,,10px,q,10qo,,10qp,q,10rg,,10rh,q,10s8,,10s9,q,10t0,,10t1,q,10ts,,10tt,q,10uk,,10ul,q,10vc,,10vd,q,10w4,,10w5,q,10ww,,10wx,q,10xo,,10xp,q,10yg,,10yh,q,10z8,,10z9,q,1100,,1101,q,110s,,110t,q,111k,,111l,q,112c,,112d,q,1134,,1135,q,113w,,113x,q,114o,,114p,q,115g,,115h,q,1168,,1169,q,1170,,1171,q,117s,,117t,q,118k,,118l,q,119c,,119d,q,11a4,,11a5,q,11aw,,11ax,q,11bo,,11bp,q,11cg,,11ch,q,11d8,,11d9,q,11e0,,11e1,q,11es,,11et,q,11fk,,11fl,q,11gc,,11gd,q,11h4,,11h5,q,11hw,,11hx,q,11io,,11ip,q,11jg,,11jh,q,11k8,,11k9,q,11l0,,11l1,q,11ls,,11lt,q,11mk,,11ml,q,11nc,,11nd,q,11o4,,11o5,q,11ow,,11ox,q,11po,,11pp,q,11qg,,11qh,q,11r8,,11r9,q,11s0,,11s1,q,11ss,,11st,q,11tk,,11tl,q,11uc,,11ud,q,11v4,,11v5,q,11vw,,11vx,q,11wo,,11wp,q,11xg,,11xh,q,11y8,,11y9,q,11z0,,11z1,q,11zs,,11zt,q,120k,,120l,q,121c,,121d,q,1224,,1225,q,122w,,122x,q,123o,,123p,q,124g,,124h,q,1258,,1259,q,1260,,1261,q,126s,,126t,q,127k,,127l,q,128c,,128d,q,1294,,1295,q,129w,,129x,q,12ao,,12ap,q,12bg,,12bh,q,12c8,,12c9,q,12d0,,12d1,q,12ds,,12dt,q,12ek,,12el,q,12fc,,12fd,q,12g4,,12g5,q,12gw,,12gx,q,12ho,,12hp,q,12ig,,12ih,q,12j8,,12j9,q,12k0,,12k1,q,12ks,,12kt,q,12lk,,12ll,q,12mc,,12md,q,12n4,,12n5,q,12nw,,12nx,q,12oo,,12op,q,12pg,,12ph,q,12q8,,12q9,q,12r0,,12r1,q,12rs,,12rt,q,12sk,,12sl,q,12tc,,12td,q,12u4,,12u5,q,12uw,,12ux,q,12vo,,12vp,q,12wg,,12wh,q,12x8,,12x9,q,12y0,,12y1,q,12ys,,12yt,q,12zk,,12zl,q,130c,,130d,q,1314,,1315,q,131w,,131x,q,132o,,132p,q,133g,,133h,q,1348,,1349,q,1350,,1351,q,135s,,135t,q,136k,,136l,q,137c,,137d,q,1384,,1385,q,138w,,138x,q,139o,,139p,q,13ag,,13ah,q,13b8,,13b9,q,13c0,,13c1,q,13cs,,13ct,q,13dk,,13dl,q,13ec,,13ed,q,13f4,,13f5,q,13fw,,13fx,q,13go,,13gp,q,13hg,,13hh,q,13i8,,13i9,q,13j0,,13j1,q,13js,,13jt,q,13kk,,13kl,q,13lc,,13ld,q,13m4,,13m5,q,13mw,,13mx,q,13no,,13np,q,13og,,13oh,q,13p8,,13p9,q,13q0,,13q1,q,13qs,,13qt,q,13rk,,13rl,q,13sc,,13sd,q,13t4,,13t5,q,13tw,,13tx,q,13uo,,13up,q,13vg,,13vh,q,13w8,,13w9,q,13x0,,13x1,q,13xs,,13xt,q,13yk,,13yl,q,13zc,,13zd,q,1404,,1405,q,140w,,140x,q,141o,,141p,q,142g,,142h,q,1438,,1439,q,1440,,1441,q,144s,,144t,q,145k,,145l,q,146c,,146d,q,1474,,1475,q,147w,,147x,q,148o,,148p,q,149g,,149h,q,14a8,,14a9,q,14b0,,14b1,q,14bs,,14bt,q,14ck,,14cl,q,14dc,,14dd,q,14e4,,14e5,q,14ew,,14ex,q,14fo,,14fp,q,14gg,,14gh,q,14h8,,14h9,q,14i0,,14i1,q,14is,,14it,q,14jk,,14jl,q,14kc,,14kd,q,14l4,,14l5,q,14lw,,14lx,q,14mo,,14mp,q,14ng,,14nh,q,14o8,,14o9,q,14p0,,14p1,q,14ps,,14pt,q,14qk,,14ql,q,14rc,,14rd,q,14s4,,14s5,q,14sw,,14sx,q,14to,,14tp,q,14ug,,14uh,q,14v8,,14v9,q,14w0,,14w1,q,14ws,,14wt,q,14xk,,14xl,q,14yc,,14yd,q,14z4,,14z5,q,14zw,,14zx,q,150o,,150p,q,151g,,151h,q,1528,,1529,q,1530,,1531,q,153s,,153t,q,154k,,154l,q,155c,,155d,q,1564,,1565,q,156w,,156x,q,157o,,157p,q,158g,,158h,q,1598,,1599,q,15a0,,15a1,q,15as,,15at,q,15bk,,15bl,q,15cc,,15cd,q,15d4,,15d5,q,15dw,,15dx,q,15eo,,15ep,q,15fg,,15fh,q,15g8,,15g9,q,15h0,,15h1,q,15hs,,15ht,q,15ik,,15il,q,15jc,,15jd,q,15k4,,15k5,q,15kw,,15kx,q,15lo,,15lp,q,15mg,,15mh,q,15n8,,15n9,q,15o0,,15o1,q,15os,,15ot,q,15pk,,15pl,q,15qc,,15qd,q,15r4,,15r5,q,15rw,,15rx,q,15so,,15sp,q,15tg,,15th,q,15u8,,15u9,q,15v0,,15v1,q,15vs,,15vt,q,15wk,,15wl,q,15xc,,15xd,q,15y4,,15y5,q,15yw,,15yx,q,15zo,,15zp,q,160g,,160h,q,1618,,1619,q,1620,,1621,q,162s,,162t,q,163k,,163l,q,164c,,164d,q,1654,,1655,q,165w,,165x,q,166o,,166p,q,167g,,167h,q,1688,,1689,q,1690,,1691,q,169s,,169t,q,16ak,,16al,q,16bc,,16bd,q,16c4,,16c5,q,16cw,,16cx,q,16do,,16dp,q,16eg,,16eh,q,16f8,,16f9,q,16g0,,16g1,q,16gs,,16gt,q,16hk,,16hl,q,16ic,,16id,q,16j4,,16j5,q,16jw,,16jx,q,16ko,,16kp,q,16ls,m,16mj,1c,1dlq,,1e68,f,1e74,f,1edb,,1ehq,1,1ek0,b,1eyl,,1f4w,,1f92,4,1gjl,2,1gjp,1,1gjw,3,1gl4,2,1glb,,1gpx,1,1h5w,3,1h7t,4,1hgr,1,1hj0,3,1hl2,a,1hmq,3,1hq8,,1hq9,,1hqa,,1hrs,e,1htc,,1htf,1,1htr,2,1htu,,1hv4,2,1hv7,3,1hvb,1,1hvd,1,1hvh,,1hvm,,1hvx,,1hxc,2,1hyf,4,1hyk,,1hyl,7,1hz9,1,1i0j,,1i0w,1,1i0y,,1i2b,2,1i2e,8,1i2n,,1i2o,,1i2q,1,1i2x,3,1i32,,1i33,,1i5o,2,1i5r,2,1i5u,1,1i5w,3,1i66,,1i69,,1ian,,1iao,2,1iar,7,1ibk,1,1ibm,1,1id7,1,1ida,,1idb,,1idc,,1idd,3,1idj,1,1idn,1,1idp,,1idz,,1iea,1,1iee,6,1ieo,4,1igo,,1igp,1,1igr,5,1igy,,1ih1,,1ih3,2,1ih6,,1ih8,1,1iha,2,1ihd,,1ihe,,1iht,1,1ik5,2,1ik8,7,1ikg,1,1iki,2,1ikl,,1ikm,,1ila,,1ink,,1inl,1,1inn,5,1int,,1inu,,1inv,1,1inx,,1iny,,1inz,1,1io1,,1io2,1,1iun,,1iuo,1,1iuq,3,1iuw,3,1iv0,1,1iv2,,1iv3,1,1ivw,1,1iy8,2,1iyb,7,1iyj,1,1iyl,,1iym,,1iyn,1,1j1n,,1j1o,,1j1p,,1j1q,1,1j1s,7,1j4t,,1j4u,,1j4v,,1j4y,3,1j52,,1j53,4,1jcc,2,1jcf,8,1jco,,1jcp,1,1jjk,,1jjl,4,1jjr,1,1jjv,3,1jjz,,1jk0,,1jk1,,1jk2,,1jk3,,1jo1,2,1jo4,3,1joa,1,1joc,3,1jog,,1jok,,1jpd,9,1jqr,5,1jqx,,1jqy,,1jqz,3,1jrb,,1jrl,5,1jrr,1,1jrt,2,1jt0,5,1jt6,c,1jtj,,1jtk,1,1k4v,,1k4w,6,1k54,5,1k5a,,1k5b,,1k7m,l,1k89,,1k8a,6,1k8h,,1k8i,1,1k8k,,1k8l,1,1kc1,5,1kca,,1kcc,1,1kcf,6,1kcm,,1kcn,,1kei,4,1keo,1,1ker,1,1ket,,1keu,,1kev,,1koj,1,1kol,1,1kow,1,1koy,,1koz,,1kqc,1,1kqe,4,1kqm,1,1kqo,2,1kre,,1ovk,f,1ow0,,1ow7,e,1xr2,b,1xre,2,1xrh,2,1zow,4,1zqo,6,206b,,206f,3,20jz,,20k1,1i,20lr,3,20o4,,20og,1,2ftp,1,2fts,3,2jgg,19,2jhs,m,2jxh,4,2jxp,5,2jxv,7,2jy3,7,2jyd,6,2jze,3,2k3m,2,2lmo,1i,2lob,1d,2lpx,,2lqc,,2lqz,4,2lr5,e,2mtc,6,2mtk,g,2mu3,6,2mub,1,2mue,4,2mxb,,2n1s,6,2nce,,2ne4,3,2nsc,3,2nzi,1,2ok0,6,2on8,6,2pz4,73,2q6l,2,2q7j,,2q98,5,2q9q,1,2qa6,,2qa9,9,2qb1,1k,2qcm,p,2qdd,e,2qe2,,2qen,,2qeq,8,2qf0,3,2qfd,c1,2qrf,4,2qrk,8t,2r0m,7d,2r9c,3j,2rg4,b,2rit,16,2rkc,3,2rm0,7,2rmi,5,2rns,7,2rou,29,2rrg,1a,2rss,9,2rt3,c8,2scg,sd,jny8,v,jnz4,2n,jo1s,3j,jo5c,6n,joc0,2rz", "262122424333333393233393339333333333393393b3b3b3b3b333b33b3bb33333b3b3333333b3b33bb3333b33b3bb33333b3bbb333b333b33333b3b3b3b3333b3b33b3bb39333b33b33b3b3b333b333333b3b333333b33b3b3333b3335dc333333b3b3b33323333b3bb3b33b3b3b3333b3333b3b333bb3b33b3b3b3b3b333b333b3323e2244234444444444444444444444444444444444444444443333443443333333b3b3bb33333b353b3b3b3b333b3b333b333333b3bb3b3b3bb3787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878787878dc333232333333333333333b3b3333bb3b393933b3b33bb3b393b3b3b3333b33b33b3bbb33b333b3333bb3933b3b3b333b3b3b3b3b33b3b3b33b3b3b33b3b33b33b3b3b33bb39b9b3b33b3b33b9333b393b3b33b33b3b3b3333393b3b3b33b39bb3b332333b333dd3b33332333323333333333333333333333344444444a44444434444444444444423232"), RD = GE("1sl,10,1ug,7,1vc,7,1w5,j,1wq,6,1wy,,1x2,3,1y4,1,1y7,,1yo,1,239,j,23u,6,242,1,245,4,261,,26t,j,27e,6,27m,1,27p,4,28s,1,28v,,29d,,2dx,j,2ei,f,2fs,2,2l1,11"); function* bD(e) { if (e === "") return; let A = 0, g = e.length, I = null, t = null, i = null, n = [0, 0, 2], r = 0, o = !1, C = !1, B = !1, Q = !1, s = e.codePointAt(A), E = 0, a = ""; for (; ;) { if (a += e[A++], UD(s) || (a += e[A++]), I = t, I === null && (I = ko(s, n), i = I), !C && I === 0 ? C = Go(s) : I === 3 && (B = YD(s)), A < g) s = e.codePointAt(A), t = ko(s, n); else { yield { segment: a, index: E, input: e, _catBegin: i, _catEnd: I }; return } I === 10 ? r += 1 : (r = 0, t === 14 && (I === 3 || I === 4) ? o = !0 : t === 0 && (Q = C && B && (C = Go(s)), B = B && !C)), KD(I, t, r, o, Q) && (yield { segment: a, index: E, input: e, _catBegin: i, _catEnd: I }, E = A, a = "", o = !1, Q = !1, i = t) } } function* VI(e) { for (let A of bD(e)) yield A.segment } function ko(e, A) { if (e < 127) return e >= 32 ? 0 : e === 10 ? 6 : e === 13 ? 1 : 2; if (e < A[0] || e > A[1]) { let g = SE(e, No); if (g < 0) return 0; let I = No[g]; A[0] = I[0], A[1] = I[1], A[2] = I[2] } return A[2] } function Go(e) { return SE(e, RD) >= 0 } function YD(e) { return e === 2381 || e === 2509 || e === 2765 || e === 2893 || e === 3149 || e === 3405 } function KD(e, A, g, I, t) { return e === 1 && A === 6 ? !1 : e === 1 || e === 2 || e === 6 || A === 1 || A === 2 || A === 6 ? !0 : e === 5 && (A === 5 || A === 7 || A === 8 || A === 13) || (e === 7 || e === 13) && (A === 12 || A === 13) || A === 12 && (e === 8 || e === 12) || A === 3 || A === 14 || A === 11 || e === 9 || A === 0 && t ? !1 : e === 14 && A === 4 ? !I : e === 10 && A === 10 ? g % 2 === 0 : !0 } function $t(e) { return `${e.sessionID}:${e.txIndex}:${e.changeIdx}` } class vD extends cr { constructor(A) { super(A), this.type = "coplaintext", this._cachedMapping = new WeakMap } get mapping() { const A = this.entries(); let g = this._cachedMapping.get(A); if (g) return g; g = { opIDbeforeIdx: [], opIDafterIdx: [], idxAfterOpID: {}, idxBeforeOpID: {} }; let I = 0; for (const t of A) { const i = I + 1; g.opIDafterIdx[I] = t.opID, g.opIDbeforeIdx[i] = t.opID, g.idxAfterOpID[$t(t.opID)] = i, g.idxBeforeOpID[$t(t.opID)] = I, I = i } return this._cachedMapping.set(A, g), g } toString() { return this.entries().map(A => A.value).join("") } insertBefore(A, g, I = "private") { const t = Array.from(VI(g)); if (A === 0) { const i = t[0]; i && this.prepend(i, 0, I), t.length > 1 && this.appendChars(t.slice(1), 0, I) } else this.appendChars(t, A - 1, I) } appendChars(A, g, I = "private") { const t = JD(A); for (const i of t) this.appendItems(i, g, I), g += i.length } insertAfter(A, g, I = "private") { const t = Array.from(VI(g)); A >= this.entries().length ? this.appendChars(t, A - 1, I) : this.appendChars(t, A, I) } deleteRange({ from: A, to: g }, I = "private") { const t = []; for (let i = A; i < g;) { const n = this.mapping.opIDafterIdx[i]; if (!n) throw new Error("Invalid idx to delete " + i); t.push({ op: "del", insertion: n }); let r = i + 1; for (; !this.mapping.opIDbeforeIdx[r] && r < g;)r++; i = r } this.core.makeTransaction(t, I), this.processNewTransactions() } toGraphemes(A) { return [...VI(A)] } fromGraphemes(A) { return A.join("") } } function JD(e) { const A = Math.ceil(je.MAX_RECOMMENDED_TX_SIZE / 200), g = []; for (let I = 0; I < e.length; I += A)g.push(e.slice(I, I + A)); return g } function HD(e, A) { return e.verified.header.type === "comap" ? e.verified.header.ruleset.type === "group" ? e.verified.header.meta?.type === "account" && !A?.ignorePrivateTransactions ? new at(e) : new wr(e, A) : new ur(e) : e.verified.header.type === "coplaintext" ? new vD(e) : e.verified.header.type === "colist" ? new cr(e) : e.verified.header.type === "costream" ? e.verified.header.meta && e.verified.header.meta.type === "binary" ? new dE(e) : new wE(e) : new AD(e) } function Dr(e, A = new Set) { return e.ruleset.type === "ownedByGroup" && A.add(e.ruleset.group), e.meta?.source && A.add(e.meta.source), A } function ME(e, A) { for (const g of e) { const I = YA(g); RI(I) && A.add(I) } } function fr(e, A = new Set) { for (const g of e) { if (g.privacy !== "trusting") continue; const I = qD(g.changes); for (const t of I) if (t && typeof t == "object" && "op" in t && t.op === "set" && "key" in t && t.key) { const i = lr(t.key); i && A.add(i) } } return A } function FE(e, A, g, I) { const t = new Set; if (Dr(A, t), ME(g, t), A.ruleset.type === "group") for (const i of I) fr(i, t); return t.delete(e), t } function LD(e, A) { const g = new Set; A.header && Dr(A.header, g); const I = Object.keys(A.new); if (ME(I, g), (e.verified?.header ?? A.header)?.ruleset.type === "group") for (const { newTransactions: i } of Object.values(A.new)) fr(i, g); return g.delete(e.id), g } function qD(e) { try { return Wg(e) } catch { return [] } } class bI { constructor(A, g, I) { this.id = A, this.crypto = g, this.sessions = new Map, this.knownState = { id: this.id, header: !0, sessions: {} }, I && (this.streamingKnownState = { ...I }, this.knownStateWithStreaming = { id: this.id, header: !0, sessions: { ...I } }) } setStreamingKnownState(A) { if (wo(A, this.knownState.sessions)) return; const g = uE(A, this.knownState.sessions); this.streamingKnownState ? Vg(this.streamingKnownState, g) : this.streamingKnownState = g, this.knownStateWithStreaming || (this.knownStateWithStreaming = ig(this.knownState)), Vg(this.knownStateWithStreaming.sessions, g) } invalidateKnownStateCache() { this.immutableKnownState = void 0, this.immutableKnownStateWithStreaming = void 0 } getImmutableKnownState() { return this.immutableKnownState || (this.immutableKnownState = ig(this.knownState)), this.immutableKnownState } getImmutableKnownStateWithStreaming() { return this.knownStateWithStreaming ? (this.immutableKnownStateWithStreaming || (this.immutableKnownStateWithStreaming = ig(this.knownStateWithStreaming)), this.immutableKnownStateWithStreaming) : this.getImmutableKnownState() } get(A) { return this.sessions.get(A) } getOrCreateSessionLog(A, g) { let I = this.sessions.get(A); return I || (I = { signerID: g, impl: this.crypto.createSessionLog(this.id, A, g), transactions: [], lastSignature: void 0, signatureAfter: {}, txSizeSinceLastInbetweenSignature: 0, sessionID: A }, this.sessions.set(A, I)), I } addTransaction(A, g, I, t, i = !1) { const n = this.getOrCreateSessionLog(A, g); n.impl.tryAdd(I, t, i), this.addTransactionsToJsLog(n, I, t) } makeNewPrivateTransaction(A, g, I, t, i, n, r) { const o = this.getOrCreateSessionLog(A, g.currentSignerID()), C = o.impl.addNewPrivateTransaction(g, I, t, i, r, n); return this.addTransactionsToJsLog(o, [C.transaction], C.signature), C } makeNewTrustingTransaction(A, g, I, t, i) { const n = this.getOrCreateSessionLog(A, g.currentSignerID()), r = n.impl.addNewTrustingTransaction(g, I, i, t); return this.addTransactionsToJsLog(n, [r.transaction], r.signature), r } addTransactionsToJsLog(A, g, I) { for (const i of g) A.transactions.push(i); A.lastSignature = I, A.txSizeSinceLastInbetweenSignature += g.reduce((i, n) => i + (n.privacy === "private" ? n.encryptedChanges.length : n.changes.length), 0); const t = A.transactions.length; Vt(A.txSizeSinceLastInbetweenSignature) && (A.signatureAfter[t - 1] = I, A.txSizeSinceLastInbetweenSignature = 0), lo(this.knownState.sessions, A.sessionID, t), this.streamingKnownState && wo(this.streamingKnownState, this.knownState.sessions) && (this.streamingKnownState = void 0, this.knownStateWithStreaming = void 0), this.knownStateWithStreaming && lo(this.knownStateWithStreaming.sessions, A.sessionID, t), this.invalidateKnownStateCache() } decryptTransaction(A, g, I) { const t = this.sessions.get(A); if (!t) return; const i = t.impl.decryptNextTransactionChangesJson(g, I); if (i) return Wg(i) } decryptTransactionMeta(A, g, I) { const t = this.sessions.get(A); if (!t?.transactions[g]?.meta) return; const i = t.impl.decryptNextTransactionMetaJson(g, I); if (i) return Wg(i) } get size() { return this.sessions.size } entries() { return this.sessions.entries() } values() { return this.sessions.values() } keys() { return this.sessions.keys() } clone() { const A = new bI(this.id, this.crypto); for (const [g, I] of this.sessions) A.sessions.set(g, { impl: I.impl.clone(), transactions: I.transactions.slice(), lastSignature: I.lastSignature, signatureAfter: { ...I.signatureAfter }, txSizeSinceLastInbetweenSignature: I.txSizeSinceLastInbetweenSignature, signerID: I.signerID, sessionID: g }); return A.streamingKnownState = this.streamingKnownState ? { ...this.streamingKnownState } : void 0, A.knownState = ig(this.knownState), A.knownStateWithStreaming = this.knownStateWithStreaming ? ig(this.knownStateWithStreaming) : void 0, A } } class yr { constructor(A, g, I, t) { this.id = A, this.crypto = g, this.header = I, this.sessions = t ?? new bI(A, g), this.branchSourceId = I.meta?.source, this.branchName = I.meta?.branch } clone() { return new yr(this.id, this.crypto, this.header, this.sessions.clone()) } tryAddTransactions(A, g, I, t, i = !1) { this.sessions.addTransaction(A, g, I, t, i) } makeNewTrustingTransaction(A, g, I, t, i) { return this.sessions.makeNewTrustingTransaction(A, g, I, t, i) } makeNewPrivateTransaction(A, g, I, t, i, n, r) { return this.sessions.makeNewPrivateTransaction(A, g, I, t, i, n, r) } getLastSignatureCheckpoint(A) { const g = this.sessions.get(A); return g?.signatureAfter ? Object.keys(g.signatureAfter).reduce((I, t) => Math.max(I, parseInt(t)), -1) : -1 } setStreamingKnownState(A) { this.sessions.setStreamingKnownState(A) } newContentSince(A) { let g = Lg(this.id, this.header, !1); const I = [g]; let t = 0; const i = () => { g = Lg(this.id, this.header, !1), I.push(g), t = 0 }, n = Q => { const s = g.new[Q]; if (!s) throw new Error("Session content not found", { cause: { sessionID: Q, currentPiece: g } }); delete g.new[Q]; const E = Lg(this.id, this.header, !1); E.new[Q] = s, I.splice(I.length - 1, 0, E) }, r = A?.sessions; for (const [Q, s] of this.sessions.sessions) { const E = r?.[Q] ?? 0; let a = 0; for (let c = E; c < s.transactions.length; c++) { const u = c === s.transactions.length - 1, h = s.transactions[c]; a += st(h); const d = s.signatureAfter[c]; if (d) jI(g, h, Q, d, c), n(Q), a = 0; else if (u) { if (!s.lastSignature) throw new Error("All the SessionLogs sent must have a lastSignature", { cause: s }); jI(g, h, Q, s.lastSignature, c), Vt(a) ? (WI(Q, g), n(Q)) : Vt(t, a) ? (WI(Q, g), i()) : t += a } else jI(g, h, Q, void 0, c) } WI(Q, g) } const o = I[0]; if (!o) throw new Error("First piece not found", { cause: I }); !A?.header && (o.header = this.header); const B = I.filter(Q => Q.header || Object.keys(Q.new).length > 0); if ((B.length > 1 || this.isStreaming()) && (A ? o.expectContentUntil = uE(this.knownStateWithStreaming().sessions, A.sessions) : o.expectContentUntil = { ...this.knownStateWithStreaming().sessions }), B.length !== 0) return B } knownState() { return this.sessions.knownState } knownStateWithStreaming() { return this.sessions.knownStateWithStreaming ?? this.knownState() } immutableKnownState() { return this.sessions.getImmutableKnownState() } immutableKnownStateWithStreaming() { return this.sessions.getImmutableKnownStateWithStreaming() } isStreaming() { return !!this.sessions.knownStateWithStreaming } decryptTransaction(A, g, I) { return this.sessions.decryptTransaction(A, g, I) } decryptTransactionMeta(A, g, I) { return this.sessions.decryptTransactionMeta(A, g, I) } } function WI(e, A) { if (A.new[e] && !A.new[e].lastSignature) throw new Error("The SessionContent sent must have a lastSignature", { cause: A.new[e] }) } function UE({ type: e, branchName: A, ownerId: g, sourceId: I }) { return { type: e, meta: { branch: A, source: I }, ruleset: { type: "ownedByGroup", group: g }, uniqueness: "" } } function pr(e) { return e.verified?.header.ruleset.type === "ownedByGroup" } function xD(e, A, g) { if (!e.verified) throw new Error("CoValueCore: getBranchId called on coValue without verified state"); const I = g ?? mr(e); if (!I) return e.id; const t = UE({ type: e.verified.header.type, branchName: A, ownerId: I, sourceId: e.id }); return _g(t, e.node.crypto) } function mr(e) { if (!e.verified) throw new Error("CoValueCore: getBranchOwnerId called on coValue without verified state"); const A = e.verified.header; if (A.ruleset.type === "ownedByGroup") return A.ruleset.group } function zD(e, A, g) { if (!e.verified) throw new Error("CoValueCore: createBranch called on coValue without verified state"); const I = g ?? mr(e); if (!I) return e; const t = e.safeGetGroup()?.myRole(); if (!t || t === "reader" && !g) return x.warn("Trying to create a branch without enough access rights, returning the source coValue"), e; const i = t === "reader" ? "trusting" : "private", n = UE({ type: e.verified.header.type, branchName: A, ownerId: I, sourceId: e.id }), r = e.node.createCoValue(n), o = { ...e.knownState().sessions }; return r.makeTransaction([], "private", { from: o }), e.makeTransaction([], i, { branch: A, ownerId: g }), r } function RE(e) { if (!e.verified) return; const A = e.getCurrentBranchSourceId(); if (!A) return; const g = e.node.getCoValue(A); if (g.isAvailable()) return g } function OD(e) { if (!e.verified) throw new Error("CoValueCore: mergeBranch called on coValue without verified state"); if (!pr(e)) return e; const A = RE(e); if (!A) throw new Error("CoValueCore: unable to find source branch"); let g = {}; for (const Q of A.getMergeCommits()) Q.branch === e.id && Vg(g, Q.merged); const I = e.getValidTransactions({ from: g, ignorePrivateTransactions: !1, skipBranchSource: !0 }).filter(Q => Q.changes.length > 0); if (I.length === 0) return A; let t, i, n = 0; const r = Date.now(); for (const Q of I) { const s = { mi: Q.txID.txIndex }; Q.madeAt !== n && (s.t = r - Q.madeAt), t !== Q.txID.sessionID && (s.s = Q.txID.sessionID), i !== Q.txID.branch && (s.b = Q.txID.branch), A.makeTransaction(Q.changes, Q.tx.privacy, s, r), t = Q.txID.sessionID, i = Q.txID.branch, n = Q.madeAt } const o = e.knownState().sessions, C = g, B = {}; for (const [Q, s] of Object.entries(o)) (C[Q] ?? 0) < s && (B[Q] = s); return A.makeTransaction([], "private", { merged: B, branch: e.id }), A } function jD(e, A) { if (!A.isValid || A.tx.privacy === "trusting") return; const g = !A.changes, I = !A.meta && A.tx.meta; if (!g && !I) return; const t = e.getReadKey(A.tx.keyUsed); if (t) { if (g) { const i = e.verified.decryptTransaction(A.txID.sessionID, A.txID.txIndex, t); i && (A.changes = i) } if (I) { const i = e.verified.decryptTransactionMeta(A.txID.sessionID, A.txID.txIndex, t); i && (A.meta = i) } } } var $e = function (e, A, g, I, t) { if (I === "m") throw new TypeError("Private method is not writable"); if (I === "a" && !t) throw new TypeError("Private accessor was defined without a setter"); if (typeof A == "function" ? e !== A || !t : !A.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return I === "a" ? t.call(e, g) : t ? t.value = g : A.set(e, g), g }, XI = function (e, A, g, I) { if (g === "a" && !I) throw new TypeError("Private accessor was defined without a getter"); if (typeof A == "function" ? e !== A || !I : !A.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return g === "m" ? I : g === "a" ? I.call(e) : I ? I.value : A.get(e) }, Rg, bg, Yg; function _g(e, A) { return `co_z${A.shortHash(e).slice(11)}` } let bE = !1; function TD() { bE = !0 } class ZD { constructor(A, g, I, t, i, n, r, o) { this.isValidated = !1, this.isValid = !1, this.validationErrorMessage = void 0, this.dispatchTransaction = o, this.author = YA(g); const C = i ? { sessionID: g, txIndex: I, branch: i } : { sessionID: g, txIndex: I }; this.coValueId = A, this.currentTxID = C, this.sourceTxID = void 0, this.tx = t, this.currentMadeAt = t.madeAt, this.sourceTxMadeAt = void 0, this.previous = r, n ? (this.changes = n.changes, this.meta = n.meta) : this.tx.privacy === "trusting" && (this.changes = fo(this.tx.changes), this.tx.meta && (this.meta = fo(this.tx.meta))) } get txID() { return this.sourceTxID ?? this.currentTxID } get madeAt() { return this.sourceTxMadeAt ?? this.currentMadeAt } isValidTransactionWithChanges() { return !!(this.isValid && this.changes) } markValid() { this.isValid = !0, this.validationErrorMessage = void 0, this.isValidated || (this.isValidated = !0, this.dispatchTransaction(this)) } markInvalid(A, g) { this.isValidated = !0, this.isValid = !1, this.validationErrorMessage = A, bE === !0 && x.error("Invalid transaction: " + A, { coValueId: this.coValueId, txID: this.txID, author: this.author, ...g }) } } class PD { get verified() { return this._verified } constructor(A, g) { this.loadingStatuses = new Map, this.listeners = new Set, this.missingDependencies = new Set, this.newContentQueue = [], Rg.set(this, !1), bg.set(this, !1), Yg.set(this, !1), this.mergeCommits = [], this.branches = [], this.earliestTxMadeAt = Number.MAX_SAFE_INTEGER, this.latestTxMadeAt = 0, this.verifiedTransactions = [], this.toValidateTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this.toProcessTransactions = [], this.verifiedTransactionsKnownSessions = {}, this.lastVerifiedTransactionBySessionID = {}, this.parsingCache = new Map, this.dispatchTransaction = I => { if (!I.isValidated) { this.toValidateTransactions.push(I); return } I.changes ? this.toProcessTransactions.push(I) : this.toDecryptTransactions.push(I), I.meta && this.toParseMetaTransactions.push(I) }, this.dependencies = new Set, this.incompleteDependencies = new Set, this.dependant = new Set, this.readKeyCache = new Map, this.crypto = g.crypto, this.id = A, this._verified = null, this.node = g, this.counter = se.getMeter("cojson").createUpDownCounter("jazz.covalues.loaded", { description: "The number of covalues in the system", unit: "covalue", valueType: jA.INT }), this.updateCounter(null) } get loadingState() { if (this.verified) return "available"; if (this.loadingStatuses.size === 0) return "unknown"; for (const A of this.loadingStatuses.values()) { if (A.type === "pending") return "loading"; if (A.type === "unknown") return "unknown" } return "unavailable" } hasMissingDependencies() { return this.missingDependencies.size > 0 } isAvailable() { return this.hasVerifiedContent() } isCompletelyDownloaded() { return !(!this.hasVerifiedContent() || this.isStreaming() || this.incompleteDependencies.size > 0) } isStreaming() { return this.verified?.isStreaming() ?? !1 } hasVerifiedContent() { return !!this.verified } newContentSince(A) { return this.verified?.newContentSince(A) } isErroredInPeer(A) { return this.getLoadingStateForPeer(A) === "errored" } waitFor(A) { const { predicate: g, onSuccess: I } = A; this.subscribe((t, i) => { g(t) && (i(), I(t)) }, !0) } waitForAsync(A) { return new Promise(g => { this.waitFor({ predicate: A, onSuccess: g }) }) } waitForAvailableOrUnavailable() { return this.waitForAsync(A => A.isAvailable() || A.loadingState === "unavailable") } waitForAvailable() { return this.waitForAsync(A => A.isAvailable()) } waitForFullStreaming() { return this.waitForAsync(A => A.isAvailable() && !A.isStreaming()) } getLoadingStateForPeer(A) { return this.loadingStatuses.get(A)?.type ?? "unknown" } updateCounter(A) { const g = this.loadingState; A !== g && (A && this.counter.add(-1, { state: A }), this.counter.add(1, { state: g })) } unmount(A = !1) { return !A && this.verified?.header.ruleset.type === "group" || this.listeners.size > 0 ? !1 : (this.counter.add(-1, { state: this.loadingState }), this.groupInvalidationSubscription && (this.groupInvalidationSubscription(), this.groupInvalidationSubscription = void 0), this.node.internalDeleteCoValue(this.id), !0) } markNotFoundInPeer(A) { const g = this.loadingState; this.loadingStatuses.set(A, { type: "unavailable" }), this.updateCounter(g), this.scheduleNotifyUpdate() } markFoundInPeer(A, g) { this.loadingStatuses.set(A, { type: "available" }), this.updateCounter(g), this.scheduleNotifyUpdate() } isCircularDependency(A) { if (A.id === this.id) return !0; const g = new Set, I = [A]; for (; I.length > 0;) { const t = I.pop(); if (!t) return !1; g.add(t.id); for (const i of t.dependencies) { if (i === this.id) return !0; g.has(i) || I.push(this.node.getCoValue(i)) } } return !1 } addNewContentToQueue(A, g) { const I = this.newContentQueue.length > 0; this.newContentQueue.push({ msg: A, from: g }), !I && this.waitFor({ predicate: t => !t.hasMissingDependencies(), onSuccess: () => { const t = this.newContentQueue; this.newContentQueue = []; for (const { msg: i, from: n } of t) this.node.syncManager.handleNewContent(i, n) } }) } addDependencyFromHeader(A) { for (const g of Dr(A)) this.addDependency(g) } provideHeader(A, g, I) { if (!I) { const t = _g(A, this.node.crypto); if (this.id !== t) return !1 } if (this.addDependencyFromHeader(A), this._verified?.sessions.size) throw new Error("CoValueCore: provideHeader called on coValue with verified sessions present!"); return this._verified = new yr(this.id, this.node.crypto, A, new bI(this.id, this.node.crypto, g)), !0 } markErrored(A, g) { const I = this.loadingState; this.loadingStatuses.set(A, { type: "errored", error: g }), this.updateCounter(I), this.scheduleNotifyUpdate() } markPending(A) { const g = this.loadingState; this.loadingStatuses.set(A, { type: "pending" }), this.updateCounter(g), this.scheduleNotifyUpdate() } subscribeToGroupInvalidation() { if (!this.verified || this.groupInvalidationSubscription) return; const A = this.verified.header; if (A.ruleset.type == "ownedByGroup") { const g = A.ruleset.group, I = this.node.getCoValue(g); I.isAvailable() ? this.groupInvalidationSubscription = I.subscribe(t => { this.resetParsedTransactions(), this.scheduleNotifyUpdate() }, !1) : x.error("CoValueCore: Owner group not available", { id: this.id, groupId: g }) } } contentInClonedNodeWithDifferentAccount(A) { return this.node.loadCoValueAsDifferentAgent(this.id, A.agentSecret, A.id).then(g => g.getCurrentContent()) } knownStateWithStreaming() { return this.verified?.immutableKnownStateWithStreaming() ?? Te(this.id) } knownState() { return this.verified?.immutableKnownState() ?? Te(this.id) } get meta() { return this.verified?.header.meta ?? null } nextTransactionID() { if (!this.verified) throw new Error("CoValueCore: nextTransactionID called on coValue without verified state"); const A = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID; return { sessionID: A, txIndex: this.verified.sessions.get(A)?.transactions.length || 0 } } addDependenciesFromContentMessage(A) { const g = LD(this, A); for (const I of g) this.addDependency(I) } tryAddTransactions(A, g, I, t = !1) { let i; if (!t) { const n = this.node.resolveAccountAgent(YA(A), "Expected to know signer of transaction"); if (n.error || !n.value) return { type: "ResolveAccountAgentError", id: this.id, error: n.error }; i = this.crypto.getAgentSignerID(n.value) } if (!this.verified) return { type: "TriedToAddTransactionsWithoutVerifiedState", id: this.id, error: void 0 }; try { this.verified.tryAddTransactions(A, i, g, I, t), this.processNewTransactions(), this.scheduleNotifyUpdate() } catch (n) { return { type: "InvalidSignature", id: this.id, error: n } } } processNewTransactions() { this._cachedContent && this._cachedContent.processNewTransactions() } scheduleNotifyUpdate() { this.listeners.size !== 0 && ($e(this, bg, !0, "f"), XI(this, Rg, "f") || ($e(this, Rg, !0, "f"), queueMicrotask(() => { $e(this, Rg, !1, "f"), XI(this, bg, "f") && this.notifyUpdate() }))) } pauseNotifyUpdate() { $e(this, Yg, !0, "f") } resumeNotifyUpdate() { $e(this, Yg, !1, "f"), this.notifyUpdate() } notifyUpdate() { if (!(this.listeners.size === 0 || XI(this, Yg, "f"))) { $e(this, bg, !1, "f"); for (const A of this.listeners) try { A(this, () => { this.listeners.delete(A) }) } catch (g) { x.error("Error in listener for coValue " + this.id, { err: g }) } } } subscribe(A, g = !0) { return this.listeners.add(A), g && A(this, () => { this.listeners.delete(A) }), () => { this.listeners.delete(A) } } makeTransaction(A, g, I, t) { if (!this.verified) throw new Error("CoValueCore: makeTransaction called on coValue without verified state"); Wd(A); const i = this.verified.header.meta?.type === "account" ? this.node.currentSessionID.replace(this.node.getCurrentAgent().id, this.node.getCurrentAgent().currentAgentID()) : this.node.currentSessionID, n = this.node.getCurrentAgent(); let r; const o = this.knownState(); if (g === "private") { const { secret: B, id: Q } = this.getCurrentReadKey(); if (!B) throw new Error("Can't make transaction without read key secret"); r = this.verified.makeNewPrivateTransaction(i, n, A, Q, B, I, t ?? Date.now()) } else r = this.verified.makeNewTrustingTransaction(i, n, A, I, t ?? Date.now()); const { transaction: C } = r; return this.parsingCache.set(C, { changes: A, meta: I }), this.node.syncManager.recordTransactionsSize([C], "local"), this.processNewTransactions(), this.addDependenciesFromNewTransaction(C), this.notifyUpdate(), this.node.syncManager.syncLocalTransaction(this.verified, o), !0 } addDependenciesFromNewTransaction(A) { if (this.verified?.header.ruleset.type === "group") for (const g of fr([A])) this.addDependency(g) } getCurrentContent(A) { if (!this.verified) throw new Error("CoValueCore: getCurrentContent called on coValue without verified state"); if (!A?.ignorePrivateTransactions && this._cachedContent) return this._cachedContent; const g = HD(this, A); return this.subscribeToGroupInvalidation(), A?.ignorePrivateTransactions || (this._cachedContent = g), g } resetParsedTransactions() { this.branchStart = void 0, this.mergeCommits = []; for (const A of this.verifiedTransactions) A.isValidated = !1; this.toValidateTransactions = this.verifiedTransactions.slice(), this.toProcessTransactions = [], this.toDecryptTransactions = [], this.toParseMetaTransactions = [], this._cachedContent?.rebuildFromCore() } loadVerifiedTransactionsFromLogs() { if (!this.verified) return; const A = this.isBranched(); for (const [g, I] of this.verified.sessions.entries()) { const t = this.verifiedTransactionsKnownSessions[g] ?? 0; for (let i = t; i < I.transactions.length; i++) { const n = I.transactions[i]; if (!n) continue; const r = this.parsingCache.get(n); r && this.parsingCache.delete(n); const o = new ZD(this.id, g, i, n, A ? this.id : void 0, r, this.lastVerifiedTransactionBySessionID[g], this.dispatchTransaction); o.madeAt > this.latestTxMadeAt && (this.latestTxMadeAt = o.madeAt), o.madeAt < this.earliestTxMadeAt && (this.earliestTxMadeAt = o.madeAt), this.verifiedTransactions.push(o), this.dispatchTransaction(o), this.lastVerifiedTransactionBySessionID[g] = o } this.verifiedTransactionsKnownSessions[g] = I.transactions.length } } determineValidTransactions() { hD(this), this.toValidateTransactions = [] } parseMetaInformation(A) { if (A.meta) { if (this.isBranched() && "from" in A.meta) { const g = A.meta; this.branchStart ? this.branchStart = Vg(this.branchStart, g.from) : this.branchStart = g.from } if ("branch" in A.meta) { const g = A.meta; this.branches.push(g) } if ("merged" in A.meta) { const g = A.meta; this.mergeCommits.push(g) } if ("mi" in A.meta) { const g = A.meta, I = A.previous, t = g.s ?? I?.txID.sessionID; g.t ? A.sourceTxMadeAt = A.currentMadeAt - g.t : I && (A.sourceTxMadeAt = I.madeAt), A.sourceTxMadeAt && A.sourceTxMadeAt > A.currentMadeAt && A.markInvalid("Transaction sourceMadeAt is after the currentMadeAt", { sourceTxMadeAt: A.sourceTxMadeAt, currentMadeAt: A.currentMadeAt }), t ? A.sourceTxID = { sessionID: t, txIndex: g.mi, branch: g.b ?? I?.txID.branch } : x.error("Merge commit without session ID", { txID: A.txID, prevTxID: I?.txID ?? null }) } } } parseNewTransactions(A) { if (!this.isAvailable()) return; if (this.loadVerifiedTransactionsFromLogs(), this.determineValidTransactions(), !A) { const I = this.toDecryptTransactions; this.toDecryptTransactions = []; for (const t of I) jD(this, t), this.dispatchTransaction(t) } const g = this.toParseMetaTransactions; this.toParseMetaTransactions = []; for (const I of g) this.parseMetaInformation(I) } getValidTransactions(A) { if (!this.verified) return []; this.parseNewTransactions(A?.ignorePrivateTransactions ?? !1); const g = [], I = RE(this), t = A?.from, i = A?.to, n = A?.knownTransactions?.[this.id] ?? 0; for (let r = n; r < this.toProcessTransactions.length; r++) { const o = this.toProcessTransactions[r]; if (!o.isValidTransactionWithChanges()) continue; const C = o.currentTxID, B = t?.[C.sessionID] ?? -1, Q = i?.[C.sessionID] ?? 1 / 0; B > C.txIndex || Q < C.txIndex || g.push(o) } if (A?.knownTransactions !== void 0 && (A.knownTransactions[this.id] = this.toProcessTransactions.length), I && this.branchStart && !A?.skipBranchSource) { const r = I.getValidTransactions({ knownTransactions: A?.knownTransactions, to: this.branchStart, ignorePrivateTransactions: A?.ignorePrivateTransactions ?? !1 }); for (const o of r) g.push(o) } return g } addDependency(A) { const g = this.node.getCoValue(A); this.isCircularDependency(g) || this.dependencies.has(A) || (this.dependencies.add(A), g.addDependant(this.id), g.isCompletelyDownloaded() || (this.incompleteDependencies.add(g.id), g.waitFor({ predicate: I => I.isCompletelyDownloaded(), onSuccess: () => { this.incompleteDependencies.delete(g.id), this.incompleteDependencies.size === 0 && this.notifyUpdate() } })), g.isAvailable() || (this.missingDependencies.add(g.id), g.waitFor({ predicate: I => I.isAvailable(), onSuccess: () => { this.missingDependencies.delete(g.id), this.missingDependencies.size === 0 && this.notifyUpdate() } }))) } addDependant(A) { this.dependant.add(A) } isGroup() { return !(!this.verified || this.verified.header.ruleset.type !== "group" || this.verified.header.meta?.type === "account") } createBranch(A, g) { return zD(this, A, g) } mergeBranch() { return OD(this) } getBranch(A, g) { return this.node.getCoValue(xD(this, A, g)) } getCurrentBranchName() { return this.verified?.branchName } getCurrentBranchSourceId() { return this.verified?.branchSourceId } isBranched() { return !!this.verified?.branchSourceId } hasBranch(A, g) { this.parseNewTransactions(!1); const I = mr(this); return this.branches.some(t => { if (t.branch !== A) return !1; if (t.ownerId === g) return !0; if (!g) return t.ownerId === I; if (!t.ownerId) return g === I }) } getMergeCommits() { return this.mergeCommits } getValidSortedTransactions(A) { const g = this.getValidTransactions(A); return g.sort(this.compareTransactions), g } compareTransactions(A, g) { return A.madeAt !== g.madeAt ? A.madeAt - g.madeAt : A.txID.sessionID === g.txID.sessionID ? A.txID.txIndex - g.txID.txIndex : 0 } getCurrentReadKey() { if (!this.verified) throw new Error("CoValueCore: getCurrentReadKey called on coValue without verified state"); if (this.verified.header.ruleset.type === "group") return wA(this.getCurrentContent()).getCurrentReadKey(); if (this.verified.header.ruleset.type === "ownedByGroup") return this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentReadKey(); throw new Error("Only groups or values owned by groups have read secrets") } getReadKey(A) { const g = this.readKeyCache.get(A); if (g) return g; if (!this.verified) throw new Error("CoValueCore: getUncachedReadKey called on coValue without verified state"); if (this.verified.header.ruleset.type === "group") return wA(this.getCurrentContent({ ignorePrivateTransactions: !0 })).getReadKey(A); if (this.verified.header.ruleset.type === "ownedByGroup") return wA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()).getReadKey(A); throw new Error("Only groups or values owned by groups have read secrets") } safeGetGroup() { if (!this.verified) throw new Error("CoValueCore: getGroup called on coValue without verified state"); if (this.verified.header.ruleset.type === "ownedByGroup") return wA(this.node.expectCoValueLoaded(this.verified.header.ruleset.group).getCurrentContent()) } getGroup() { const A = this.safeGetGroup(); if (!A) throw new Error("Only values owned by groups have groups"); return A } getTx(A) { return this.verified?.sessions.get(A.sessionID)?.transactions[A.txIndex] } getDependedOnCoValues() { return this.dependencies } waitForSync(A) { return this.node.syncManager.waitForSync(this.id, A?.timeout) } load(A) { this.loadFromStorage(g => { g || this.loadFromPeers(A) }) } loadFromStorage(A) { const g = this.node; if (!g.storage) { A?.(!1); return } const I = this.getLoadingStateForPeer("storage"); if (I === "pending") { if (!A) return; this.subscribe((t, i) => { const n = t.getLoadingStateForPeer("storage"); n === "available" || t.isAvailable() ? (i(), A(!0)) : (n === "errored" || n === "unavailable") && (i(), A(!1)) }); return } if (I !== "unknown") { A?.(I === "available"); return } this.markPending("storage"), g.storage.load(this.id, t => { g.syncManager.handleNewContent(t, "storage") }, t => { A?.(t), t || this.markNotFoundInPeer("storage") }) } loadFromPeers(A) { if (A.length !== 0) for (const g of A) { const I = this.getLoadingStateForPeer(g.id); (I === "unknown" || I === "unavailable") && (this.markPending(g.id), this.internalLoadFromPeer(g)) } } internalLoadFromPeer(A) { if (A.closed && !A.persistent) { this.markNotFoundInPeer(A.id); return } A.closed || (A.pushOutgoingMessage({ action: "load", ...this.knownState() }), A.trackLoadRequestSent(this.id)); const g = () => { this.getLoadingStateForPeer(A.id) === "pending" && (x.warn("Timeout waiting for peer to load coValue", { id: this.id, peerID: A.id }), this.markNotFoundInPeer(A.id)) }, I = setTimeout(g, Pg.TIMEOUT), t = A.persistent ? void 0 : A.addCloseListener(g); this.subscribe((i, n) => { const r = i.getLoadingStateForPeer(A.id); (i.isAvailable() || r === "available" || r === "errored" || r === "unavailable") && (n(), t?.(), clearTimeout(I)) }, !0) } } Rg = new WeakMap, bg = new WeakMap, Yg = new WeakMap; class VD { constructor(A, g) { this.coValues = A, this.garbageCollectGroups = g, this.interval = setInterval(() => { this.collect() }, ho.INTERVAL) } getCurrentTime() { return performance.now() } trackCoValueAccess({ verified: A }) { A && (A.lastAccessed = this.getCurrentTime()) } collect() { const A = this.getCurrentTime(); for (const g of this.coValues.values()) { const { verified: I } = g; if (!I?.lastAccessed) continue; A - I.lastAccessed > ho.MAX_AGE && g.unmount(this.garbageCollectGroups) } } stop() { clearInterval(this.interval) } } const Ag = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0; function YI(e) { return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array" } function AI(e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e) } function ge(e, ...A) { if (!YI(e)) throw new Error("Uint8Array expected"); if (A.length > 0 && !A.includes(e.length)) throw new Error("Uint8Array expected of length " + A + ", got length=" + e.length) } function $g(e, A = !0) { if (e.destroyed) throw new Error("Hash instance has been destroyed"); if (A && e.finished) throw new Error("Hash#digest() has already been called") } function Nr(e, A) { ge(e); const g = A.outputLen; if (e.length < g) throw new Error("digestInto() expects output buffer of length at least " + g) } function WD(e) { return new Uint8Array(e.buffer, e.byteOffset, e.byteLength) } function eI(e) { return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)) } function Le(...e) { for (let A = 0; A < e.length; A++)e[A].fill(0) } function _I(e) { return new DataView(e.buffer, e.byteOffset, e.byteLength) } function gI(e, A) { return e << 32 - A | e >>> A } const YE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68; function KE(e) { return e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255 } const XD = YE ? e => e : e => KE(e); function _D(e) { for (let A = 0; A < e.length; A++)e[A] = KE(e[A]); return e } const kA = YE ? e => e : _D, vE = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", $D = Array.from({ length: 256 }, (e, A) => A.toString(16).padStart(2, "0")); function kr(e) { if (ge(e), vE) return e.toHex(); let A = ""; for (let g = 0; g < e.length; g++)A += $D[e[g]]; return A } const ne = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; function So(e) { if (e >= ne._0 && e <= ne._9) return e - ne._0; if (e >= ne.A && e <= ne.F) return e - (ne.A - 10); if (e >= ne.a && e <= ne.f) return e - (ne.a - 10) } function JE(e) { if (typeof e != "string") throw new Error("hex string expected, got " + typeof e); if (vE) return Uint8Array.fromHex(e); const A = e.length, g = A / 2; if (A % 2) throw new Error("hex string expected, got unpadded hex of length " + A); const I = new Uint8Array(g); for (let t = 0, i = 0; t < g; t++, i += 2) { const n = So(e.charCodeAt(i)), r = So(e.charCodeAt(i + 1)); if (n === void 0 || r === void 0) { const o = e[i] + e[i + 1]; throw new Error('hex string expected, got non-hex character "' + o + '" at index ' + i) } I[t] = n * 16 + r } return I } function Af(e) { if (typeof e != "string") throw new Error("string expected"); return new Uint8Array(new TextEncoder().encode(e)) } function hg(e) { return typeof e == "string" && (e = Af(e)), ge(e), e } function Mo(...e) { let A = 0; for (let I = 0; I < e.length; I++) { const t = e[I]; ge(t), A += t.length } const g = new Uint8Array(A); for (let I = 0, t = 0; I < e.length; I++) { const i = e[I]; g.set(i, t), t += i.length } return g } class HE { } function ef(e) { const A = I => e().update(hg(I)).digest(), g = e(); return A.outputLen = g.outputLen, A.blockLen = g.blockLen, A.create = () => e(), A } function gf(e) { const A = (I, t) => e(t).update(hg(I)).digest(), g = e({}); return A.outputLen = g.outputLen, A.blockLen = g.blockLen, A.create = I => e(I), A } function LE(e = 32) { if (Ag && typeof Ag.getRandomValues == "function") return Ag.getRandomValues(new Uint8Array(e)); if (Ag && typeof Ag.randomBytes == "function") return Uint8Array.from(Ag.randomBytes(e)); throw new Error("crypto.getRandomValues must be defined") } function tf(e, A, g, I) { if (typeof e.setBigUint64 == "function") return e.setBigUint64(A, g, I); const t = BigInt(32), i = BigInt(4294967295), n = Number(g >> t & i), r = Number(g & i), o = I ? 4 : 0, C = I ? 0 : 4; e.setUint32(A + o, n, I), e.setUint32(A + C, r, I) } class If extends HE { constructor(A, g, I, t) { super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = A, this.outputLen = g, this.padOffset = I, this.isLE = t, this.buffer = new Uint8Array(A), this.view = _I(this.buffer) } update(A) { $g(this), A = hg(A), ge(A); const { view: g, buffer: I, blockLen: t } = this, i = A.length; for (let n = 0; n < i;) { const r = Math.min(t - this.pos, i - n); if (r === t) { const o = _I(A); for (; t <= i - n; n += t)this.process(o, n); continue } I.set(A.subarray(n, n + r), this.pos), this.pos += r, n += r, this.pos === t && (this.process(g, 0), this.pos = 0) } return this.length += A.length, this.roundClean(), this } digestInto(A) { $g(this), Nr(A, this), this.finished = !0; const { buffer: g, view: I, blockLen: t, isLE: i } = this; let { pos: n } = this; g[n++] = 128, Le(this.buffer.subarray(n)), this.padOffset > t - n && (this.process(I, 0), n = 0); for (let Q = n; Q < t; Q++)g[Q] = 0; tf(I, t - 8, BigInt(this.length * 8), i), this.process(I, 0); const r = _I(A), o = this.outputLen; if (o % 4) throw new Error("_sha2: outputLen should be aligned to 32bit"); const C = o / 4, B = this.get(); if (C > B.length) throw new Error("_sha2: outputLen bigger than state"); for (let Q = 0; Q < C; Q++)r.setUint32(4 * Q, B[Q], i) } digest() { const { buffer: A, outputLen: g } = this; this.digestInto(A); const I = A.slice(0, g); return this.destroy(), I } _cloneInto(A) { A || (A = new this.constructor), A.set(...this.get()); const { blockLen: g, buffer: I, length: t, finished: i, destroyed: n, pos: r } = this; return A.destroyed = n, A.finished = i, A.length = t, A.pos = r, t % g && A.buffer.set(I), A } clone() { return this._cloneInto() } } const nf = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), uA = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]); class Gr { constructor(A, g) { this.id = A, this.peerId = g, this.knownState = Te(A) } cloneWithoutOptimistic() { const A = new Gr(this.id, this.peerId); return A.set(this.knownState), A } updateHeader(A) { this.knownState.header = A, this.optimisticKnownState && (this.optimisticKnownState.header = A) } combineWith(A) { zI(this.knownState, A), this.optimisticKnownState && zI(this.optimisticKnownState, A) } combineOptimisticWith(A) { this.optimisticKnownState || (this.optimisticKnownState = ig(this.knownState)), zI(this.optimisticKnownState, A) } set(A) { A === "empty" ? (this.knownState.header = !1, this.knownState.sessions = {}) : (this.knownState.header = A.header, this.knownState.sessions = { ...A.sessions }), this.optimisticKnownState = void 0 } value() { return this.knownState } optimisticValue() { return this.optimisticKnownState ?? this.knownState } } class Sr { constructor(A, g) { this.peer = A, this.toldKnownState = new Set, this.loadRequestSent = new Set, this.listeners = new Set, this.closed = !1, this.closeListeners = new Set, this._knownStates = g ?? new Map } getKnownState(A) { return this._knownStates.get(A)?.value() } getOptimisticKnownState(A) { return this._knownStates.get(A)?.optimisticValue() } isCoValueSubscribedToPeer(A) { return this._knownStates.has(A) } newPeerStateFrom(A) { this.closed || this.gracefulShutdown(); const g = new Map; for (const I of this._knownStates.values()) g.set(I.id, I.cloneWithoutOptimistic()); return new Sr(A, g) } trackLoadRequestSent(A) { this.toldKnownState.add(A), this.loadRequestSent.add(A) } trackToldKnownState(A) { this.toldKnownState.add(A) } getOrCreateKnownState(A) { let g = this._knownStates.get(A); return g || (g = new Gr(A, this.peer.id), this._knownStates.set(A, g)), g } updateHeader(A, g) { const I = this.getOrCreateKnownState(A); I.updateHeader(g), this.triggerUpdate(A, I) } combineWith(A, g) { const I = this.getOrCreateKnownState(A); I.combineWith(g), this.triggerUpdate(A, I) } combineOptimisticWith(A, g) { const I = this.getOrCreateKnownState(A); I.combineOptimisticWith(g), this.triggerUpdate(A, I) } setKnownState(A, g) { const I = this.getOrCreateKnownState(A); I.set(g), this.triggerUpdate(A, I) } emitCoValueChange(A) { if (this.peer.role === "client" && !this.isCoValueSubscribedToPeer(A)) return; const g = this.getOrCreateKnownState(A); this.triggerUpdate(A, g) } triggerUpdate(A, g) { for (const I of this.listeners) I(A, g) } subscribeToKnownStatesUpdates(A) { return this.listeners.add(A), () => { this.listeners.delete(A) } } get id() { return this.peer.id } get role() { return this.peer.role } get priority() { return this.peer.priority } get incoming() { return this.peer.incoming } get persistent() { return this.peer.persistent } pushOutgoingMessage(A) { this.peer.outgoing.push(A) } addCloseListener(A) { return this.closed ? (A(), () => { }) : (this.closeListeners.add(A), () => { this.closeListeners.delete(A) }) } emitClose() { for (const A of this.closeListeners) A(); this.closeListeners.clear() } gracefulShutdown() { this.closed || (x.debug("Gracefully closing", { peerId: this.id, peerRole: this.role }), this.closed = !0, this.peer.outgoing.push("Disconnected"), this.peer.outgoing.close(), this.peer.incoming.close(), this.emitClose()) } } class rf { constructor(A) { this.syncManager = A, this.listeners = new Set, this.listenersByPeers = new Map } subscribeToUpdates(A) { return this.listeners.add(A), () => { this.listeners.delete(A) } } subscribeToPeerUpdates(A, g) { const I = this.listenersByPeers.get(A) ?? new Set; return I.size === 0 && this.listenersByPeers.set(A, I), I.add(g), () => { I.delete(g) } } triggerUpdate(A, g, I) { const t = this.listenersByPeers.get(A); if (!t?.size && !this.listeners.size) return; const i = { uploaded: this.getIsCoValueFullyUploadedIntoPeer(I, g) }; for (const n of this.listeners) n(A, I, i); if (t) for (const n of t) n(I, i) } isSynced(A, g) { const I = A.getKnownState(g); return I ? this.getIsCoValueFullyUploadedIntoPeer(I, g) : !1 } getIsCoValueFullyUploadedIntoPeer(A, g) { const I = this.syncManager.local.getCoValue(g); if (!I.hasVerifiedContent()) return !1; const t = I.verified.knownState(); return cE(t.sessions, A.sessions) } } class KI { constructor(A) { this.meter = A, this.head = void 0, this.tail = void 0, this.length = 0 } push(A) { const g = { value: A, next: void 0 }; if (this.head === void 0) this.head = g, this.tail = g; else if (this.tail) this.tail.next = g, this.tail = g; else throw new Error("LinkedList is corrupted"); this.length++, this.meter?.push() } shift() { if (!this.head) return; const A = this.head, g = A.value; return this.head = A.next, A.next = void 0, this.head === void 0 && (this.tail = void 0), this.length--, this.meter?.pull(), g } isEmpty() { return this.head === void 0 } } class of { constructor(A, g) { this.attrs = g, this.pullCounter = se.getMeter("cojson").createCounter(`${A}.pulled`, { description: "Number of messages pulled from the queue", valueType: jA.INT, unit: "1" }), this.pushCounter = se.getMeter("cojson").createCounter(`${A}.pushed`, { description: "Number of messages pushed to the queue", valueType: jA.INT, unit: "1" }), this.pullCounter.add(0, this.attrs), this.pushCounter.add(0, this.attrs) } pull() { this.pullCounter.add(1, this.attrs) } push() { this.pushCounter.add(1, this.attrs) } } function $I(e, A) { return new KI(new of("jazz.messagequeue." + e, A)) } class Cf { constructor() { this.currentQueue = 0, this.processing = !1, this.pullCounter = se.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pulled", { description: "Number of messages pulled from the queue", valueType: jA.INT, unit: "1" }), this.pushCounter = se.getMeter("cojson").createCounter("jazz.messagequeue.incoming.pushed", { description: "Number of messages pushed to the queue", valueType: jA.INT, unit: "1" }), this.pullCounter.add(0, { peerRole: "client" }), this.pushCounter.add(0, { peerRole: "client" }), this.pullCounter.add(0, { peerRole: "server" }), this.pushCounter.add(0, { peerRole: "server" }), this.queues = [], this.peerToQueue = new WeakMap } push(A, g) { const I = this.peerToQueue.get(g); if (I) I.push(A); else { const t = new KI; this.peerToQueue.set(g, t), this.queues.push([t, g]), t.push(A) } this.pushCounter.add(1, { peerRole: g.role }) } pull() { const A = this.queues[this.currentQueue]; if (!A) return; const [g, I] = A, t = g.shift(); if (g.isEmpty() ? (this.queues.splice(this.currentQueue, 1), this.peerToQueue.delete(I)) : this.currentQueue++, this.currentQueue >= this.queues.length && (this.currentQueue = 0), t) return this.pullCounter.add(1, { peerRole: I.role }), { msg: t, peer: I } } async processQueue(A) { this.processing = !0; let g, I = performance.now(); for (; g = this.pull();) { const { msg: t, peer: i } = g; try { A(t, i) } catch (r) { x.error("Error processing message", { err: r }) } performance.now() - I > EE.INCOMING_MESSAGES_TIME_BUDGET && await new Promise(r => setTimeout(r, 0)) } this.processing = !1 } } class Bf { constructor(A) { this.sync = A, this.batch = [], this.firstChunks = new Map, this.syncTransaction = (g, I) => { const t = this.lastUpdatedValue, i = this.lastUpdatedValueKnownState; if (t && i) { if (t.id === g.id) return; this.addContentToBatch(t, i) } this.lastUpdatedValue = g, this.lastUpdatedValueKnownState = I; for (const n of this.dirtyCoValuesTrackingSets) n.add(g.id); this.scheduleNextBatch() }, this.nextBatchScheduled = !1, this.dirtyCoValuesTrackingSets = new Set, this.trackDirtyCoValues = () => { const g = new Set; return this.dirtyCoValuesTrackingSets.add(g), { done: () => (this.dirtyCoValuesTrackingSets.delete(g), g) } } } addContentToBatch(A, g) { const I = A.newContentSince(g); if (I) for (const t of I) this.batch.push(t) } scheduleNextBatch() { this.nextBatchScheduled || (this.nextBatchScheduled = !0, queueMicrotask(() => { this.lastUpdatedValue && this.lastUpdatedValueKnownState && this.addContentToBatch(this.lastUpdatedValue, this.lastUpdatedValueKnownState); const A = this.batch; this.lastUpdatedValue = void 0, this.lastUpdatedValueKnownState = void 0, this.firstChunks = new Map, this.batch = [], this.nextBatchScheduled = !1; for (const g of A) this.sync(g) })) } } class qE { ignoreUnknownCoValuesFromServers() { this._ignoreUnknownCoValuesFromServers = !0 } constructor(A) { this.peers = {}, this.skipVerify = !1, this._ignoreUnknownCoValuesFromServers = !1, this.peersCounter = se.getMeter("cojson").createUpDownCounter("jazz.peers", { description: "Amount of connected peers", valueType: jA.INT, unit: "peer" }), this.messagesQueue = new Cf, this.syncQueue = new Bf(g => this.syncContent(g)), this.syncLocalTransaction = this.syncQueue.syncTransaction, this.trackDirtyCoValues = this.syncQueue.trackDirtyCoValues, this.local = A, this.syncState = new rf(this), this.transactionsSizeHistogram = se.getMeter("cojson").createHistogram("jazz.transactions.size", { description: "The size of transactions in a covalue", unit: "bytes", valueType: jA.INT }) } disableTransactionVerification() { this.skipVerify = !0 } getPeers(A) { return this.getServerPeers(A).concat(this.getClientPeers()) } getClientPeers() { return Object.values(this.peers).filter(A => A.role === "client") } getServerPeers(A, g) { const I = Object.values(this.peers).filter(t => t.role === "server" && t.id !== g); return this.serverPeerSelector ? this.serverPeerSelector(A, I) : I } handleSyncMessage(A, g) { if (!aD(A.id)) { const I = A.id ? "invalid" : "undefined"; x.warn(`Received sync message with ${I} id`, { msg: A }); return } if (g.role === "server" && this._ignoreUnknownCoValuesFromServers && !this.local.hasCoValue(A.id)) { x.warn(`Ignoring message ${A.action} on unknown coValue ${A.id} from peer ${g.id}`); return } if (this.local.getCoValue(A.id).isErroredInPeer(g.id)) { x.warn(`Skipping message ${A.action} on errored coValue ${A.id} from peer ${g.id}`); return } switch (A.action) { case "load": return this.handleLoad(A, g); case "known": return A.isCorrection ? this.handleCorrection(A, g) : this.handleKnownState(A, g); case "content": return this.handleNewContent(A, g); case "done": return; default: throw new Error(`Unknown message type ${A.action}`) } } sendNewContent(A, g, I = new Set) { if (I.has(A)) return; I.add(A); const t = this.local.getCoValue(A); if (!t.isAvailable()) return; if (g.role !== "server") for (const r of t.getDependedOnCoValues()) this.sendNewContent(r, g, I); const n = t.newContentSince(g.getOptimisticKnownState(A)); if (n) { for (const r of n) this.trySendToPeer(g, r); g.combineOptimisticWith(A, t.knownState()) } else g.toldKnownState.has(A) || this.trySendToPeer(g, { action: "known", ...t.knownStateWithStreaming() }); g.trackToldKnownState(A) } reconcileServerPeers() { const A = Object.values(this.peers).filter(g => g.role === "server"); for (const g of A) this.startPeerReconciliation(g) } startPeerReconciliation(A) { const g = [], I = new Set, t = i => { if (!I.has(i.id) && (I.add(i.id), this.getServerPeers(i.id).find(n => n.id === A.id) !== void 0)) { for (const n of i.getDependedOnCoValues()) { const r = this.local.getCoValue(n); r.isAvailable() && t(r) } g.push(i) } }; for (const i of this.local.allCoValues()) i.isAvailable() ? t(i) : A.loadRequestSent.has(i.id) || (A.trackLoadRequestSent(i.id), this.trySendToPeer(A, { action: "load", header: !1, id: i.id, sessions: {} })), A.getKnownState(i.id) || A.setKnownState(i.id, "empty"); for (const i of g) A.trackLoadRequestSent(i.id), this.trySendToPeer(A, { action: "load", ...i.knownState() }) } pushMessage(A, g) { this.messagesQueue.push(A, g), !this.messagesQueue.processing && this.messagesQueue.processQueue((I, t) => { this.handleSyncMessage(I, t) }) } addPeer(A, g = !1) { const I = this.peers[A.id], t = I ? I.newPeerStateFrom(A) : new Sr(A, void 0); this.peers[A.id] = t, this.peersCounter.add(1, { role: A.role }); const i = t.subscribeToKnownStatesUpdates((n, r) => { this.syncState.triggerUpdate(A.id, n, r.value()) }); !g && t.role === "server" && this.startPeerReconciliation(t), t.incoming.onMessage(n => { if (n === "Disconnected") { t.gracefulShutdown(); return } this.pushMessage(n, t) }), t.addCloseListener(() => { i(), this.peersCounter.add(-1, { role: A.role }), !A.persistent && this.peers[A.id] === t && this.removePeer(A.id) }) } removePeer(A) { const g = this.peers[A]; g && (g.closed || g.gracefulShutdown(), delete this.peers[g.id]) } trySendToPeer(A, g) { return A.pushOutgoingMessage(g) } handleLoad(A, g) { g.setKnownState(A.id, xI(A)); const I = this.local.getCoValue(A.id); if (I.isAvailable()) { this.sendNewContent(A.id, g); return } const t = this.getServerPeers(A.id, g.id); I.load(t); const i = () => { I.isAvailable() || (g.trackToldKnownState(A.id), this.trySendToPeer(g, { action: "known", id: A.id, header: !1, sessions: {} })) }; t.length > 0 || this.local.storage ? I.waitForAvailableOrUnavailable().then(i) : i() } handleKnownState(A, g) { const I = this.local.getCoValue(A.id); g.combineWith(A.id, xI(A)), g.getOptimisticKnownState(A.id)?.header || I.markNotFoundInPeer(g.id), I.isAvailable() && this.sendNewContent(A.id, g) } recordTransactionsSize(A, g) { for (const I of A) { const t = st(I); this.transactionsSizeHistogram.record(t, { source: g }) } } handleNewContent(A, g) { const I = this.local.getCoValue(A.id), t = g === "storage" || g === "import" ? void 0 : g, i = g === "storage" ? "storage" : g === "import" ? "import" : t?.role; if (t?.role === "client" && A.expectContentUntil && (A = { ...A, expectContentUntil: void 0 }), I.addDependenciesFromContentMessage(A), !this.skipVerify && I.hasMissingDependencies()) { I.addNewContentToQueue(A, g); for (const C of I.missingDependencies) { const B = this.local.getCoValue(C); if (!B.hasVerifiedContent()) { const Q = this.getServerPeers(C); t?.role === "client" && Q.push(t), B.load(Q) } } return } if (I.hasVerifiedContent()) A.expectContentUntil && I.verified.setStreamingKnownState(A.expectContentUntil); else { if (!A.header) { if (this.local.storage?.getKnownState(A.id)?.header) { I.loadFromStorage(s => { s ? this.handleNewContent(A, g) : x.error("Known CoValue not found in storage", { id: A.id }) }); return } t ? this.trySendToPeer(t, { action: "known", isCorrection: !0, id: A.id, header: !1, sessions: {} }) : x.error("Received new content with no header on a missing CoValue", { id: A.id }); return } const C = I.loadingState; if (!I.provideHeader(A.header, A.expectContentUntil, this.skipVerify)) { x.error("Failed to provide header", { id: A.id, header: A.header }); return } I.markFoundInPeer(t?.id ?? "storage", C), t?.updateHeader(A.id, !0), A.expectContentUntil && t?.combineWith(A.id, { id: A.id, header: !0, sessions: A.expectContentUntil }) } if (!I.hasVerifiedContent()) throw new Error("Unreachable: CoValue should always have a verified state at this point"); let n = !1; const r = { action: "content", id: A.id, priority: A.priority, header: A.header, new: {} }; for (const [C, B] of $d(A)) { const Q = _d(B, I.knownState(), C); if (Q === void 0) { n = !0; continue } if (Q.length === 0) continue; const s = I.tryAddTransactions(C, Q, B.lastSignature, this.skipVerify); if (s) { t ? (x.error("Failed to add transactions", { peerId: t.id, peerRole: t.role, id: A.id, errorType: s.type, err: s.error, sessionID: C, msgKnownState: TI(A).sessions, msgSummary: ZI(A), knownState: I.knownState().sessions }), I.markErrored(t.id, s)) : x.error("Failed to add transactions from storage", { id: A.id, err: s.error, sessionID: C, errorType: s.type }); continue } i && i !== "import" && this.recordTransactionsSize(Q, i), r.new[C] = B } t && t.combineWith(A.id, TI(r)), n ? t ? (this.trySendToPeer(t, { action: "known", isCorrection: !0, ...I.knownState() }), t.trackToldKnownState(A.id)) : x.error("Invalid state assumed when handling new content from storage", { id: A.id, content: ZI(A), knownState: I.knownState() }) : t && (this.trySendToPeer(t, { action: "known", ...I.knownState() }), t.trackToldKnownState(A.id)); const o = r.header || Object.keys(r.new).length > 0; g !== "storage" && o && this.storeContent(r); for (const C of this.getPeers(I.id)) { if (C.closed || I.isErroredInPeer(C.id)) { C.emitCoValueChange(I.id); continue } C.isCoValueSubscribedToPeer(I.id) ? this.sendNewContent(I.id, C) : C.role === "server" && !C.loadRequestSent.has(I.id) && I.getLoadingStateForPeer(C.id) === "unknown" && (this.trySendToPeer(C, { action: "load", ...I.knownStateWithStreaming() }), C.trackLoadRequestSent(I.id)) } } handleCorrection(A, g) { return g.setKnownState(A.id, xI(A)), this.sendNewContent(A.id, g) } syncContent(A) { const g = this.local.getCoValue(A.id); this.storeContent(A); const I = TI(A); for (const t of this.getPeers(g.id)) if (!(t.role === "client" && !t.isCoValueSubscribedToPeer(g.id))) { if (t.closed || g.isErroredInPeer(t.id)) { t.emitCoValueChange(A.id); continue } this.trySendToPeer(t, A), t.combineOptimisticWith(g.id, I), t.trackToldKnownState(g.id) } } storeContent(A) { const g = this.local.storage; if (!g) return; const I = this.local.getCoValue(A.id); g.store(A, t => { if (!I.verified) { x.error("Correction requested for a CoValue with no verified content", { id: A.id, content: ZI(A), correction: t, state: I.loadingState }); return } return I.newContentSince(t) }) } waitForSyncWithPeer(A, g, I) { const t = this.peers[A]; if (t) { if (t.isCoValueSubscribedToPeer(g)) { if (this.syncState.isSynced(t, g)) return } else if (t.role === "client") return; return new Promise((i, n) => { const r = this.syncState.subscribeToPeerUpdates(A, (C, B) => { B.uploaded && C.id === g && (i(!0), r?.(), clearTimeout(o)) }), o = setTimeout(() => { n(new Error(`Timeout waiting for sync on ${A}/${g}`)), r?.() }, I) }) } } waitForStorageSync(A) { return this.local.storage?.waitForSync(A, this.local.getCoValue(A)) } waitForSync(A, g = 6e4) { const I = this.getPeers(A); return Promise.all(I.map(t => this.waitForSyncWithPeer(t.id, A, g)).concat(this.waitForStorageSync(A))) } waitForAllCoValuesSync(A = 6e4) { const g = this.local.allCoValues(), I = Array.from(g).filter(t => t.loadingState === "available" || t.loadingState === "loading"); return Promise.all(I.map(t => this.waitForSync(t.id, A))) } gracefulShutdown() { for (const A of Object.values(this.peers)) A.gracefulShutdown() } } function xE(e, A, { peer1role: g = "client", peer2role: I = "client", persistent: t = !1 } = {}) { const i = new ui, n = new ui; return [{ id: e, incoming: i, outgoing: n, role: g, persistent: t }, { id: A, incoming: n, outgoing: i, role: I, persistent: t }] } let ui = class { constructor() { this.buffer = [], this.listeners = new Set, this.closed = !1, this.closeListeners = new Set } push(A) { if (!this.listeners.size) { this.buffer.push(A); return } for (const g of this.listeners) g(A) } close() { this.closed = !0; for (const A of this.closeListeners) A(); this.closeListeners.clear(), this.listeners.clear() } onMessage(A) { if (this.buffer.length) { for (const g of this.buffer) A(g); this.buffer = [] } this.listeners.add(A) } onClose(A) { this.closeListeners.add(A) } }; class Qe { constructor(A, g, I) { this.coValues = new Map, this.syncManager = new qE(this), this.garbageCollector = void 0, this.crashed = void 0, this.agentSecret = A, this.currentSessionID = g, this.crypto = I } enableGarbageCollector(A) { this.garbageCollector || (this.garbageCollector = new VD(this.coValues, A?.garbageCollectGroups ?? !1)) } setStorage(A) { this.storage = A } removeStorage() { this.storage?.close(), this.storage = void 0 } hasCoValue(A) { const g = this.coValues.get(A); return g ? g.loadingState !== "unknown" : !1 } getCoValue(A) { let g = this.coValues.get(A); return g || (g = new PD(A, this), this.coValues.set(A, g)), this.garbageCollector?.trackCoValueAccess(g), g } allCoValues() { return this.coValues.values() } internalDeleteCoValue(A) { this.coValues.delete(A) } getCurrentAccountOrAgentID() { return YA(this.currentSessionID) } getCurrentAgent() { if (!this._cachedCurrentAgent) { const A = this.getCurrentAccountOrAgentID(); bt(A) ? this._cachedCurrentAgent = new po(this.agentSecret, this.crypto) : this._cachedCurrentAgent = new dr(mo(this.expectCoValueLoaded(A).getCurrentContent()), this.agentSecret) } return this._cachedCurrentAgent } expectCurrentAccountID(A) { const g = this.getCurrentAccountOrAgentID(); if (bt(g)) throw new Error("Current account is an agent, but expected an account: " + A); return g } expectCurrentAccount(A) { const g = this.expectCurrentAccountID(A); return mo(this.expectCoValueLoaded(g).getCurrentContent()) } static internalCreateAccount(A) { const { crypto: g, initialAgentSecret: I = g.newRandomAgentSecret(), peers: t = [] } = A, i = kE(I, g), n = _g(i, g), r = new Qe(I, g.newRandomSessionID(n), g); A.storage && r.setStorage(A.storage); for (const s of t) r.syncManager.addPeer(s); const o = g.getAgentID(I), C = wA(r.createCoValue(i).getCurrentContent()); C.set(o, "admin", "trusting"); const B = g.newRandomKeySecret(), Q = g.seal({ message: B.secret, from: g.getAgentSealerSecret(I), to: g.getAgentSealerID(o), nOnceMaterial: { in: C.id, tx: C.core.nextTransactionID() } }); return C.set(`${B.id}_for_${o}`, Q, "trusting"), C.set("readKey", B.id, "trusting"), r.expectCurrentAccount("after creation") } static async withNewlyCreatedAccount({ creationProps: A, peers: g, migration: I, crypto: t, initialAgentSecret: i = t.newRandomAgentSecret(), storage: n }) { const r = Qe.internalCreateAccount({ crypto: t, initialAgentSecret: i, peers: g, storage: n }), o = r.core.node; if (I) await I(r, o, A); else { const B = o.createGroup(); B.addMember("everyone", "reader"); const Q = B.createMap({ name: A.name }); r.set("profile", Q.id, "trusting") } const C = r.get("profile"); if (!C) throw new Error("Must set account profile in initial migration"); return o.storage && await Promise.all([o.syncManager.waitForStorageSync(r.id), o.syncManager.waitForStorageSync(C)]), { node: o, accountID: r.id, accountSecret: i, sessionID: o.currentSessionID } } static async withLoadedAccount({ accountID: A, accountSecret: g, sessionID: I, peers: t, crypto: i, migration: n, storage: r }) { try { const o = new Qe(g, I || i.newRandomSessionID(A), i); r && o.setStorage(r); for (const s of t) o.syncManager.addPeer(s); const C = await o.load(A); if (C === "unavailable") throw new Error("Account unavailable from all peers"); const B = C.get("profile"); if (!B) throw new Error("Account has no profile"); const Q = C.get("root"); return Q && (C.getRaw("root")?.trusting || C.set("root", Q, "trusting")), await o.load(B), n && await n(C, o), o } catch (o) { throw x.error("Error withLoadedAccount", { err: o }), o } } createCoValue(A) { if (this.crashed) throw new Error("Trying to create CoValue after node has crashed", { cause: this.crashed }); const g = _g(A, this.crypto), I = this.getCoValue(g); if (I.provideHeader(A), !I.hasVerifiedContent()) throw new Error("CoValue not available after providing header"); return this.garbageCollector?.trackCoValueAccess(I), this.syncManager.syncLocalTransaction(I.verified, Te(g)), I } async loadCoValueCore(A, g, I) { if (typeof A != "string" || !A.startsWith("co_z")) throw new TypeError(`Trying to load CoValue with invalid id ${Array.isArray(A) ? JSON.stringify(A) : A}`); if (this.crashed) throw new Error("Trying to load CoValue after node has crashed", { cause: this.crashed }); let t = 0; for (; ;) { const i = this.getCoValue(A); if (i.isAvailable()) return i; if (i.loadingState === "unknown" || i.loadingState === "unavailable") { const r = this.syncManager.getServerPeers(A, g); if (!this.storage && r.length === 0) return i; i.load(r) } const n = await i.waitForAvailableOrUnavailable(); if (n.isAvailable() || I || t >= Pg.MAX_RETRIES) return n; await Promise.race([new Promise(r => setTimeout(r, Pg.RETRY_DELAY)), i.waitForAvailable()]), t++ } } async load(A, g) { const I = await this.loadCoValueCore(A, void 0, g); return I.isAvailable() ? I.getCurrentContent() : "unavailable" } async checkoutBranch(A, g, I) { const t = await this.loadCoValueCore(A); if (!t.isAvailable()) return "unavailable"; if (!pr(t)) return t.getCurrentContent(); const i = t.getBranch(g, I); return i.isAvailable() ? i.getCurrentContent() : !t.hasBranch(g, I) || (await this.loadCoValueCore(i.id), !i.isAvailable()) ? t.createBranch(g, I).getCurrentContent() : i.getCurrentContent() } getLoaded(A) { const g = this.getCoValue(A); if (g.isAvailable()) return g.getCurrentContent() } subscribe(A, g, I) { let t = !1, i; return this.load(A, I).then(n => { if (!t) { if (n === "unavailable") { g("unavailable"); return } i = n.subscribe(g) } }).catch(n => { x.error("Subscription error", { id: A, err: n }) }), () => { t = !0, i?.() } } async acceptInvite(A, g) { const I = await this.load(A); if (I === "unavailable") throw new Error("Trying to accept invite: Group/owned value unavailable from all peers"); const t = I.core.verified.header.ruleset; let i; if (t.type === "unsafeAllowAll") throw new Error("Can only accept invites to values owned by groups"); if (t.type === "ownedByGroup") { const a = await this.load(t.group); if (a === "unavailable") throw new Error("Trying to accept invite: CoValue owner unavailable from all peers"); i = wA(a) } else i = wA(I); if (i.core.verified.header.meta?.type === "account") throw new Error("Can't accept invites to values owned by accounts"); const n = this.crypto.agentSecretFromSecretSeed(FD(g)), r = this.crypto.getAgentID(n), o = await new Promise((a, c) => { i.subscribe(u => { const h = u.get(r); h && a(h) }), setTimeout(() => c(new Error("Couldn't find invite before timeout")), 2e3) }); if (!o) throw new Error("No invite found"); const C = this.getCurrentAgent(), B = i.get(C.id); if (B === "admin" || B === "writer" && o === "writerInvite" || B === "writer" && o === "reader" || B === "reader" && o === "readerInvite" || B && o === "writeOnlyInvite") { x.debug("Not accepting invite that would replace or downgrade role"); return } const Q = await this.loadCoValueAsDifferentAgent(i.id, n), s = wA(Q.getCurrentContent()); s.addMemberInternal(C, o === "adminInvite" ? "admin" : o === "managerInvite" ? "manager" : o === "writerInvite" ? "writer" : o === "writeOnlyInvite" ? "writeOnly" : "reader"); const E = s.core.newContentSince(i.core.knownState()) ?? []; for (const a of E) this.syncManager.handleNewContent(a, "import") } expectCoValueLoaded(A, g) { const I = this.getCoValue(A); if (!I.isAvailable()) throw new Error(`${g ? g + ": " : ""}CoValue ${A} not yet loaded.`); return I } expectProfileLoaded(A, g) { const I = this.expectCoValueLoaded(A, g), t = wA(I.getCurrentContent()).get("profile"); if (!t) throw new Error(`${g ? g + ": " : ""}Account ${A} has no profile`); return this.expectCoValueLoaded(t, g).getCurrentContent() } resolveAccountAgent(A, g) { if (bt(A)) return { value: A, error: void 0 }; let I; try { I = this.expectCoValueLoaded(A, g) } catch (i) { return { value: void 0, error: i } } return I.verified.header.type !== "comap" || I.verified.header.ruleset.type !== "group" || !I.verified.header.meta || !("type" in I.verified.header.meta) || I.verified.header.meta.type !== "account" ? { value: void 0, error: new Error(`Unexpectedly not account: ${g}`) } : { value: I.getCurrentContent().currentAgentID(), error: void 0 } } createGroup(A = this.crypto.createdNowUnique()) { const g = this.getCurrentAgent(), I = this.createCoValue({ type: "comap", ruleset: { type: "group", initialAdmin: g.id }, meta: null, ...A }), t = wA(I.getCurrentContent()); t.set(g.id, "admin", "trusting"); const i = this.crypto.newRandomKeySecret(); return t.set(`${i.id}_for_${g.id}`, this.crypto.seal({ message: i.secret, from: g.currentSealerSecret(), to: g.currentSealerID(), nOnceMaterial: { in: I.id, tx: I.nextTransactionID() } }), "trusting"), t.set("readKey", i.id, "trusting"), t } async loadCoValueAsDifferentAgent(A, g, I) { const t = new po(g, this.crypto), i = new Qe(g, this.crypto.newRandomSessionID(I || t.id), this.crypto); return await i.loadVerifiedStateFrom(this, A), i.expectCoValueLoaded(A) } async loadVerifiedStateFrom(A, g) { const I = xE("source-" + g, "target-" + g, { peer1role: "server", peer2role: "client" }); this.syncManager.addPeer(I[0], !0), A.syncManager.addPeer(I[1], !0); const t = this.getCoValue(g), i = this.syncManager.peers[I[0].id]; if (!i) throw new Error("Peer state not found"); t.loadFromPeers([i]), await t.waitForAvailable(), i.gracefulShutdown() } gracefulShutdown() { return this.syncManager.gracefulShutdown(), this.garbageCollector?.stop(), this.storage?.close() } } function Qf({ newTxsInSession: e, contentMessage: A, sessionRow: g, firstNewTxIdx: I, signature: t }) { let i = A.new[g.sessionID]; i ? i.lastSignature = t : (i = { after: I, lastSignature: t, newTransactions: [] }, A.new[g.sessionID] = i); for (const n of e) i.newTransactions.push(n.tx) } function zE(e, A) { const g = A.id, I = Object.keys(A.new), t = Object.values(A.new).map(i => i.newTransactions); return FE(g, e, I, t) } function sf(e) { return e.reduce((A, g) => A + st(g), 0) } const af = { [RA.HIGH]: 0, [RA.MEDIUM]: 1, [RA.LOW]: 2 }; class Ef { constructor(A, g, I) { this.defaultPriority = A, this.queues = [$I(g, { priority: RA.HIGH, ...I }), $I(g, { priority: RA.MEDIUM, ...I }), $I(g, { priority: RA.LOW, ...I })] } getQueue(A) { return this.queues[af[A]] } push(A) { const g = "priority" in A ? A.priority : this.defaultPriority; this.getQueue(g).push(A) } pull() { const A = this.queues.findIndex(g => g.length > 0); return this.queues[A]?.shift() } } class cf { constructor() { this.knwonStates = new Map, this.waitForSyncRequests = new Map } getKnownState(A) { const g = this.knwonStates.get(A); if (!g) { const I = Te(A); return this.knwonStates.set(A, I), I } return g } setKnownState(A, g) { this.knwonStates.set(A, g) } handleUpdate(A, g) { const I = this.waitForSyncRequests.get(A); if (I) for (const t of I) Fo(t.knownState, g) && (t.resolve(), I.delete(t)) } waitForSync(A, g) { const I = g.knownState(); if (Fo(I, this.getKnownState(A))) return Promise.resolve(); const t = this.waitForSyncRequests.get(A) || new Set; return this.waitForSyncRequests.set(A, t), new Promise(i => { const n = g.subscribe(C => { o.knownState = C.knownState(), this.handleUpdate(A, this.getKnownState(A)) }, !1), o = { knownState: I, resolve: () => { i(), n() } }; t.add(o) }) } } function Fo(e, A) { return !A.header && e.header ? !1 : cE(e.sessions, A.sessions) } class uf { constructor() { this.backlog = new KI, this.processing = !1 } async schedule(A, g) { if (this.backlog.push({ queue: A, callback: g }), !this.processing) { for (this.processing = !0; this.backlog.head;)await this.backlog.head.value.callback(), this.backlog.shift(); this.processing = !1 } } } class vI { constructor() { this.queue = new KI, this.closed = !1, this.processing = !1 } push(A, g) { this.closed || this.queue.push({ data: A, correctionCallback: g }) } pull() { return this.queue.shift() } processQueue(A) { if (!this.processing) return this.processing = !0, vI.manager.schedule(this, async () => { let g; for (; g = this.pull();) { const { data: I, correctionCallback: t } = g; try { this.lastCallback = A(I, t), await this.lastCallback } catch (i) { x.error("Error processing message in store queue", { err: i }) } } this.lastCallback = void 0, this.processing = !1 }) } close() { for (this.closed = !0; this.pull();); return this.lastCallback } } vI.manager = new uf; class hf { constructor(A) { this.loadedCoValues = new Set, this.knwonStates = new cf, this.storeQueue = new vI, this.dbClient = A } getKnownState(A) { return this.knwonStates.getKnownState(A) } async load(A, g, I) { await this.loadCoValue(A, g, I) } async loadCoValue(A, g, I) { const t = await this.dbClient.getCoValue(A); if (!t) { I?.(!1); return } const i = await this.dbClient.getCoValueSessions(t.rowID), n = new Map; let r = !1; await Promise.all(i.map(async Q => { const s = await this.dbClient.getSignatures(Q.rowID, 0); s.length > 0 && (r = !0, n.set(Q.sessionID, s)) })); const o = this.knwonStates.getKnownState(t.id); o.header = !0; for (const Q of i) OI(o.sessions, Q.sessionID, Q.lastIdx); this.loadedCoValues.add(t.id); let C = Lg(t.id, t.header); r && (C.expectContentUntil = o.sessions); for (const Q of i) { const s = n.get(Q.sessionID) || []; let E = 0; s[s.length - 1]?.signature !== Q.lastSignature && s.push({ idx: Q.lastIdx, signature: Q.lastSignature }); for (const c of s) { const u = await this.dbClient.getNewTransactionInSession(Q.rowID, E, c.idx); Qf({ newTxsInSession: u, contentMessage: C, sessionRow: Q, firstNewTxIdx: E, signature: c.signature }), E = c.idx + 1, s.length > 1 && (await this.pushContentWithDependencies(t, C, g), C = Lg(t.id, t.header)) } } (Object.keys(C.new).length > 0 || !r) && await this.pushContentWithDependencies(t, C, g), this.knwonStates.handleUpdate(t.id, o), I?.(!0) } async pushContentWithDependencies(A, g, I) { const t = zE(A.header, g), i = []; for (const n of t) this.loadedCoValues.has(n) || i.push(new Promise(r => { this.loadCoValue(n, I, r) })); await Promise.all(i), I(g) } async store(A, g) { this.storeQueue.push(A, g), this.storeQueue.processQueue(async (I, t) => this.storeSingle(I, t)) } async handleCorrection(A, g) { const I = g(A); if (!I) return x.error("Correction callback returned undefined", { knownState: A, correction: I ?? null }), !1; for (const t of I) if (!await this.storeSingle(t, n => { x.error("Double correction requested", { msg: t, knownState: n }) })) return !1; return !0 } async storeSingle(A, g) { if (this.storeQueue.closed) return !1; const I = A.id, t = await this.dbClient.upsertCoValue(I, A.header); if (!t) { const r = Te(I); return this.knwonStates.setKnownState(I, r), this.handleCorrection(r, g) } const i = this.knwonStates.getKnownState(I); i.header = !0; let n = !1; for (const r of Object.keys(A.new)) await this.dbClient.transaction(async () => { const o = await this.dbClient.getSingleCoValueSession(t, r); o && OI(i.sessions, o.sessionID, o.lastIdx); const C = o?.lastIdx || 0, B = A.new[r]?.after || 0; if (C < B) n = !0; else { const Q = await this.putNewTxs(A, r, o, t); OI(i.sessions, r, Q) } }); return this.knwonStates.handleUpdate(I, i), n ? this.handleCorrection(i, g) : !0 } async putNewTxs(A, g, I, t) { const i = A.new[g]?.newTransactions || [], n = I?.lastIdx || 0, r = n - (A.new[g]?.after || 0), o = i.slice(r); if (o.length === 0) return n; let C = I?.bytesSinceLastSignature || 0; const B = sf(o), Q = n + o.length; let s = !1; Vt(C, B) ? (s = !0, C = 0) : C += B; const E = n; if (!A.new[g]) throw new Error("Session ID not found"); const a = { coValue: t, sessionID: g, lastIdx: Q, lastSignature: A.new[g].lastSignature, bytesSinceLastSignature: C }, c = await this.dbClient.addSessionUpdate({ sessionUpdate: a, sessionRow: I }); return s && await this.dbClient.addSignatureAfter({ sessionRowID: c, idx: Q - 1, signature: A.new[g].lastSignature }), await Promise.all(o.map((u, h) => this.dbClient.addTransaction(c, E + h, u))), Q } waitForSync(A, g) { return this.knwonStates.waitForSync(A, g) } close() { return this.storeQueue.close() } } const KA = { connectedPeers: xE, rawCoIDtoBytes: ED, rawCoIDfromBytes: cD, secretSeedLength: Rt, shortHashLength: hr, expectGroup: wA, base64URLtoBytes: cg, bytesToBase64url: ug, parseJSON: Wg, stableStringify: $, getDependedOnCoValues: zE, getDependedOnCoValuesFromRawData: FE, accountOrAgentIDfromSessionID: YA, isAccountID: RI, accountHeaderForInitialAgentSecret: kE, idforHeader: _g, getPriorityFromHeader: hE, getGroupDependentKeyList: uD, getGroupDependentKey: lr, enablePermissionErrors: TD, SyncManager: qE, CO_VALUE_LOADING_CONFIG: Pg, CO_VALUE_PRIORITY: RA, setIncomingMessagesTimeBudget: Pd, setCoValueLoadingRetryDelay: Zd, ConnectedPeerChannel: ui, textEncoder: gA, textDecoder: Xg, getTransactionSize: st, getContentMessageSize: Xd, TRANSACTION_CONFIG: je, setMaxRecommendedTxSize: Td, canBeBranched: pr }; var hA = {}, Uo; function lf() { if (Uo) return hA; Uo = 1, Object.defineProperty(hA, "__esModule", { value: !0 }), hA.calcSlices = hA.applyPatch = hA.calcPatch = hA.lcs = hA.diff = hA.diff_core = void 0; function e(C, B) { const { b: Q, eq: s, stack_base: E } = C; let { i: a, N: c, j: u, M: h, Z: d, stack_top: w } = C; for (; ;)switch (B) { case 0: { A: for (; c > 0 && h > 0;) { Q.fill(0, 0, 2 * d); const f = c - h, F = c + h, Y = F & 1, O = a + c - 1, v = u + h - 1, p = (F + Y) / 2; let k; e: for (let S = 0; S <= p; S++) { const K = 2 * Math.max(0, S - h) - S, M = S - 2 * Math.max(0, S - c); for (let m = K; m <= M; m += 2) { const b = Q[m - 1 - d * Math.floor((m - 1) / d)], j = Q[m + 1 - d * Math.floor((m + 1) / d)], J = m === -S || m !== S && b < j ? j : b + 1, T = J - m; let G = J, Z = T; for (; G < c && Z < h && s(a + G, u + Z);)G++, Z++; if (Q[m - d * Math.floor(m / d)] = G, Y === 1 && (k = f - m) >= 1 - S && k < S && G + Q[d + k - d * Math.floor(k / d)] >= c) if (S > 1 || G !== J) { E[w++] = a + G, E[w++] = c - G, E[w++] = u + Z, E[w++] = h - Z, c = J, h = T, d = 2 * (Math.min(c, h) + 1); continue A } else break e } for (let m = K; m <= M; m += 2) { const b = Q[d + m - 1 - d * Math.floor((m - 1) / d)], j = Q[d + m + 1 - d * Math.floor((m + 1) / d)], J = m === -S || m !== S && b < j ? j : b + 1, T = J - m; let G = J, Z = T; for (; G < c && Z < h && s(O - G, v - Z);)G++, Z++; if (Q[d + m - d * Math.floor(m / d)] = G, Y === 0 && (k = f - m) >= -S && k <= S && G + Q[k - d * Math.floor(k / d)] >= c) if (S > 0 || G !== J) { E[w++] = a + c - J, E[w++] = J, E[w++] = u + h - T, E[w++] = T, c = c - G, h = h - Z, d = 2 * (Math.min(c, h) + 1); continue A } else break e } } if (c !== h) { h > c ? (a += c, u += c, h -= c, c = 0) : (a += h, u += h, c -= h, h = 0); break } } if (c + h !== 0) if (C.pxe === a || C.pye === u) C.pxe = a + c, C.pye = u + h; else { const f = C.pxs; if (C.oxs = C.pxs, C.oxe = C.pxe, C.oys = C.pys, C.oye = C.pye, C.pxs = a, C.pxe = a + c, C.pys = u, C.pye = u + h, f >= 0) return C.i = a, C.N = c, C.j = u, C.M = h, C.Z = d, C.stack_top = w, 1 } } case 1: { if (w === 0) return 2; h = E[--w], u = E[--w], c = E[--w], a = E[--w], d = 2 * (Math.min(c, h) + 1), B = 0 } } } class A { constructor(B) { this.state = B, this.c = 0, this.result = { value: null, done: !1 } } [Symbol.iterator]() { return this } next() { const { state: B, result: Q } = this; if (this.c > 1) return Q.done = !0, Q.value = void 0, Q; const s = e(B, this.c); return this.c = s, s === 1 ? (Q.value = [B.oxs, B.oxe, B.oys, B.oye], Q) : B.pxs >= 0 ? (Q.value = [B.pxs, B.pxe, B.pys, B.pye], Q) : (Q.done = !0, Q.value = void 0, Q) } } function g(C, B, Q, s, E) { const a = (Math.min(B, s) + 1) * 2, c = B + s, u = new (c < 256 ? Uint8Array : c < 65536 ? Uint16Array : Uint32Array)(2 * a); return new A({ i: C, N: B, j: Q, M: s, Z: a, b: u, eq: E, pxs: -1, pxe: -1, pys: -1, pye: -1, oxs: -1, oxe: -1, oys: -1, oye: -1, stack_top: 0, stack_base: [] }) } hA.diff_core = g; function I(C, B, Q) { let [s, E, a] = [0, C.length, B.length]; if (typeof Q == "function") { for (; s < E && s < a && Q(s, s);)s++; if (s === E && s === a) return [][Symbol.iterator](); for (; Q(--E, --a) && E > s && a > s;); } else { for (; s < E && s < a && C[s] === B[s];)s++; if (s === E && s === a) return [][Symbol.iterator](); for (; C[--E] === B[--a] && E > s && a > s;); Q = (c, u) => C[c] === B[u] } return g(s, E + 1 - s, s, a + 1 - s, Q) } hA.diff = I; class t { constructor(B, Q) { this.diff = B, this.N = Q, this.i = 0, this.j = 0 } [Symbol.iterator]() { return this } next() { const B = this.diff.next(); if (B.done) { const { i: h, j: d, N: w } = this; return h < w && (B.done = !1, B.value = [h, d, w - h], this.i = w), B } const Q = B.value, s = Q[0], E = Q[1], a = Q[3], { i: c, j: u } = this; return c !== s && (Q.length--, Q[0] = c, Q[1] = u, Q[2] = s - c), this.i = E, this.j = a, B } } function i(C, B, Q) { return new t(I(C, B, Q), C.length) } hA.lcs = i; function* n(C, B, Q) { const s = ArrayBuffer.isView(C) ? Uint8Array.prototype.subarray : C.slice; for (const E of I(C, B, Q)) E[2] = s.call(B, E[2], E[3]), yield E } hA.calcPatch = n; function* r(C, B) { let Q = 0; const s = ArrayBuffer.isView(C) ? Uint8Array.prototype.subarray : C.slice; for (const [E, a, c] of B) Q < E && (yield s.call(C, Q, E)), c.length > 0 && (yield c), Q = a; Q < C.length && (yield s.call(C, Q)) } hA.applyPatch = r; function* o(C, B, Q) { let s = 0; const E = ArrayBuffer.isView(C) ? Uint8Array.prototype.subarray : C.slice; for (const [a, c, u, h] of I(C, B, Q)) s < a && (yield [0, E.call(C, s, a)]), a < c && (yield [-1, E.call(C, a, c)]), u < h && (yield [1, E.call(B, u, h)]), s = c; s < C.length && (yield [0, C.slice(s)]) } return hA.calcSlices = o, hA } var OE = lf(); function jE(e) { return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array" } function Ro(e) { if (typeof e != "boolean") throw new Error(`boolean expected, not ${e}`) } function Ai(e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e) } function lA(e, ...A) { if (!jE(e)) throw new Error("Uint8Array expected"); if (A.length > 0 && !A.includes(e.length)) throw new Error("Uint8Array expected of length " + A + ", got length=" + e.length) } function bo(e, A = !0) { if (e.destroyed) throw new Error("Hash instance has been destroyed"); if (A && e.finished) throw new Error("Hash#digest() has already been called") } function wf(e, A) { lA(e); const g = A.outputLen; if (e.length < g) throw new Error("digestInto() expects output buffer of length at least " + g) } function fe(e) { return new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)) } function ve(...e) { for (let A = 0; A < e.length; A++)e[A].fill(0) } const df = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68; function Df(e) { if (typeof e != "string") throw new Error("string expected"); return new Uint8Array(new TextEncoder().encode(e)) } function hi(e) { if (typeof e == "string") e = Df(e); else if (jE(e)) e = li(e); else throw new Error("Uint8Array expected, got " + typeof e); return e } function ff(e, A) { if (A == null || typeof A != "object") throw new Error("options must be defined"); return Object.assign(e, A) } function yf(e, A) { if (e.length !== A.length) return !1; let g = 0; for (let I = 0; I < e.length; I++)g |= e[I] ^ A[I]; return g === 0 } const pf = (e, A) => { function g(I, ...t) { if (lA(I), !df) throw new Error("Non little-endian hardware is not yet supported"); if (e.nonceLength !== void 0) { const B = t[0]; if (!B) throw new Error("nonce / iv required"); e.varSizeNonce ? lA(B) : lA(B, e.nonceLength) } const i = e.tagLength; i && t[1] !== void 0 && lA(t[1]); const n = A(I, ...t), r = (B, Q) => { if (Q !== void 0) { if (B !== 2) throw new Error("cipher output not supported"); lA(Q) } }; let o = !1; return { encrypt(B, Q) { if (o) throw new Error("cannot encrypt() twice with same key + nonce"); return o = !0, lA(B), r(n.encrypt.length, Q), n.encrypt(B, Q) }, decrypt(B, Q) { if (lA(B), i && B.length < i) throw new Error("invalid ciphertext length: smaller than tagLength=" + i); return r(n.decrypt.length, Q), n.decrypt(B, Q) } } } return Object.assign(g, e), g }; function Yo(e, A, g = !0) { if (A === void 0) return new Uint8Array(e); if (A.length !== e) throw new Error("invalid output length, expected " + e + ", got: " + A.length); if (g && !mf(A)) throw new Error("invalid output, must be aligned"); return A } function mf(e) { return e.byteOffset % 4 === 0 } function li(e) { return Uint8Array.from(e) } const TE = e => Uint8Array.from(e.split("").map(A => A.charCodeAt(0))), Nf = TE("expand 16-byte k"), kf = TE("expand 32-byte k"), Gf = fe(Nf), Sf = fe(kf); function U(e, A) { return e << A | e >>> 32 - A } function wi(e) { return e.byteOffset % 4 === 0 } const pt = 64, Mf = 16, ZE = 2 ** 32 - 1, Ko = new Uint32Array; function Ff(e, A, g, I, t, i, n, r) { const o = t.length, C = new Uint8Array(pt), B = fe(C), Q = wi(t) && wi(i), s = Q ? fe(t) : Ko, E = Q ? fe(i) : Ko; for (let a = 0; a < o; n++) { if (e(A, g, I, B, n, r), n >= ZE) throw new Error("arx: counter overflow"); const c = Math.min(pt, o - a); if (Q && c === pt) { const u = a / 4; if (a % 4 !== 0) throw new Error("arx: invalid block position"); for (let h = 0, d; h < Mf; h++)d = u + h, E[d] = s[d] ^ B[h]; a += pt; continue } for (let u = 0, h; u < c; u++)h = a + u, i[h] = t[h] ^ C[u]; a += c } } function Uf(e, A) { const { allowShortKeys: g, extendNonceFn: I, counterLength: t, counterRight: i, rounds: n } = ff({ allowShortKeys: !1, counterLength: 8, counterRight: !1, rounds: 20 }, A); if (typeof e != "function") throw new Error("core must be a function"); return Ai(t), Ai(n), Ro(i), Ro(g), (r, o, C, B, Q = 0) => { lA(r), lA(o), lA(C); const s = C.length; if (B === void 0 && (B = new Uint8Array(s)), lA(B), Ai(Q), Q < 0 || Q >= ZE) throw new Error("arx: counter overflow"); if (B.length < s) throw new Error(`arx: output (${B.length}) is shorter than data (${s})`); const E = []; let a = r.length, c, u; if (a === 32) E.push(c = li(r)), u = Sf; else if (a === 16 && g) c = new Uint8Array(32), c.set(r), c.set(r, 16), u = Gf, E.push(c); else throw new Error(`arx: invalid 32-byte key, got length=${a}`); wi(o) || E.push(o = li(o)); const h = fe(c); if (I) { if (o.length !== 24) throw new Error("arx: extended nonce must be 24 bytes"); I(u, h, fe(o.subarray(0, 16)), h), o = o.subarray(16) } const d = 16 - t; if (d !== o.length) throw new Error(`arx: nonce must be ${d} or 16 bytes`); if (d !== 12) { const f = new Uint8Array(12); f.set(o, i ? 0 : 12 - o.length), o = f, E.push(o) } const w = fe(o); return Ff(e, u, h, w, C, B, Q, n), ve(...E), B } } const EA = (e, A) => e[A++] & 255 | (e[A++] & 255) << 8; class Rf { constructor(A) { this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, A = hi(A), lA(A, 32); const g = EA(A, 0), I = EA(A, 2), t = EA(A, 4), i = EA(A, 6), n = EA(A, 8), r = EA(A, 10), o = EA(A, 12), C = EA(A, 14); this.r[0] = g & 8191, this.r[1] = (g >>> 13 | I << 3) & 8191, this.r[2] = (I >>> 10 | t << 6) & 7939, this.r[3] = (t >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | n << 12) & 255, this.r[5] = n >>> 1 & 8190, this.r[6] = (n >>> 14 | r << 2) & 8191, this.r[7] = (r >>> 11 | o << 5) & 8065, this.r[8] = (o >>> 8 | C << 8) & 8191, this.r[9] = C >>> 5 & 127; for (let B = 0; B < 8; B++)this.pad[B] = EA(A, 16 + 2 * B) } process(A, g, I = !1) { const t = I ? 0 : 2048, { h: i, r: n } = this, r = n[0], o = n[1], C = n[2], B = n[3], Q = n[4], s = n[5], E = n[6], a = n[7], c = n[8], u = n[9], h = EA(A, g + 0), d = EA(A, g + 2), w = EA(A, g + 4), f = EA(A, g + 6), F = EA(A, g + 8), Y = EA(A, g + 10), O = EA(A, g + 12), v = EA(A, g + 14); let p = i[0] + (h & 8191), k = i[1] + ((h >>> 13 | d << 3) & 8191), S = i[2] + ((d >>> 10 | w << 6) & 8191), K = i[3] + ((w >>> 7 | f << 9) & 8191), M = i[4] + ((f >>> 4 | F << 12) & 8191), m = i[5] + (F >>> 1 & 8191), b = i[6] + ((F >>> 14 | Y << 2) & 8191), j = i[7] + ((Y >>> 11 | O << 5) & 8191), J = i[8] + ((O >>> 8 | v << 8) & 8191), T = i[9] + (v >>> 5 | t), G = 0, Z = G + p * r + k * (5 * u) + S * (5 * c) + K * (5 * a) + M * (5 * E); G = Z >>> 13, Z &= 8191, Z += m * (5 * s) + b * (5 * Q) + j * (5 * B) + J * (5 * C) + T * (5 * o), G += Z >>> 13, Z &= 8191; let eA = G + p * o + k * r + S * (5 * u) + K * (5 * c) + M * (5 * a); G = eA >>> 13, eA &= 8191, eA += m * (5 * E) + b * (5 * s) + j * (5 * Q) + J * (5 * B) + T * (5 * C), G += eA >>> 13, eA &= 8191; let X = G + p * C + k * o + S * r + K * (5 * u) + M * (5 * c); G = X >>> 13, X &= 8191, X += m * (5 * a) + b * (5 * E) + j * (5 * s) + J * (5 * Q) + T * (5 * B), G += X >>> 13, X &= 8191; let cA = G + p * B + k * C + S * o + K * r + M * (5 * u); G = cA >>> 13, cA &= 8191, cA += m * (5 * c) + b * (5 * a) + j * (5 * E) + J * (5 * s) + T * (5 * Q), G += cA >>> 13, cA &= 8191; let ZA = G + p * Q + k * B + S * C + K * o + M * r; G = ZA >>> 13, ZA &= 8191, ZA += m * (5 * u) + b * (5 * c) + j * (5 * a) + J * (5 * E) + T * (5 * s), G += ZA >>> 13, ZA &= 8191; let PA = G + p * s + k * Q + S * B + K * C + M * o; G = PA >>> 13, PA &= 8191, PA += m * r + b * (5 * u) + j * (5 * c) + J * (5 * a) + T * (5 * E), G += PA >>> 13, PA &= 8191; let VA = G + p * E + k * s + S * Q + K * B + M * C; G = VA >>> 13, VA &= 8191, VA += m * o + b * r + j * (5 * u) + J * (5 * c) + T * (5 * a), G += VA >>> 13, VA &= 8191; let WA = G + p * a + k * E + S * s + K * Q + M * B; G = WA >>> 13, WA &= 8191, WA += m * C + b * o + j * r + J * (5 * u) + T * (5 * c), G += WA >>> 13, WA &= 8191; let Ie = G + p * c + k * a + S * E + K * s + M * Q; G = Ie >>> 13, Ie &= 8191, Ie += m * B + b * C + j * o + J * r + T * (5 * u), G += Ie >>> 13, Ie &= 8191; let ie = G + p * u + k * c + S * a + K * E + M * s; G = ie >>> 13, ie &= 8191, ie += m * Q + b * B + j * C + J * o + T * r, G += ie >>> 13, ie &= 8191, G = (G << 2) + G | 0, G = G + Z | 0, Z = G & 8191, G = G >>> 13, eA += G, i[0] = Z, i[1] = eA, i[2] = X, i[3] = cA, i[4] = ZA, i[5] = PA, i[6] = VA, i[7] = WA, i[8] = Ie, i[9] = ie } finalize() { const { h: A, pad: g } = this, I = new Uint16Array(10); let t = A[1] >>> 13; A[1] &= 8191; for (let r = 2; r < 10; r++)A[r] += t, t = A[r] >>> 13, A[r] &= 8191; A[0] += t * 5, t = A[0] >>> 13, A[0] &= 8191, A[1] += t, t = A[1] >>> 13, A[1] &= 8191, A[2] += t, I[0] = A[0] + 5, t = I[0] >>> 13, I[0] &= 8191; for (let r = 1; r < 10; r++)I[r] = A[r] + t, t = I[r] >>> 13, I[r] &= 8191; I[9] -= 8192; let i = (t ^ 1) - 1; for (let r = 0; r < 10; r++)I[r] &= i; i = ~i; for (let r = 0; r < 10; r++)A[r] = A[r] & i | I[r]; A[0] = (A[0] | A[1] << 13) & 65535, A[1] = (A[1] >>> 3 | A[2] << 10) & 65535, A[2] = (A[2] >>> 6 | A[3] << 7) & 65535, A[3] = (A[3] >>> 9 | A[4] << 4) & 65535, A[4] = (A[4] >>> 12 | A[5] << 1 | A[6] << 14) & 65535, A[5] = (A[6] >>> 2 | A[7] << 11) & 65535, A[6] = (A[7] >>> 5 | A[8] << 8) & 65535, A[7] = (A[8] >>> 8 | A[9] << 5) & 65535; let n = A[0] + g[0]; A[0] = n & 65535; for (let r = 1; r < 8; r++)n = (A[r] + g[r] | 0) + (n >>> 16) | 0, A[r] = n & 65535; ve(I) } update(A) { bo(this), A = hi(A), lA(A); const { buffer: g, blockLen: I } = this, t = A.length; for (let i = 0; i < t;) { const n = Math.min(I - this.pos, t - i); if (n === I) { for (; I <= t - i; i += I)this.process(A, i); continue } g.set(A.subarray(i, i + n), this.pos), this.pos += n, i += n, this.pos === I && (this.process(g, 0, !1), this.pos = 0) } return this } destroy() { ve(this.h, this.r, this.buffer, this.pad) } digestInto(A) { bo(this), wf(A, this), this.finished = !0; const { buffer: g, h: I } = this; let { pos: t } = this; if (t) { for (g[t++] = 1; t < 16; t++)g[t] = 0; this.process(g, 0, !0) } this.finalize(); let i = 0; for (let n = 0; n < 8; n++)A[i++] = I[n] >>> 0, A[i++] = I[n] >>> 8; return A } digest() { const { buffer: A, outputLen: g } = this; this.digestInto(A); const I = A.slice(0, g); return this.destroy(), I } } function bf(e) { const A = (I, t) => e(t).update(hi(I)).digest(), g = e(new Uint8Array(32)); return A.outputLen = g.outputLen, A.blockLen = g.blockLen, A.create = I => e(I), A } const vo = bf(e => new Rf(e)); function Yf(e, A, g, I, t, i = 20) { let n = e[0], r = A[0], o = A[1], C = A[2], B = A[3], Q = e[1], s = g[0], E = g[1], a = t, c = 0, u = e[2], h = A[4], d = A[5], w = A[6], f = A[7], F = e[3], Y = n, O = r, v = o, p = C, k = B, S = Q, K = s, M = E, m = a, b = c, j = u, J = h, T = d, G = w, Z = f, eA = F; for (let cA = 0; cA < i; cA += 2)k ^= U(Y + T | 0, 7), m ^= U(k + Y | 0, 9), T ^= U(m + k | 0, 13), Y ^= U(T + m | 0, 18), b ^= U(S + O | 0, 7), G ^= U(b + S | 0, 9), O ^= U(G + b | 0, 13), S ^= U(O + G | 0, 18), Z ^= U(j + K | 0, 7), v ^= U(Z + j | 0, 9), K ^= U(v + Z | 0, 13), j ^= U(K + v | 0, 18), p ^= U(eA + J | 0, 7), M ^= U(p + eA | 0, 9), J ^= U(M + p | 0, 13), eA ^= U(J + M | 0, 18), O ^= U(Y + p | 0, 7), v ^= U(O + Y | 0, 9), p ^= U(v + O | 0, 13), Y ^= U(p + v | 0, 18), K ^= U(S + k | 0, 7), M ^= U(K + S | 0, 9), k ^= U(M + K | 0, 13), S ^= U(k + M | 0, 18), J ^= U(j + b | 0, 7), m ^= U(J + j | 0, 9), b ^= U(m + J | 0, 13), j ^= U(b + m | 0, 18), T ^= U(eA + Z | 0, 7), G ^= U(T + eA | 0, 9), Z ^= U(G + T | 0, 13), eA ^= U(Z + G | 0, 18); let X = 0; I[X++] = n + Y | 0, I[X++] = r + O | 0, I[X++] = o + v | 0, I[X++] = C + p | 0, I[X++] = B + k | 0, I[X++] = Q + S | 0, I[X++] = s + K | 0, I[X++] = E + M | 0, I[X++] = a + m | 0, I[X++] = c + b | 0, I[X++] = u + j | 0, I[X++] = h + J | 0, I[X++] = d + T | 0, I[X++] = w + G | 0, I[X++] = f + Z | 0, I[X++] = F + eA | 0 } function Kf(e, A, g, I) { let t = e[0], i = A[0], n = A[1], r = A[2], o = A[3], C = e[1], B = g[0], Q = g[1], s = g[2], E = g[3], a = e[2], c = A[4], u = A[5], h = A[6], d = A[7], w = e[3]; for (let F = 0; F < 20; F += 2)o ^= U(t + u | 0, 7), s ^= U(o + t | 0, 9), u ^= U(s + o | 0, 13), t ^= U(u + s | 0, 18), E ^= U(C + i | 0, 7), h ^= U(E + C | 0, 9), i ^= U(h + E | 0, 13), C ^= U(i + h | 0, 18), d ^= U(a + B | 0, 7), n ^= U(d + a | 0, 9), B ^= U(n + d | 0, 13), a ^= U(B + n | 0, 18), r ^= U(w + c | 0, 7), Q ^= U(r + w | 0, 9), c ^= U(Q + r | 0, 13), w ^= U(c + Q | 0, 18), i ^= U(t + r | 0, 7), n ^= U(i + t | 0, 9), r ^= U(n + i | 0, 13), t ^= U(r + n | 0, 18), B ^= U(C + o | 0, 7), Q ^= U(B + C | 0, 9), o ^= U(Q + B | 0, 13), C ^= U(o + Q | 0, 18), c ^= U(a + E | 0, 7), s ^= U(c + a | 0, 9), E ^= U(s + c | 0, 13), a ^= U(E + s | 0, 18), u ^= U(w + d | 0, 7), h ^= U(u + w | 0, 9), d ^= U(h + u | 0, 13), w ^= U(d + h | 0, 18); let f = 0; I[f++] = t, I[f++] = C, I[f++] = a, I[f++] = w, I[f++] = B, I[f++] = Q, I[f++] = s, I[f++] = E } const qg = Uf(Yf, { counterRight: !0, extendNonceFn: Kf }), Jo = pf({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (e, A) => ({ encrypt(g, I) { I = Yo(g.length + 32, I, !1); const t = I.subarray(0, 32), i = I.subarray(32); I.set(g, 32), ve(t), qg(e, A, I, I); const n = vo(i, t); return I.set(n, 16), ve(I.subarray(0, 16), n), I.subarray(16) }, decrypt(g, I) { lA(g), I = Yo(g.length + 32, I, !1); const t = I.subarray(0, 32), i = I.subarray(32, 48), n = I.subarray(48); I.set(g, 32), ve(t); const r = qg(e, A, t, t), o = vo(n, r); if (!yf(i, o)) throw new Error("invalid tag"); return qg(e, A, I.subarray(16), I.subarray(16)), ve(t, i, o), n } })), mt = BigInt(2 ** 32 - 1), Ho = BigInt(32); function di(e, A = !1) { return A ? { h: Number(e & mt), l: Number(e >> Ho & mt) } : { h: Number(e >> Ho & mt) | 0, l: Number(e & mt) | 0 } } function vf(e, A = !1) { const g = e.length; let I = new Uint32Array(g), t = new Uint32Array(g); for (let i = 0; i < g; i++) { const { h: n, l: r } = di(e[i], A);[I[i], t[i]] = [n, r] } return [I, t] } const Lo = (e, A, g) => e >>> g, qo = (e, A, g) => e << 32 - g | A >>> g, eg = (e, A, g) => e >>> g | A << 32 - g, gg = (e, A, g) => e << 32 - g | A >>> g, Nt = (e, A, g) => e << 64 - g | A >>> g - 32, kt = (e, A, g) => e >>> g - 32 | A << 64 - g; function re(e, A, g, I) { const t = (A >>> 0) + (I >>> 0); return { h: e + g + (t / 2 ** 32 | 0) | 0, l: t | 0 } } const Jf = (e, A, g) => (e >>> 0) + (A >>> 0) + (g >>> 0), Hf = (e, A, g, I) => A + g + I + (e / 2 ** 32 | 0) | 0, Lf = (e, A, g, I) => (e >>> 0) + (A >>> 0) + (g >>> 0) + (I >>> 0), qf = (e, A, g, I, t) => A + g + I + t + (e / 2 ** 32 | 0) | 0, xf = (e, A, g, I, t) => (e >>> 0) + (A >>> 0) + (g >>> 0) + (I >>> 0) + (t >>> 0), zf = (e, A, g, I, t, i) => A + g + I + t + i + (e / 2 ** 32 | 0) | 0, PE = vf(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(e => BigInt(e))), Of = PE[0], jf = PE[1], Ee = new Uint32Array(80), ce = new Uint32Array(80); class Tf extends If { constructor(A = 64) { super(128, A, 16, !1), this.Ah = uA[0] | 0, this.Al = uA[1] | 0, this.Bh = uA[2] | 0, this.Bl = uA[3] | 0, this.Ch = uA[4] | 0, this.Cl = uA[5] | 0, this.Dh = uA[6] | 0, this.Dl = uA[7] | 0, this.Eh = uA[8] | 0, this.El = uA[9] | 0, this.Fh = uA[10] | 0, this.Fl = uA[11] | 0, this.Gh = uA[12] | 0, this.Gl = uA[13] | 0, this.Hh = uA[14] | 0, this.Hl = uA[15] | 0 } get() { const { Ah: A, Al: g, Bh: I, Bl: t, Ch: i, Cl: n, Dh: r, Dl: o, Eh: C, El: B, Fh: Q, Fl: s, Gh: E, Gl: a, Hh: c, Hl: u } = this; return [A, g, I, t, i, n, r, o, C, B, Q, s, E, a, c, u] } set(A, g, I, t, i, n, r, o, C, B, Q, s, E, a, c, u) { this.Ah = A | 0, this.Al = g | 0, this.Bh = I | 0, this.Bl = t | 0, this.Ch = i | 0, this.Cl = n | 0, this.Dh = r | 0, this.Dl = o | 0, this.Eh = C | 0, this.El = B | 0, this.Fh = Q | 0, this.Fl = s | 0, this.Gh = E | 0, this.Gl = a | 0, this.Hh = c | 0, this.Hl = u | 0 } process(A, g) { for (let w = 0; w < 16; w++, g += 4)Ee[w] = A.getUint32(g), ce[w] = A.getUint32(g += 4); for (let w = 16; w < 80; w++) { const f = Ee[w - 15] | 0, F = ce[w - 15] | 0, Y = eg(f, F, 1) ^ eg(f, F, 8) ^ Lo(f, F, 7), O = gg(f, F, 1) ^ gg(f, F, 8) ^ qo(f, F, 7), v = Ee[w - 2] | 0, p = ce[w - 2] | 0, k = eg(v, p, 19) ^ Nt(v, p, 61) ^ Lo(v, p, 6), S = gg(v, p, 19) ^ kt(v, p, 61) ^ qo(v, p, 6), K = Lf(O, S, ce[w - 7], ce[w - 16]), M = qf(K, Y, k, Ee[w - 7], Ee[w - 16]); Ee[w] = M | 0, ce[w] = K | 0 } let { Ah: I, Al: t, Bh: i, Bl: n, Ch: r, Cl: o, Dh: C, Dl: B, Eh: Q, El: s, Fh: E, Fl: a, Gh: c, Gl: u, Hh: h, Hl: d } = this; for (let w = 0; w < 80; w++) { const f = eg(Q, s, 14) ^ eg(Q, s, 18) ^ Nt(Q, s, 41), F = gg(Q, s, 14) ^ gg(Q, s, 18) ^ kt(Q, s, 41), Y = Q & E ^ ~Q & c, O = s & a ^ ~s & u, v = xf(d, F, O, jf[w], ce[w]), p = zf(v, h, f, Y, Of[w], Ee[w]), k = v | 0, S = eg(I, t, 28) ^ Nt(I, t, 34) ^ Nt(I, t, 39), K = gg(I, t, 28) ^ kt(I, t, 34) ^ kt(I, t, 39), M = I & i ^ I & r ^ i & r, m = t & n ^ t & o ^ n & o; h = c | 0, d = u | 0, c = E | 0, u = a | 0, E = Q | 0, a = s | 0, { h: Q, l: s } = re(C | 0, B | 0, p | 0, k | 0), C = r | 0, B = o | 0, r = i | 0, o = n | 0, i = I | 0, n = t | 0; const b = Jf(k, K, m); I = Hf(b, p, S, M), t = b | 0 } ({ h: I, l: t } = re(this.Ah | 0, this.Al | 0, I | 0, t | 0)), { h: i, l: n } = re(this.Bh | 0, this.Bl | 0, i | 0, n | 0), { h: r, l: o } = re(this.Ch | 0, this.Cl | 0, r | 0, o | 0), { h: C, l: B } = re(this.Dh | 0, this.Dl | 0, C | 0, B | 0), { h: Q, l: s } = re(this.Eh | 0, this.El | 0, Q | 0, s | 0), { h: E, l: a } = re(this.Fh | 0, this.Fl | 0, E | 0, a | 0), { h: c, l: u } = re(this.Gh | 0, this.Gl | 0, c | 0, u | 0), { h, l: d } = re(this.Hh | 0, this.Hl | 0, h | 0, d | 0), this.set(I, t, i, n, r, o, C, B, Q, s, E, a, c, u, h, d) } roundClean() { Le(Ee, ce) } destroy() { Le(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) } } const Zf = ef(() => new Tf); const Mr = BigInt(0), Di = BigInt(1); function fi(e, A = "") { if (typeof e != "boolean") { const g = A && `"${A}"`; throw new Error(g + "expected boolean, got type=" + typeof e) } return e } function Kt(e, A, g = "") { const I = YI(e), t = e?.length, i = A !== void 0; if (!I || i && t !== A) { const n = g && `"${g}" `, r = i ? ` of length ${A}` : "", o = I ? `length=${t}` : `type=${typeof e}`; throw new Error(n + "expected Uint8Array" + r + ", got " + o) } return e } function VE(e) { if (typeof e != "string") throw new Error("hex string expected, got " + typeof e); return e === "" ? Mr : BigInt("0x" + e) } function Pf(e) { return VE(kr(e)) } function lg(e) { return ge(e), VE(kr(Uint8Array.from(e).reverse())) } function WE(e, A) { return JE(e.toString(16).padStart(A * 2, "0")) } function XE(e, A) { return WE(e, A).reverse() } function _A(e, A, g) { let I; if (typeof A == "string") try { I = JE(A) } catch (i) { throw new Error(e + " must be hex string or Uint8Array, cause: " + i) } else if (YI(A)) I = Uint8Array.from(A); else throw new Error(e + " must be hex string or Uint8Array"); const t = I.length; if (typeof g == "number" && t !== g) throw new Error(e + " of length " + g + " expected, got " + t); return I } function xo(e) { return Uint8Array.from(e) } const ei = e => typeof e == "bigint" && Mr <= e; function Vf(e, A, g) { return ei(e) && ei(A) && ei(g) && A <= e && e < g } function tI(e, A, g, I) { if (!Vf(A, g, I)) throw new Error("expected valid " + e + ": " + g + " <= n < " + I + ", got " + A) } function Wf(e) { let A; for (A = 0; e > Mr; e >>= Di, A += 1); return A } const Fr = e => (Di << BigInt(e)) - Di; function JI(e, A, g = {}) { if (!e || typeof e != "object") throw new Error("expected valid options object"); function I(t, i, n) { const r = e[t]; if (n && r === void 0) return; const o = typeof r; if (o !== i || r === null) throw new Error(`param "${t}" is invalid: expected ${i}, got ${o}`) } Object.entries(A).forEach(([t, i]) => I(t, i, !1)), Object.entries(g).forEach(([t, i]) => I(t, i, !0)) } function zo(e) { const A = new WeakMap; return (g, ...I) => { const t = A.get(g); if (t !== void 0) return t; const i = e(g, ...I); return A.set(g, i), i } } const pA = BigInt(0), dA = BigInt(1), Je = BigInt(2), _E = BigInt(3), $E = BigInt(4), Ac = BigInt(5), Xf = BigInt(7), ec = BigInt(8), _f = BigInt(9), gc = BigInt(16); function oA(e, A) { const g = e % A; return g >= pA ? g : A + g } function LA(e, A, g) { let I = e; for (; A-- > pA;)I *= I, I %= g; return I } function Oo(e, A) { if (e === pA) throw new Error("invert: expected non-zero number"); if (A <= pA) throw new Error("invert: expected positive modulus, got " + A); let g = oA(e, A), I = A, t = pA, i = dA; for (; g !== pA;) { const r = I / g, o = I % g, C = t - i * r; I = g, g = o, t = i, i = C } if (I !== dA) throw new Error("invert: does not exist"); return oA(t, A) } function Ur(e, A, g) { if (!e.eql(e.sqr(A), g)) throw new Error("Cannot find square root") } function tc(e, A) { const g = (e.ORDER + dA) / $E, I = e.pow(A, g); return Ur(e, I, A), I } function $f(e, A) { const g = (e.ORDER - Ac) / ec, I = e.mul(A, Je), t = e.pow(I, g), i = e.mul(A, t), n = e.mul(e.mul(i, Je), t), r = e.mul(i, e.sub(n, e.ONE)); return Ur(e, r, A), r } function Ay(e) { const A = Et(e), g = Ic(e), I = g(A, A.neg(A.ONE)), t = g(A, I), i = g(A, A.neg(I)), n = (e + Xf) / gc; return (r, o) => { let C = r.pow(o, n), B = r.mul(C, I); const Q = r.mul(C, t), s = r.mul(C, i), E = r.eql(r.sqr(B), o), a = r.eql(r.sqr(Q), o); C = r.cmov(C, B, E), B = r.cmov(s, Q, a); const c = r.eql(r.sqr(B), o), u = r.cmov(C, B, c); return Ur(r, u, o), u } } function Ic(e) { if (e < _E) throw new Error("sqrt is not defined for small field"); let A = e - dA, g = 0; for (; A % Je === pA;)A /= Je, g++; let I = Je; const t = Et(e); for (; jo(t, I) === 1;)if (I++ > 1e3) throw new Error("Cannot find square root: probably non-prime P"); if (g === 1) return tc; let i = t.pow(I, A); const n = (A + dA) / Je; return function (o, C) { if (o.is0(C)) return C; if (jo(o, C) !== 1) throw new Error("Cannot find square root"); let B = g, Q = o.mul(o.ONE, i), s = o.pow(C, A), E = o.pow(C, n); for (; !o.eql(s, o.ONE);) { if (o.is0(s)) return o.ZERO; let a = 1, c = o.sqr(s); for (; !o.eql(c, o.ONE);)if (a++, c = o.sqr(c), a === B) throw new Error("Cannot find square root"); const u = dA << BigInt(B - a - 1), h = o.pow(Q, u); B = a, Q = o.sqr(h), s = o.mul(s, Q), E = o.mul(E, h) } return E } } function ey(e) { return e % $E === _E ? tc : e % ec === Ac ? $f : e % gc === _f ? Ay(e) : Ic(e) } const gy = (e, A) => (oA(e, A) & dA) === dA, ty = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"]; function Iy(e) { const A = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, g = ty.reduce((I, t) => (I[t] = "function", I), A); return JI(e, g), e } function iy(e, A, g) { if (g < pA) throw new Error("invalid exponent, negatives unsupported"); if (g === pA) return e.ONE; if (g === dA) return A; let I = e.ONE, t = A; for (; g > pA;)g & dA && (I = e.mul(I, t)), t = e.sqr(t), g >>= dA; return I } function ic(e, A, g = !1) { const I = new Array(A.length).fill(g ? e.ZERO : void 0), t = A.reduce((n, r, o) => e.is0(r) ? n : (I[o] = n, e.mul(n, r)), e.ONE), i = e.inv(t); return A.reduceRight((n, r, o) => e.is0(r) ? n : (I[o] = e.mul(n, I[o]), e.mul(n, r)), i), I } function jo(e, A) { const g = (e.ORDER - dA) / Je, I = e.pow(A, g), t = e.eql(I, e.ONE), i = e.eql(I, e.ZERO), n = e.eql(I, e.neg(e.ONE)); if (!t && !i && !n) throw new Error("invalid Legendre symbol result"); return t ? 1 : i ? 0 : -1 } function ny(e, A) { A !== void 0 && AI(A); const g = A !== void 0 ? A : e.toString(2).length, I = Math.ceil(g / 8); return { nBitLength: g, nByteLength: I } } function Et(e, A, g = !1, I = {}) { if (e <= pA) throw new Error("invalid field: expected ORDER > 0, got " + e); let t, i, n = !1, r; if (typeof A == "object" && A != null) { if (I.sqrt || g) throw new Error("cannot specify opts in two arguments"); const s = A; s.BITS && (t = s.BITS), s.sqrt && (i = s.sqrt), typeof s.isLE == "boolean" && (g = s.isLE), typeof s.modFromBytes == "boolean" && (n = s.modFromBytes), r = s.allowedLengths } else typeof A == "number" && (t = A), I.sqrt && (i = I.sqrt); const { nBitLength: o, nByteLength: C } = ny(e, t); if (C > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes"); let B; const Q = Object.freeze({ ORDER: e, isLE: g, BITS: o, BYTES: C, MASK: Fr(o), ZERO: pA, ONE: dA, allowedLengths: r, create: s => oA(s, e), isValid: s => { if (typeof s != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof s); return pA <= s && s < e }, is0: s => s === pA, isValidNot0: s => !Q.is0(s) && Q.isValid(s), isOdd: s => (s & dA) === dA, neg: s => oA(-s, e), eql: (s, E) => s === E, sqr: s => oA(s * s, e), add: (s, E) => oA(s + E, e), sub: (s, E) => oA(s - E, e), mul: (s, E) => oA(s * E, e), pow: (s, E) => iy(Q, s, E), div: (s, E) => oA(s * Oo(E, e), e), sqrN: s => s * s, addN: (s, E) => s + E, subN: (s, E) => s - E, mulN: (s, E) => s * E, inv: s => Oo(s, e), sqrt: i || (s => (B || (B = ey(e)), B(Q, s))), toBytes: s => g ? XE(s, C) : WE(s, C), fromBytes: (s, E = !0) => { if (r) { if (!r.includes(s.length) || s.length > C) throw new Error("Field.fromBytes: expected " + r + " bytes, got " + s.length); const c = new Uint8Array(C); c.set(s, g ? 0 : c.length - s.length), s = c } if (s.length !== C) throw new Error("Field.fromBytes: expected " + C + " bytes, got " + s.length); let a = g ? lg(s) : Pf(s); if (n && (a = oA(a, e)), !E && !Q.isValid(a)) throw new Error("invalid field element: outside of range 0..ORDER"); return a }, invertBatch: s => ic(Q, s), cmov: (s, E, a) => a ? E : s }); return Object.freeze(Q) } const II = BigInt(0), yi = BigInt(1); function To(e, A) { const g = A.negate(); return e ? g : A } function Gt(e, A) { const g = ic(e.Fp, A.map(I => I.Z)); return A.map((I, t) => e.fromAffine(I.toAffine(g[t]))) } function nc(e, A) { if (!Number.isSafeInteger(e) || e <= 0 || e > A) throw new Error("invalid window size, expected [1.." + A + "], got W=" + e) } function gi(e, A) { nc(e, A); const g = Math.ceil(A / e) + 1, I = 2 ** (e - 1), t = 2 ** e, i = Fr(e), n = BigInt(e); return { windows: g, windowSize: I, mask: i, maxNumber: t, shiftBy: n } } function Zo(e, A, g) { const { windowSize: I, mask: t, maxNumber: i, shiftBy: n } = g; let r = Number(e & t), o = e >> n; r > I && (r -= i, o += yi); const C = A * I, B = C + Math.abs(r) - 1, Q = r === 0, s = r < 0, E = A % 2 !== 0; return { nextN: o, offset: B, isZero: Q, isNeg: s, isNegF: E, offsetF: C } } function ry(e, A) { if (!Array.isArray(e)) throw new Error("array expected"); e.forEach((g, I) => { if (!(g instanceof A)) throw new Error("invalid point at index " + I) }) } function oy(e, A) { if (!Array.isArray(e)) throw new Error("array of scalars expected"); e.forEach((g, I) => { if (!A.isValid(g)) throw new Error("invalid scalar at index " + I) }) } const ti = new WeakMap, rc = new WeakMap; function Ii(e) { return rc.get(e) || 1 } function Po(e) { if (e !== II) throw new Error("invalid wNAF") } class Cy { constructor(A, g) { this.BASE = A.BASE, this.ZERO = A.ZERO, this.Fn = A.Fn, this.bits = g } _unsafeLadder(A, g, I = this.ZERO) { let t = A; for (; g > II;)g & yi && (I = I.add(t)), t = t.double(), g >>= yi; return I } precomputeWindow(A, g) { const { windows: I, windowSize: t } = gi(g, this.bits), i = []; let n = A, r = n; for (let o = 0; o < I; o++) { r = n, i.push(r); for (let C = 1; C < t; C++)r = r.add(n), i.push(r); n = r.double() } return i } wNAF(A, g, I) { if (!this.Fn.isValid(I)) throw new Error("invalid scalar"); let t = this.ZERO, i = this.BASE; const n = gi(A, this.bits); for (let r = 0; r < n.windows; r++) { const { nextN: o, offset: C, isZero: B, isNeg: Q, isNegF: s, offsetF: E } = Zo(I, r, n); I = o, B ? i = i.add(To(s, g[E])) : t = t.add(To(Q, g[C])) } return Po(I), { p: t, f: i } } wNAFUnsafe(A, g, I, t = this.ZERO) { const i = gi(A, this.bits); for (let n = 0; n < i.windows && I !== II; n++) { const { nextN: r, offset: o, isZero: C, isNeg: B } = Zo(I, n, i); if (I = r, !C) { const Q = g[o]; t = t.add(B ? Q.negate() : Q) } } return Po(I), t } getPrecomputes(A, g, I) { let t = ti.get(g); return t || (t = this.precomputeWindow(g, A), A !== 1 && (typeof I == "function" && (t = I(t)), ti.set(g, t))), t } cached(A, g, I) { const t = Ii(A); return this.wNAF(t, this.getPrecomputes(t, A, I), g) } unsafe(A, g, I, t) { const i = Ii(A); return i === 1 ? this._unsafeLadder(A, g, t) : this.wNAFUnsafe(i, this.getPrecomputes(i, A, I), g, t) } createCache(A, g) { nc(g, this.bits), rc.set(A, g), ti.delete(A) } hasCache(A) { return Ii(A) !== 1 } } function By(e, A, g, I) { ry(g, e), oy(I, A); const t = g.length, i = I.length; if (t !== i) throw new Error("arrays of points and scalars must have equal length"); const n = e.ZERO, r = Wf(BigInt(t)); let o = 1; r > 12 ? o = r - 3 : r > 4 ? o = r - 2 : r > 0 && (o = 2); const C = Fr(o), B = new Array(Number(C) + 1).fill(n), Q = Math.floor((A.BITS - 1) / o) * o; let s = n; for (let E = Q; E >= 0; E -= o) { B.fill(n); for (let c = 0; c < i; c++) { const u = I[c], h = Number(u >> BigInt(E) & C); B[h] = B[h].add(g[c]) } let a = n; for (let c = B.length - 1, u = n; c > 0; c--)u = u.add(B[c]), a = a.add(u); if (s = s.add(a), E !== 0) for (let c = 0; c < o; c++)s = s.double() } return s } function Vo(e, A, g) { if (A) { if (A.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n"); return Iy(A), A } else return Et(e, { isLE: g }) } function Qy(e, A, g = {}, I) { if (I === void 0 && (I = e === "edwards"), !A || typeof A != "object") throw new Error(`expected valid ${e} CURVE object`); for (const o of ["p", "n", "h"]) { const C = A[o]; if (!(typeof C == "bigint" && C > II)) throw new Error(`CURVE.${o} must be positive bigint`) } const t = Vo(A.p, g.Fp, I), i = Vo(A.n, g.Fn, I), r = ["Gx", "Gy", "a", "d"]; for (const o of r) if (!t.isValid(A[o])) throw new Error(`CURVE.${o} must be valid field element of CURVE.Fp`); return A = Object.freeze(Object.assign({}, A)), { CURVE: A, Fp: t, Fn: i } } const ue = BigInt(0), QA = BigInt(1), ii = BigInt(2), sy = BigInt(8); function ay(e, A, g, I) { const t = e.sqr(g), i = e.sqr(I), n = e.add(e.mul(A.a, t), i), r = e.add(e.ONE, e.mul(A.d, e.mul(t, i))); return e.eql(n, r) } function Ey(e, A = {}) { const g = Qy("edwards", e, A, A.FpFnLE), { Fp: I, Fn: t } = g; let i = g.CURVE; const { h: n } = i; JI(A, {}, { uvRatio: "function" }); const r = ii << BigInt(t.BYTES * 8) - QA, o = u => I.create(u), C = A.uvRatio || ((u, h) => { try { return { isValid: !0, value: I.sqrt(I.div(u, h)) } } catch { return { isValid: !1, value: ue } } }); if (!ay(I, i, i.Gx, i.Gy)) throw new Error("bad curve params: generator point"); function B(u, h, d = !1) { const w = d ? QA : ue; return tI("coordinate " + u, h, w, r), h } function Q(u) { if (!(u instanceof a)) throw new Error("ExtendedPoint expected") } const s = zo((u, h) => { const { X: d, Y: w, Z: f } = u, F = u.is0(); h == null && (h = F ? sy : I.inv(f)); const Y = o(d * h), O = o(w * h), v = I.mul(f, h); if (F) return { x: ue, y: QA }; if (v !== QA) throw new Error("invZ was invalid"); return { x: Y, y: O } }), E = zo(u => { const { a: h, d } = i; if (u.is0()) throw new Error("bad point: ZERO"); const { X: w, Y: f, Z: F, T: Y } = u, O = o(w * w), v = o(f * f), p = o(F * F), k = o(p * p), S = o(O * h), K = o(p * o(S + v)), M = o(k + o(d * o(O * v))); if (K !== M) throw new Error("bad point: equation left != right (1)"); const m = o(w * f), b = o(F * Y); if (m !== b) throw new Error("bad point: equation left != right (2)"); return !0 }); class a { constructor(h, d, w, f) { this.X = B("x", h), this.Y = B("y", d), this.Z = B("z", w, !0), this.T = B("t", f), Object.freeze(this) } static CURVE() { return i } static fromAffine(h) { if (h instanceof a) throw new Error("extended point not allowed"); const { x: d, y: w } = h || {}; return B("x", d), B("y", w), new a(d, w, QA, o(d * w)) } static fromBytes(h, d = !1) { const w = I.BYTES, { a: f, d: F } = i; h = xo(Kt(h, w, "point")), fi(d, "zip215"); const Y = xo(h), O = h[w - 1]; Y[w - 1] = O & -129; const v = lg(Y), p = d ? r : I.ORDER; tI("point.y", v, ue, p); const k = o(v * v), S = o(k - QA), K = o(F * k - f); let { isValid: M, value: m } = C(S, K); if (!M) throw new Error("bad point: invalid y coordinate"); const b = (m & QA) === QA, j = (O & 128) !== 0; if (!d && m === ue && j) throw new Error("bad point: x=0 and x_0=1"); return j !== b && (m = o(-m)), a.fromAffine({ x: m, y: v }) } static fromHex(h, d = !1) { return a.fromBytes(_A("point", h), d) } get x() { return this.toAffine().x } get y() { return this.toAffine().y } precompute(h = 8, d = !0) { return c.createCache(this, h), d || this.multiply(ii), this } assertValidity() { E(this) } equals(h) { Q(h); const { X: d, Y: w, Z: f } = this, { X: F, Y, Z: O } = h, v = o(d * O), p = o(F * f), k = o(w * O), S = o(Y * f); return v === p && k === S } is0() { return this.equals(a.ZERO) } negate() { return new a(o(-this.X), this.Y, this.Z, o(-this.T)) } double() { const { a: h } = i, { X: d, Y: w, Z: f } = this, F = o(d * d), Y = o(w * w), O = o(ii * o(f * f)), v = o(h * F), p = d + w, k = o(o(p * p) - F - Y), S = v + Y, K = S - O, M = v - Y, m = o(k * K), b = o(S * M), j = o(k * M), J = o(K * S); return new a(m, b, J, j) } add(h) { Q(h); const { a: d, d: w } = i, { X: f, Y: F, Z: Y, T: O } = this, { X: v, Y: p, Z: k, T: S } = h, K = o(f * v), M = o(F * p), m = o(O * w * S), b = o(Y * k), j = o((f + F) * (v + p) - K - M), J = b - m, T = b + m, G = o(M - d * K), Z = o(j * J), eA = o(T * G), X = o(j * G), cA = o(J * T); return new a(Z, eA, cA, X) } subtract(h) { return this.add(h.negate()) } multiply(h) { if (!t.isValidNot0(h)) throw new Error("invalid scalar: expected 1 <= sc < curve.n"); const { p: d, f: w } = c.cached(this, h, f => Gt(a, f)); return Gt(a, [d, w])[0] } multiplyUnsafe(h, d = a.ZERO) { if (!t.isValid(h)) throw new Error("invalid scalar: expected 0 <= sc < curve.n"); return h === ue ? a.ZERO : this.is0() || h === QA ? this : c.unsafe(this, h, w => Gt(a, w), d) } isSmallOrder() { return this.multiplyUnsafe(n).is0() } isTorsionFree() { return c.unsafe(this, i.n).is0() } toAffine(h) { return s(this, h) } clearCofactor() { return n === QA ? this : this.multiplyUnsafe(n) } toBytes() { const { x: h, y: d } = this.toAffine(), w = I.toBytes(d); return w[w.length - 1] |= h & QA ? 128 : 0, w } toHex() { return kr(this.toBytes()) } toString() { return `<Point ${this.is0() ? "ZERO" : this.toHex()}>` } get ex() { return this.X } get ey() { return this.Y } get ez() { return this.Z } get et() { return this.T } static normalizeZ(h) { return Gt(a, h) } static msm(h, d) { return By(a, t, h, d) } _setWindowSize(h) { this.precompute(h) } toRawBytes() { return this.toBytes() } } a.BASE = new a(i.Gx, i.Gy, QA, o(i.Gx * i.Gy)), a.ZERO = new a(ue, QA, QA, ue), a.Fp = I, a.Fn = t; const c = new Cy(a, t.BITS); return a.BASE.precompute(8), a } function cy(e, A, g = {}) { if (typeof A != "function") throw new Error('"hash" function param is required'); JI(g, {}, { adjustScalarBytes: "function", randomBytes: "function", domain: "function", prehash: "function", mapToCurve: "function" }); const { prehash: I } = g, { BASE: t, Fp: i, Fn: n } = e, r = g.randomBytes || LE, o = g.adjustScalarBytes || (p => p), C = g.domain || ((p, k, S) => { if (fi(S, "phflag"), k.length || S) throw new Error("Contexts/pre-hash are not supported"); return p }); function B(p) { return n.create(lg(p)) } function Q(p) { const k = w.secretKey; p = _A("private key", p, k); const S = _A("hashed private key", A(p), 2 * k), K = o(S.slice(0, k)), M = S.slice(k, 2 * k), m = B(K); return { head: K, prefix: M, scalar: m } } function s(p) { const { head: k, prefix: S, scalar: K } = Q(p), M = t.multiply(K), m = M.toBytes(); return { head: k, prefix: S, scalar: K, point: M, pointBytes: m } } function E(p) { return s(p).pointBytes } function a(p = Uint8Array.of(), ...k) { const S = Mo(...k); return B(A(C(S, _A("context", p), !!I))) } function c(p, k, S = {}) { p = _A("message", p), I && (p = I(p)); const { prefix: K, scalar: M, pointBytes: m } = s(k), b = a(S.context, K, p), j = t.multiply(b).toBytes(), J = a(S.context, j, m, p), T = n.create(b + J * M); if (!n.isValid(T)) throw new Error("sign failed: invalid s"); const G = Mo(j, n.toBytes(T)); return Kt(G, w.signature, "result") } const u = { zip215: !0 }; function h(p, k, S, K = u) { const { context: M, zip215: m } = K, b = w.signature; p = _A("signature", p, b), k = _A("message", k), S = _A("publicKey", S, w.publicKey), m !== void 0 && fi(m, "zip215"), I && (k = I(k)); const j = b / 2, J = p.subarray(0, j), T = lg(p.subarray(j, b)); let G, Z, eA; try { G = e.fromBytes(S, m), Z = e.fromBytes(J, m), eA = t.multiplyUnsafe(T) } catch { return !1 } if (!m && G.isSmallOrder()) return !1; const X = a(M, Z.toBytes(), G.toBytes(), k); return Z.add(G.multiplyUnsafe(X)).subtract(eA).clearCofactor().is0() } const d = i.BYTES, w = { secretKey: d, publicKey: d, signature: 2 * d, seed: d }; function f(p = r(w.seed)) { return Kt(p, w.seed, "seed") } function F(p) { const k = v.randomSecretKey(p); return { secretKey: k, publicKey: E(k) } } function Y(p) { return YI(p) && p.length === n.BYTES } function O(p, k) { try { return !!e.fromBytes(p, k) } catch { return !1 } } const v = { getExtendedPublicKey: s, randomSecretKey: f, isValidSecretKey: Y, isValidPublicKey: O, toMontgomery(p) { const { y: k } = e.fromBytes(p), S = w.publicKey, K = S === 32; if (!K && S !== 57) throw new Error("only defined for 25519 and 448"); const M = K ? i.div(QA + k, QA - k) : i.div(k - QA, k + QA); return i.toBytes(M) }, toMontgomerySecret(p) { const k = w.secretKey; Kt(p, k); const S = A(p.subarray(0, k)); return o(S).subarray(0, k) }, randomPrivateKey: f, precompute(p = 8, k = e.BASE) { return k.precompute(p, !1) } }; return Object.freeze({ keygen: F, getPublicKey: E, sign: c, verify: h, utils: v, Point: e, lengths: w }) } function uy(e) { const A = { a: e.a, d: e.d, p: e.Fp.ORDER, n: e.n, h: e.h, Gx: e.Gx, Gy: e.Gy }, g = e.Fp, I = Et(A.n, e.nBitLength, !0), t = { Fp: g, Fn: I, uvRatio: e.uvRatio }, i = { randomBytes: e.randomBytes, adjustScalarBytes: e.adjustScalarBytes, domain: e.domain, prehash: e.prehash, mapToCurve: e.mapToCurve }; return { CURVE: A, curveOpts: t, hash: e.hash, eddsaOpts: i } } function hy(e, A) { const g = A.Point; return Object.assign({}, A, { ExtendedPoint: g, CURVE: e, nBitLength: g.Fn.BITS, nByteLength: g.Fn.BYTES }) } function ly(e) { const { CURVE: A, curveOpts: g, hash: I, eddsaOpts: t } = uy(e), i = Ey(A, g), n = cy(i, I, t); return hy(e, n) } const kg = BigInt(0), tg = BigInt(1), St = BigInt(2); function wy(e) { return JI(e, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...e }) } function dy(e) { const A = wy(e), { P: g, type: I, adjustScalarBytes: t, powPminus2: i, randomBytes: n } = A, r = I === "x25519"; if (!r && I !== "x448") throw new Error("invalid type"); const o = n || LE, C = r ? 255 : 448, B = r ? 32 : 56, Q = BigInt(r ? 9 : 5), s = BigInt(r ? 121665 : 39081), E = r ? St ** BigInt(254) : St ** BigInt(447), a = r ? BigInt(8) * St ** BigInt(251) - tg : BigInt(4) * St ** BigInt(445) - tg, c = E + a + tg, u = M => oA(M, g), h = d(Q); function d(M) { return XE(u(M), B) } function w(M) { const m = _A("u coordinate", M, B); return r && (m[31] &= 127), u(lg(m)) } function f(M) { return lg(t(_A("scalar", M, B))) } function F(M, m) { const b = v(w(m), f(M)); if (b === kg) throw new Error("invalid private or public key received"); return d(b) } function Y(M) { return F(M, h) } function O(M, m, b) { const j = u(M * (m - b)); return m = u(m - j), b = u(b + j), { x_2: m, x_3: b } } function v(M, m) { tI("u", M, kg, g), tI("scalar", m, E, c); const b = m, j = M; let J = tg, T = kg, G = M, Z = tg, eA = kg; for (let cA = BigInt(C - 1); cA >= kg; cA--) { const ZA = b >> cA & tg; eA ^= ZA, { x_2: J, x_3: G } = O(eA, J, G), { x_2: T, x_3: Z } = O(eA, T, Z), eA = ZA; const PA = J + T, VA = u(PA * PA), WA = J - T, Ie = u(WA * WA), ie = VA - Ie, Bu = G + Z, Qu = G - Z, Vr = u(Qu * PA), Wr = u(Bu * WA), Xr = Vr + Wr, _r = Vr - Wr; G = u(Xr * Xr), Z = u(j * u(_r * _r)), J = u(VA * Ie), T = u(ie * (VA + u(s * ie))) } ({ x_2: J, x_3: G } = O(eA, J, G)), { x_2: T, x_3: Z } = O(eA, T, Z); const X = i(T); return u(J * X) } const p = { secretKey: B, publicKey: B, seed: B }, k = (M = o(B)) => (ge(M, p.seed), M); function S(M) { const m = k(M); return { secretKey: m, publicKey: Y(m) } } return { keygen: S, getSharedSecret: (M, m) => F(M, m), getPublicKey: M => Y(M), scalarMult: F, scalarMultBase: Y, utils: { randomSecretKey: k, randomPrivateKey: k }, GuBytes: h.slice(), lengths: p } } const Dy = BigInt(1), Wo = BigInt(2), fy = BigInt(3), yy = BigInt(5), py = BigInt(8), Rr = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), oc = { p: Rr, n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: py, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") }; function Cc(e) { const A = BigInt(10), g = BigInt(20), I = BigInt(40), t = BigInt(80), i = Rr, r = e * e % i * e % i, o = LA(r, Wo, i) * r % i, C = LA(o, Dy, i) * e % i, B = LA(C, yy, i) * C % i, Q = LA(B, A, i) * B % i, s = LA(Q, g, i) * Q % i, E = LA(s, I, i) * s % i, a = LA(E, t, i) * E % i, c = LA(a, t, i) * E % i, u = LA(c, A, i) * B % i; return { pow_p_5_8: LA(u, Wo, i) * e % i, b2: r } } function Bc(e) { return e[0] &= 248, e[31] &= 127, e[31] |= 64, e } const Xo = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); function my(e, A) { const g = Rr, I = oA(A * A * A, g), t = oA(I * I * A, g), i = Cc(e * t).pow_p_5_8; let n = oA(e * I * i, g); const r = oA(A * n * n, g), o = n, C = oA(n * Xo, g), B = r === e, Q = r === oA(-e, g), s = r === oA(-e * Xo, g); return B && (n = o), (Q || s) && (n = C), gy(n, g) && (n = oA(-n, g)), { isValid: B || Q, value: n } } const Qc = Et(oc.p, { isLE: !0 }), Ny = { ...oc, Fp: Qc, hash: Zf, adjustScalarBytes: Bc, uvRatio: my }, Mt = ly(Ny), pi = (() => { const e = Qc.ORDER; return dy({ P: e, type: "x25519", powPminus2: A => { const { pow_p_5_8: g, b2: I } = Cc(A); return oA(LA(g, fy, e) * I, e) }, adjustScalarBytes: Bc }) })(); function he(e, A, g, I, t) { return e = e + A + t | 0, I = gI(I ^ e, 16), g = g + I | 0, A = gI(A ^ g, 12), { a: e, b: A, c: g, d: I } } function le(e, A, g, I, t) { return e = e + A + t | 0, I = gI(I ^ e, 8), g = g + I | 0, A = gI(A ^ g, 7), { a: e, b: A, c: g, d: I } } class ky extends HE { constructor(A, g) { super(), this.finished = !1, this.destroyed = !1, this.length = 0, this.pos = 0, AI(A), AI(g), this.blockLen = A, this.outputLen = g, this.buffer = new Uint8Array(A), this.buffer32 = eI(this.buffer) } update(A) { $g(this), A = hg(A), ge(A); const { blockLen: g, buffer: I, buffer32: t } = this, i = A.length, n = A.byteOffset, r = A.buffer; for (let o = 0; o < i;) { this.pos === g && (kA(t), this.compress(t, 0, !1), kA(t), this.pos = 0); const C = Math.min(g - this.pos, i - o), B = n + o; if (C === g && !(B % 4) && o + C < i) { const Q = new Uint32Array(r, B, Math.floor((i - o) / 4)); kA(Q); for (let s = 0; o + g < i; s += t.length, o += g)this.length += g, this.compress(Q, s, !1); kA(Q); continue } I.set(A.subarray(o, o + C), this.pos), this.pos += C, this.length += C, o += C } return this } digestInto(A) { $g(this), Nr(A, this); const { pos: g, buffer32: I } = this; this.finished = !0, Le(this.buffer.subarray(g)), kA(I), this.compress(I, 0, !0), kA(I); const t = eI(A); this.get().forEach((i, n) => t[n] = XD(i)) } digest() { const { buffer: A, outputLen: g } = this; this.digestInto(A); const I = A.slice(0, g); return this.destroy(), I } _cloneInto(A) { const { buffer: g, length: I, finished: t, destroyed: i, outputLen: n, pos: r } = this; return A || (A = new this.constructor({ dkLen: n })), A.set(...this.get()), A.buffer.set(g), A.destroyed = i, A.finished = t, A.length = I, A.pos = r, A.outputLen = n, A } clone() { return this._cloneInto() } } function _o(e, A, g, I, t, i, n, r, o, C, B, Q, s, E, a, c, u, h, d, w) { let f = 0; for (let F = 0; F < I; F++)({ a: t, b: o, c: s, d: u } = he(t, o, s, u, g[A + e[f++]])), { a: t, b: o, c: s, d: u } = le(t, o, s, u, g[A + e[f++]]), { a: i, b: C, c: E, d: h } = he(i, C, E, h, g[A + e[f++]]), { a: i, b: C, c: E, d: h } = le(i, C, E, h, g[A + e[f++]]), { a: n, b: B, c: a, d } = he(n, B, a, d, g[A + e[f++]]), { a: n, b: B, c: a, d } = le(n, B, a, d, g[A + e[f++]]), { a: r, b: Q, c, d: w } = he(r, Q, c, w, g[A + e[f++]]), { a: r, b: Q, c, d: w } = le(r, Q, c, w, g[A + e[f++]]), { a: t, b: C, c: a, d: w } = he(t, C, a, w, g[A + e[f++]]), { a: t, b: C, c: a, d: w } = le(t, C, a, w, g[A + e[f++]]), { a: i, b: B, c, d: u } = he(i, B, c, u, g[A + e[f++]]), { a: i, b: B, c, d: u } = le(i, B, c, u, g[A + e[f++]]), { a: n, b: Q, c: s, d: h } = he(n, Q, s, h, g[A + e[f++]]), { a: n, b: Q, c: s, d: h } = le(n, Q, s, h, g[A + e[f++]]), { a: r, b: o, c: E, d } = he(r, o, E, d, g[A + e[f++]]), { a: r, b: o, c: E, d } = le(r, o, E, d, g[A + e[f++]]); return { v0: t, v1: i, v2: n, v3: r, v4: o, v5: C, v6: B, v7: Q, v8: s, v9: E, v10: a, v11: c, v12: u, v13: h, v14: d, v15: w } } const XA = { CHUNK_START: 1, CHUNK_END: 2, PARENT: 4, ROOT: 8, KEYED_HASH: 16, DERIVE_KEY_CONTEXT: 32, DERIVE_KEY_MATERIAL: 64 }, oe = nf.slice(), $o = (() => { const e = Array.from({ length: 16 }, (I, t) => t), A = I => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map(t => I[t]), g = []; for (let I = 0, t = e; I < 7; I++, t = A(t))g.push(...t); return Uint8Array.from(g) })(); class br extends ky { constructor(A = {}, g = 0) { super(64, A.dkLen === void 0 ? 32 : A.dkLen), this.chunkPos = 0, this.chunksDone = 0, this.flags = 0, this.stack = [], this.posOut = 0, this.bufferOut32 = new Uint32Array(16), this.chunkOut = 0, this.enableXOF = !0; const { key: I, context: t } = A, i = t !== void 0; if (I !== void 0) { if (i) throw new Error('Only "key" or "context" can be specified at same time'); const n = hg(I).slice(); ge(n, 32), this.IV = eI(n), kA(this.IV), this.flags = g | XA.KEYED_HASH } else if (i) { const n = hg(t), r = new br({ dkLen: 32 }, XA.DERIVE_KEY_CONTEXT).update(n).digest(); this.IV = eI(r), kA(this.IV), this.flags = g | XA.DERIVE_KEY_MATERIAL } else this.IV = oe.slice(), this.flags = g; this.state = this.IV.slice(), this.bufferOut = WD(this.bufferOut32) } get() { return [] } set() { } b2Compress(A, g, I, t = 0) { const { state: i, pos: n } = this, { h: r, l: o } = di(BigInt(A), !0), { v0: C, v1: B, v2: Q, v3: s, v4: E, v5: a, v6: c, v7: u, v8: h, v9: d, v10: w, v11: f, v12: F, v13: Y, v14: O, v15: v } = _o($o, t, I, 7, i[0], i[1], i[2], i[3], i[4], i[5], i[6], i[7], oe[0], oe[1], oe[2], oe[3], r, o, n, g); i[0] = C ^ h, i[1] = B ^ d, i[2] = Q ^ w, i[3] = s ^ f, i[4] = E ^ F, i[5] = a ^ Y, i[6] = c ^ O, i[7] = u ^ v } compress(A, g = 0, I = !1) { let t = this.flags; if (this.chunkPos || (t |= XA.CHUNK_START), (this.chunkPos === 15 || I) && (t |= XA.CHUNK_END), I || (this.pos = this.blockLen), this.b2Compress(this.chunksDone, t, A, g), this.chunkPos += 1, this.chunkPos === 16 || I) { let i = this.state; this.state = this.IV.slice(); for (let n, r = this.chunksDone + 1; (I || !(r & 1)) && (n = this.stack.pop()); r >>= 1)this.buffer32.set(n, 0), this.buffer32.set(i, 8), this.pos = this.blockLen, this.b2Compress(0, this.flags | XA.PARENT, this.buffer32, 0), i = this.state, this.state = this.IV.slice(); this.chunksDone++, this.chunkPos = 0, this.stack.push(i) } this.pos = 0 } _cloneInto(A) { A = super._cloneInto(A); const { IV: g, flags: I, state: t, chunkPos: i, posOut: n, chunkOut: r, stack: o, chunksDone: C } = this; return A.state.set(t.slice()), A.stack = o.map(B => Uint32Array.from(B)), A.IV.set(g), A.flags = I, A.chunkPos = i, A.chunksDone = C, A.posOut = n, A.chunkOut = r, A.enableXOF = this.enableXOF, A.bufferOut32.set(this.bufferOut32), A } destroy() { this.destroyed = !0, Le(this.state, this.buffer32, this.IV, this.bufferOut32), Le(...this.stack) } b2CompressOut() { const { state: A, pos: g, flags: I, buffer32: t, bufferOut32: i } = this, { h: n, l: r } = di(BigInt(this.chunkOut++)); kA(t); const { v0: o, v1: C, v2: B, v3: Q, v4: s, v5: E, v6: a, v7: c, v8: u, v9: h, v10: d, v11: w, v12: f, v13: F, v14: Y, v15: O } = _o($o, 0, t, 7, A[0], A[1], A[2], A[3], A[4], A[5], A[6], A[7], oe[0], oe[1], oe[2], oe[3], r, n, g, I); i[0] = o ^ u, i[1] = C ^ h, i[2] = B ^ d, i[3] = Q ^ w, i[4] = s ^ f, i[5] = E ^ F, i[6] = a ^ Y, i[7] = c ^ O, i[8] = A[0] ^ u, i[9] = A[1] ^ h, i[10] = A[2] ^ d, i[11] = A[3] ^ w, i[12] = A[4] ^ f, i[13] = A[5] ^ F, i[14] = A[6] ^ Y, i[15] = A[7] ^ O, kA(t), kA(i), this.posOut = 0 } finish() { if (this.finished) return; this.finished = !0, Le(this.buffer.subarray(this.pos)); let A = this.flags | XA.ROOT; this.stack.length ? (A |= XA.PARENT, kA(this.buffer32), this.compress(this.buffer32, 0, !0), kA(this.buffer32), this.chunksDone = 0, this.pos = this.blockLen) : A |= (this.chunkPos ? 0 : XA.CHUNK_START) | XA.CHUNK_END, this.flags = A, this.b2CompressOut() } writeInto(A) { $g(this, !1), ge(A), this.finish(); const { blockLen: g, bufferOut: I } = this; for (let t = 0, i = A.length; t < i;) { this.posOut >= g && this.b2CompressOut(); const n = Math.min(g - this.posOut, i - t); A.set(I.subarray(this.posOut, this.posOut + n), t), this.posOut += n, t += n } return A } xofInto(A) { if (!this.enableXOF) throw new Error("XOF is not possible after digest call"); return this.writeInto(A) } xof(A) { return AI(A), this.xofInto(new Uint8Array(A)) } digestInto(A) { if (Nr(A, this), this.finished) throw new Error("digest() was already called"); return this.enableXOF = !1, this.writeInto(A), this.destroy(), A } digest() { return this.digestInto(new Uint8Array(this.outputLen)) } } const iI = gf(e => new br(e)), AC = new Map; function eC(e, A) { const g = `${e}-${A}`; let I = AC.get(g); if (!I) { const t = _.decode(e.substring(14)), i = _.decode(A.substring(8)); I = pi.getSharedSecret(t, i), AC.set(g, I) } return I } class HI extends pE { static async create() { return new HI } blake3HashOnce(A) { return iI(A) } blake3HashOnceWithContext(A, { context: g }) { return iI.create({}).update(g).update(A).digest() } generateNonce(A) { return this.blake3HashOnce(A).slice(0, 24) } generateJsonNonce(A) { return this.generateNonce(gA.encode($(A))) } newEd25519SigningKey() { return Mt.utils.randomPrivateKey() } getSignerID(A) { return `signer_z${_.encode(Mt.getPublicKey(_.decode(A.substring(14))))}` } sign(A, g) { const I = Mt.sign(gA.encode($(g)), _.decode(A.substring(14))); return `signature_z${_.encode(I)}` } verify(A, g, I) { return Mt.verify(_.decode(A.substring(11)), gA.encode($(g)), _.decode(I.substring(8))) } newX25519StaticSecret() { return pi.utils.randomPrivateKey() } getSealerID(A) { return `sealer_z${_.encode(pi.getPublicKey(_.decode(A.substring(14))))}` } encrypt(A, g, I) { const t = _.decode(g.substring(11)), i = this.generateJsonNonce(I), n = gA.encode($(A)), r = qg(t, i, n); return `encrypted_U${ug(r)}` } decryptRaw(A, g, I) { const t = _.decode(g.substring(11)), i = this.generateJsonNonce(I), n = cg(A.substring(11)), r = qg(t, i, n); return Xg.decode(r) } seal({ message: A, from: g, to: I, nOnceMaterial: t }) { const i = eC(g, I), n = this.generateJsonNonce(t), r = gA.encode($(A)), o = Jo(i, n).encrypt(r); return `sealed_U${ug(o)}` } unseal(A, g, I, t) { const i = this.generateJsonNonce(t), n = eC(g, I), r = cg(A.substring(8)), o = Jo(n, i).decrypt(r); try { return JSON.parse(Xg.decode(o)) } catch (C) { x.error("Failed to decrypt/parse sealed message", { err: C }); return } } createSessionLog(A, g, I) { return new Yr(A, g, I, this) } } class Yr { constructor(A, g, I, t) { this.coID = A, this.sessionID = g, this.signerID = I, this.crypto = t, this.transactions = [], this.streamingHash = iI.create({}) } clone() { const A = new Yr(this.coID, this.sessionID, this.signerID, this.crypto); return A.transactions = this.transactions.slice(), A.lastSignature = this.lastSignature, A.streamingHash = this.streamingHash.clone(), A } tryAdd(A, g, I) { this.internalTryAdd(A.map(t => $(t)), g, I) } internalTryAdd(A, g, I) { for (const t of A) this.streamingHash.update(gA.encode(t)); if (!I) { if (!this.signerID) throw new Error("Tried to add transactions without signer ID"); const t = this.streamingHash.clone().digest(), i = `hash_z${_.encode(t)}`; if (!this.crypto.verify(g, i, this.signerID)) { this.streamingHash = iI.create({}); for (const n of this.transactions) this.streamingHash.update(gA.encode(n)); throw new Error("Signature verification failed") } } for (const t of A) this.transactions.push(t); return this.lastSignature = g, g } internalAddNewTransaction(A, g) { this.streamingHash.update(gA.encode(A)); const I = this.streamingHash.clone().digest(), t = `hash_z${_.encode(I)}`, i = this.crypto.sign(g.currentSignerSecret(), t); return this.transactions.push(A), this.lastSignature = i, i } addNewPrivateTransaction(A, g, I, t, i, n) { const r = this.crypto.encrypt(g, t, { in: this.coID, tx: { sessionID: this.sessionID, txIndex: this.transactions.length } }), o = n ? this.crypto.encrypt(n, t, { in: this.coID, tx: { sessionID: this.sessionID, txIndex: this.transactions.length } }) : void 0, C = { encryptedChanges: r, madeAt: i, privacy: "private", keyUsed: I, meta: o }; return { signature: this.internalAddNewTransaction($(C), A), transaction: C } } addNewTrustingTransaction(A, g, I, t) { const i = { changes: $(g), madeAt: I, privacy: "trusting", meta: t ? $(t) : void 0 }; return { signature: this.internalAddNewTransaction($(i), A), transaction: i } } decryptNextTransactionChangesJson(A, g) { const I = this.transactions[A]; if (!I) throw new Error("Transaction not found"); const t = JSON.parse(I); if (t.privacy === "private") { const i = { in: this.coID, tx: { sessionID: this.sessionID, txIndex: A } }; return this.crypto.decryptRaw(t.encryptedChanges, g, i) } else return t.changes } decryptNextTransactionMetaJson(A, g) { const I = this.transactions[A]; if (!I) throw new Error("Transaction not found"); const t = JSON.parse(I); if (t.meta) if (t.privacy === "private") { const i = { in: this.coID, tx: { sessionID: this.sessionID, txIndex: A } }; return this.crypto.decryptRaw(t.meta, g, i) } else return t.meta } free() { } } var mi = {}; QC(mi, { array: () => Qt, base64: () => la, base64url: () => wa, boolean: () => mI, cidrv4: () => ua, cidrv6: () => ha, codec: () => $a, cuid: () => Qa, cuid2: () => sa, date: () => Sa, discriminatedUnion: () => ba, email: () => na, emoji: () => Ca, enum: () => MI, int: () => jt, int32: () => da, intersection: () => nr, ipv4: () => Ea, ipv6: () => ca, iso: () => Ts, json: () => BE, literal: () => La, nanoid: () => Ba, number: () => Og, object: () => Gy, optional: () => ee, record: () => or, strictObject: () => Sy, string: () => bA, templateLiteral: () => tE, tuple: () => SI, ulid: () => aa, union: () => GI, url: () => oa, uuid: () => ra, z: () => we }); function Kr(e) { const A = {}; for (const g of Object.keys(e)) Object.getOwnPropertyDescriptor(e, g)?.get || (A[g] = e[g]); return A } function sA(e, A) { const g = e ? { ...e } : {}; return g.resolve ||= A, g } function Gy(e, A) { return sc(e, "z.object() does not support collaborative types as values. Use co.map() instead"), Fa(e, A) } function Sy(e, A) { return sc(e, "z.strictObject() does not support collaborative types as values. Use co.map() instead"), Ua(e, A) } function sc(e, A) { if (My(e)) throw Error(A) } function My(e) { return Object.values(Kr(e ?? {})).some(Fy) } function Fy(e) { return typeof e == "object" && e !== null && "collaborative" in e && e.collaborative === !0 } var dg = class { constructor() { Object.defineProperties(this, { $isLoaded: { value: !0, enumerable: !1 } }) } static fromRaw(e) { return new this({ fromRaw: e }) } toJSON() { return { id: this.$jazz.id, type: this[q], error: "unknown CoValue class" } } [ke]() { return this.toJSON() } }, Ne = class { constructor(e) { this.coValue = e, Object.defineProperty(this, "_instanceID", { value: `instance-${Math.random().toString(36).slice(2)}`, enumerable: !1 }) } get id() { const e = this.raw.core.getCurrentBranchSourceId(); return e || this.raw.id } get loadingState() { return R.LOADED } get localNode() { return this.raw.core.node } get loadedAs() { const e = this.localNode.getCurrentAgent(); return e instanceof dr ? Hr.get(e.account, () => ut(MA.Account).fromRaw(e.account)) : new Jr(this.localNode) } get createdAt() { const e = this.raw.core.verified.header.meta?.createdAt; return typeof e == "string" ? new Date(e).getTime() : this.raw.core.earliestTxMadeAt } get lastUpdatedAt() { const e = this.raw.core.latestTxMadeAt; return e === 0 ? this.createdAt : e } get branchName() { return this._subscriptionScope?.unstable_branch?.name } get isBranched() { return !!this._subscriptionScope?.unstable_branch } unstable_merge() { const e = this._subscriptionScope; e && gu(e) } }, ke = Symbol.for("nodejs.util.inspect.custom"), W = "$SchemaInit$", AA = "$items$", q = "$type$", MA = {}, ac = class Fe extends dg { constructor(A) { super(); const g = new Proxy(this, Uy); if (A) if ("fromRaw" in A) Object.defineProperties(this, { $jazz: { value: new gC(g, () => A.fromRaw), enumerable: !1 } }); else throw new Error("Invalid CoMap constructor arguments"); return g } static create(A, g) { const I = new this; return Fe._createCoMap(I, A, g) } toJSON(A, g) { const I = { $jazz: { id: this.$jazz.id } }; for (const t of this.$jazz.raw.keys()) { const i = t, n = this.$jazz.getDescriptor(i); if (n) if (n == "json" || "encoded" in n) I[t] = this.$jazz.raw.get(t); else if (BA(n)) { const r = this.$jazz.raw.get(t); if (g?.includes(r) || r === this.$jazz.id) { I[t] = { _circular: r }; continue } const o = this[i]; if (o && typeof o == "object" && "toJSON" in o && typeof o.toJSON == "function") { const C = o.toJSON(i, [...g || [], this.$jazz.id]); I[t] = C } } else I[t] = void 0 } return I } [ke]() { return this.toJSON() } static _createCoMap(A, g, I) { const { owner: t, uniqueness: i } = fg(I); Object.defineProperties(A, { $jazz: { value: new gC(A, () => n), enumerable: !1 } }); const n = Fe.rawFromInit(A, g, t, i); return A } static rawFromInit(A, g, I, t) { const i = I.$jazz.raw, n = {}; if (g) for (const r of Object.keys(g)) { const o = g[r], C = A.$jazz.getDescriptor(r); if (C) if (C === "json") n[r] = o; else if (BA(C)) { if (o != null) { let B = o.$jazz?.id; B || (B = ct(C, o, I).$jazz.id), n[r] = B } } else "encoded" in C && (n[r] = C.encoded.encode(o)) } return i.createMap(n, null, "private", t) } static Record(A) { var g, I; class t extends (I = Fe, g = AA, I) { constructor() { super(...arguments), this[g] = A } } return t } static load(A, g) { return mA(this, A, g) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } static findUnique(A, g, I) { const t = Fe._getUniqueHeader(A, g); return eu(t, I) } static _getUniqueHeader(A, g) { return { type: "comap", ruleset: { type: "ownedByGroup", group: g }, meta: null, uniqueness: A } } static async upsertUnique(A) { const g = Fe._getUniqueHeader(A.unique, A.owner.$jazz.id); return CI(this, { header: g, owner: A.owner, resolve: A.resolve, onCreateWhenMissing: () => { this.create(A.value, { owner: A.owner, unique: A.unique }) }, onUpdateWhenFound(I) { I.$jazz.applyDiff(A.value) } }) } static async loadUnique(A, g, I) { const t = Fe._getUniqueHeader(A, g), i = await Ae.load(g, { loadAs: I?.loadAs }); return i.$isLoaded ? CI(this, { header: t, owner: i, resolve: I?.resolve }) : i } }; ac.prototype[q] = "CoMap"; var vr = ac, gC = class extends Ne { constructor(e, A) { super(e), this.coMap = e, this.getRaw = A } get owner() { return Dg(this.coMap) } has(e) { const A = this.raw.getRaw(e); return A?.change !== void 0 && A.change.op !== "del" } set(e, A) { const g = this.getDescriptor(e); if (!g) throw Error(`Cannot set unknown key ${e}`); let I = A?.$jazz?.id; if (g === "json") this.raw.set(e, A); else if ("encoded" in g) this.raw.set(e, g.encoded.encode(A)); else if (BA(g)) if (A === void 0) { if (!g.optional) throw Error(`Cannot set required reference ${e} to undefined`); this.raw.set(e, null) } else I || (I = ct(g, A, this.owner).$jazz.id), this.raw.set(e, I) } delete(e) { this.raw.delete(e) } applyDiff(e) { for (const A in e) if (Object.prototype.hasOwnProperty.call(e, A)) { const g = A, I = this.getDescriptor(A); if (!I) continue; const t = e[g], i = this.coMap[g]; if (I === "json" || "encoded" in I) i !== t && this.set(g, t); else if (BA(I)) { const n = i?.$jazz.id; let r = t?.$jazz?.id; n !== r && this.set(g, t) } } return this.coMap } ensureLoaded(e) { return lt(this.coMap, e) } subscribe(...e) { const { options: A, listener: g } = yA(e); return Se(this.coMap, A, g) } async waitForSync(e) { await this.raw.core.waitForSync(e) } getDescriptor(e) { return this.schema?.[e] || this.schema?.[AA] } get refs() { return mc(this.coMap, e => this.raw.get(e), () => this.raw.keys().filter(A => { const g = this.getDescriptor(A); return g && g !== "json" && BA(g) }), this.loadedAs, e => this.getDescriptor(e)) } getEdits() { const e = this.coMap; return new Proxy({}, { get(A, g) { const I = e.$jazz.raw.lastEditAt(g); if (!I) return; const t = e.$jazz.getDescriptor(g); if (t) return { ...tC(e, I, t, g), get all() { return [...e.$jazz.raw.editsAt(g)].map(i => tC(e, i, t, g)) } } }, ownKeys(A) { return e.$jazz.raw.keys() }, getOwnPropertyDescriptor(A, g) { return { value: Reflect.get(A, g), writable: !1, enumerable: !0, configurable: !0 } } }) } get raw() { return this.getRaw() } get schema() { return this.coMap.constructor._schema } }, Uy = { get(e, A, g) { if (A === "_schema") return Reflect.get(e, A); if (A in e) return Reflect.get(e, A, g); { if (typeof A != "string") return; const I = e.$jazz.getDescriptor(A); if (!I) return; const t = e.$jazz.raw.get(A); if (I === "json") return t; if ("encoded" in I) return t === void 0 ? void 0 : I.encoded.decode(t); if (BA(I)) return t == null ? void 0 : qr(e, t, A) } }, set(e, A, g, I) { if (typeof A == "string" && typeof g == "object" && g !== null && W in g) return e.constructor._schema ||= {}, e.constructor._schema[A] = g[W], !0; if (!e.$jazz.getDescriptor(A)) return !1; if (typeof A == "string") throw Error("Cannot update a CoMap directly. Use `$jazz.set` instead."); return Reflect.set(e, A, g, I) }, defineProperty(e, A, g) { return "value" in g && typeof g.value == "object" && W in g.value ? (e.constructor._schema ||= {}, e.constructor._schema[A] = g.value[W], !0) : Reflect.defineProperty(e, A, g) }, ownKeys(e) { const A = Reflect.ownKeys(e).filter(g => g !== AA); for (const g of e.$jazz.raw.keys()) A.includes(g) || A.push(g); return A }, getOwnPropertyDescriptor(e, A) { if (A in e) return Reflect.getOwnPropertyDescriptor(e, A); if (e.$jazz.getDescriptor(A) || A in e.$jazz.raw.latest) return { enumerable: !0, configurable: !0, writable: !0 } }, has(e, A) { const g = e.$jazz?.getDescriptor(A); return e.$jazz?.raw && typeof A == "string" && g ? e.$jazz.raw.get(A) !== void 0 : Reflect.has(e, A) }, deleteProperty(e, A) { const g = e.$jazz.getDescriptor(A); if (typeof A == "string" && g) throw Error("Cannot delete a CoMap property directly. Use `$jazz.delete` instead."); return Reflect.deleteProperty(e, A) } }; MA.CoMap = vr; function tC(e, A, g, I) { return { value: g === "json" ? A.value : "encoded" in g ? A.value === null || A.value === void 0 ? A.value : g.encoded.decode(A.value) : Pe(e, A.value, g), ref: g !== "json" && BA(g) ? new Ze(A.value, e.$jazz.loadedAs, g, e) : void 0, get by() { return A.by && Pe(e, A.by, { ref: te, optional: !1 }) }, madeAt: A.at, key: I } } var Ec = class Kg extends Array { static Of(A) { var g, I; return class extends (I = Kg, g = iA.items, I) { constructor() { super(...arguments), this[g] = A } } } static of(...A) { throw new Error("Can't use Array.of with CoLists") } static get [Symbol.species]() { return Array } constructor(A) { super(); const g = new Proxy(this, by); return A && "fromRaw" in A && Object.defineProperties(this, { $jazz: { value: new IC(g, () => A.fromRaw), enumerable: !1 }, $isLoaded: { value: !0, enumerable: !1 } }), g } static create(A, g) { const { owner: I, uniqueness: t } = fg(g), i = new this; Object.defineProperties(i, { $jazz: { value: new IC(i, () => n), enumerable: !1 }, $isLoaded: { value: !0, enumerable: !1 } }); const n = I.$jazz.raw.createList(vg(A, i.$jazz.schema[AA], I), null, "private", t); return i } toJSON(A, g) { const I = this.$jazz.schema[AA]; return I === "json" ? this.$jazz.raw.asArray() : "encoded" in I ? this.$jazz.raw.asArray().map(t => I.encoded.encode(t)) : BA(I) ? this.map((t, i) => g?.includes(t?.$jazz.id) ? { _circular: t.$jazz.id } : t?.toJSON(i + "", [...g || [], this.$jazz.id])) : [] } [ke]() { return this.toJSON() } static fromRaw(A) { return new this({ fromRaw: A }) } static schema(A) { this._schema ||= {}, Object.assign(this._schema, A) } static load(A, g) { return mA(this, A, g) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } static findUnique(A, g, I) { const t = Kg._getUniqueHeader(A, g); return eu(t, I) } static _getUniqueHeader(A, g) { return { type: "colist", ruleset: { type: "ownedByGroup", group: g }, meta: null, uniqueness: A } } static async upsertUnique(A) { const g = Kg._getUniqueHeader(A.unique, A.owner.$jazz.id); return CI(this, { header: g, owner: A.owner, resolve: A.resolve, onCreateWhenMissing: () => { this.create(A.value, { owner: A.owner, unique: A.unique }) }, onUpdateWhenFound(I) { I.$jazz.applyDiff(A.value) } }) } static async loadUnique(A, g, I) { const t = Kg._getUniqueHeader(A, g), i = await Ae.load(g, { loadAs: I?.loadAs }); return i.$isLoaded ? CI(this, { header: t, owner: i, resolve: I?.resolve }) : i } push(...A) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.push` instead.") } unshift(...A) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.unshift` instead.") } pop(A) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.pop` instead.") } shift(A) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.shift` instead.") } splice(A, g, ...I) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.splice` instead.") } copyWithin(A, g, I) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.set` instead.") } fill(A, g, I) { throw new Error("Cannot mutate a CoList directly. Use `.$jazz.set` instead.") } reverse(A) { throw new Error("Cannot mutate a CoList directly. Use `.toReversed` if you want a reversed copy, or `.$jazz.set` to mutate the CoList.") } sort(A) { throw new Error("Cannot mutate a CoList directly. Use `.toSorted` if you want a sorted copy, or `.$jazz.set` to mutate the CoList.") } }; Ec.prototype[q] = "CoList"; var Ry = Ec, IC = class extends Ne { constructor(e, A) { super(e), this.coList = e, this.getRaw = A } get owner() { return Dg(this.coList) } set(e, A) { const g = this.schema[AA], I = vg([A], g, this.owner)[0]; if (I === null && !g.optional) throw new Error(`Cannot set required reference ${e} to undefined`); this.raw.replace(e, I) } push(...e) { return this.raw.appendItems(vg(e, this.schema[AA], this.owner), void 0, "private"), this.raw.entries().length } unshift(...e) { for (const A of vg(e, this.schema[AA], this.owner)) this.raw.prepend(A); return this.raw.entries().length } pop() { const e = this.coList[this.coList.length - 1]; return this.raw.delete(this.coList.length - 1), e } shift() { const e = this.coList[0]; return this.raw.delete(0), e } splice(e, A, ...g) { const I = this.coList.slice(e, e + A); for (let i = e + A - 1; i >= e; i--)this.raw.delete(i); const t = vg(g, this.schema[AA], this.owner); if (t.length === 0) return I; if (t.length === 1) { const i = t[0]; return i === void 0 || (e === 0 ? this.raw.prepend(i) : this.raw.append(i, Math.max(e - 1, 0))), I } if (e === 0) for (let i = t.length - 1; i >= 0; i--) { const n = t[i]; n !== void 0 && this.raw.prepend(n) } else { let i = Math.max(e - 1, 0); for (const n of t) n !== void 0 && (this.raw.append(n, i), i++) } return I } remove(...e) { const A = e[0] instanceof Function ? e[0] : void 0; let g = []; if (A) for (let t = 0; t < this.coList.length; t++)A(this.coList[t], t, this.coList) && g.push(t); else g = e.filter(t => t >= 0 && t < this.coList.length).sort((t, i) => t - i); const I = g.map(t => this.coList[t]); for (const t of g.reverse()) this.raw.delete(t); return I } retain(e) { return this.remove((...A) => !e(...A)) } applyDiff(e) { const A = this.raw.asArray(), g = BA(this.schema[AA]) ? (t, i) => { const n = A[t]?.$jazz?.id, r = e[i]?.$jazz?.id; return !!n && !!r && n === r } : void 0, I = [...OE.calcPatch(A, e, g)]; if (I.length === 0) return this.coList; this.raw.core.pauseNotifyUpdate(); for (const [t, i, n] of I.reverse()) this.splice(t, i - t, ...n); return this.raw.core.resumeNotifyUpdate(), this.coList } ensureLoaded(e) { return lt(this.coList, e) } subscribe(...e) { const { options: A, listener: g } = yA(e); return Se(this.coList, A, g) } async waitForSync(e) { await this.raw.core.waitForSync(e) } getItemsDescriptor() { return this.schema[AA] } get refs() { return mc(this.coList, e => this.raw.get(e), () => Array.from({ length: this.raw.entries().length }, (e, A) => A), this.loadedAs, e => this.schema[AA]) } getEdits() { throw new Error("Not implemented") } get raw() { return this.getRaw() } get schema() { return this.coList.constructor._schema } }; function vg(e, A, g) { let I = []; if (A === "json") I = e; else if ("encoded" in A) I = e?.map(t => A.encoded.encode(t)); else if (BA(A)) I = e?.map(t => { if (t == null) return null; let i = t.$jazz?.id; return i || (i = ct(A, t, g).$jazz.id), i }); else throw new Error("Invalid element descriptor"); return I } var by = { get(e, A, g) { if (typeof A == "string" && !isNaN(+A)) { const I = e.$jazz.schema[AA], t = e.$jazz.raw.get(Number(A)); if (I === "json") return t; if ("encoded" in I) return t === void 0 ? void 0 : I.encoded.decode(t); if (BA(I)) return t == null ? void 0 : qr(e, t, A) } else return A === "length" ? e.$jazz.raw.entries().length : Reflect.get(e, A, g) }, set(e, A, g, I) { if (A === AA && typeof g == "object" && W in g) return e.constructor._schema ||= {}, e.constructor._schema[AA] = g[W], !0; if (typeof A == "string" && !isNaN(+A)) throw Error("Cannot update a CoList directly. Use `$jazz.set` instead."); return Reflect.set(e, A, g, I) }, defineProperty(e, A, g) { return g.value && A === AA && typeof g.value == "object" && W in g.value ? (e.constructor._schema ||= {}, e.constructor._schema[AA] = g.value[W], !0) : Reflect.defineProperty(e, A, g) }, has(e, A) { return typeof A == "string" && !isNaN(+A) ? Number(A) < e.$jazz.raw.entries().length : Reflect.has(e, A) }, ownKeys(e) { const A = Reflect.ownKeys(e), g = e.$jazz.raw.entries().map((I, t) => String(t)); return A.push(...g), A }, getOwnPropertyDescriptor(e, A) { if (A === q) return { enumerable: !1, configurable: !0, writable: !1, value: e[q] }; if (A in e) return Reflect.getOwnPropertyDescriptor(e, A); if (typeof A == "string" && !isNaN(+A)) { const g = Number(A); if (g >= 0 && g < e.$jazz.raw.entries().length) return { enumerable: !0, configurable: !0, writable: !0 } } else if (A === "length") return { enumerable: !1, configurable: !1, writable: !1 } } }, cc = class uc extends dg { static Of(A) { var g, I; const t = class extends (I = uc, g = iA.items, I) { constructor() { super(...arguments), this[g] = A } }; return t._schema ||= {}, t._schema[AA] = A[W], t } get byMe() { if (this.$jazz.loadedAs[q] === "Account") return this.perAccount[this.$jazz.loadedAs.$jazz.id] } get perAccount() { return new Proxy({}, vy(this)) } get perSession() { return new Proxy({}, Jy(this, this)) } get inCurrentSession() { if (this.$jazz.loadedAs[q] === "Account") return this.perSession[this.$jazz.loadedAs.$jazz.sessionID] } constructor(A) { return super(), Object.defineProperties(this, { $jazz: { value: new Ky(this, A.fromRaw), enumerable: !1 } }), this } static create(A, g) { const { owner: I } = fg(g), t = I.$jazz.raw.createStream(), i = new this({ fromRaw: t }); return A && i.$jazz.push(...A), i } toJSON() { const A = this.$jazz.schema[AA], g = A === "json" ? I => I : "encoded" in A ? A.encoded.encode : I => I && I.$jazz.id; return { $jazz: { id: this.$jazz.id }, ...Object.fromEntries(Object.entries(this).map(([I, t]) => [I, g(t.value)])), in: Object.fromEntries(Object.entries(this.perSession).map(([I, t]) => [I, g(t.value)])) } } [ke]() { return this.toJSON() } static schema(A) { this._schema ||= {}, Object.assign(this._schema, A) } static load(A, g) { return mA(this, A, g ?? {}) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } }; cc.prototype[q] = "CoStream"; var Yy = cc, Ky = class extends Ne { constructor(e, A) { super(e), this.coFeed = e, this.raw = A } get owner() { return Dg(this.coFeed) } push(...e) { for (const A of e) this.pushItem(A) } pushItem(e) { const A = this.schema[AA]; if (A === "json") this.raw.push(e); else if ("encoded" in A) this.raw.push(A.encoded.encode(e)); else if (BA(A)) { let g = e.$jazz?.id; g || (g = ct(A, e, this.owner).$jazz.id), this.raw.push(g) } } ensureLoaded(e) { return lt(this.coFeed, e) } subscribe(...e) { const { options: A, listener: g } = yA(e); return Se(this.coFeed, A, g) } waitForSync(e) { return this.raw.core.waitForSync(e) } getItemsDescriptor() { return this.schema[AA] } get schema() { return this.coFeed.constructor._schema } }; function nI(e, A, g, I, t) { return { get value() { if (t === "json") return A.value; if ("encoded" in t) return t.encoded.decode(A.value); if (BA(t)) return Pe(e, A.value, t); throw new Error("Invalid item field schema") }, get ref() { if (t !== "json" && BA(t)) { const i = A.value; return new Ze(i, g, t, e) } else return }, get by() { return I && Pe(e, I, { ref: te, optional: !1 }) }, madeAt: A.at, tx: A.tx } } var vy = e => ({ get(A, g, I) { if (typeof g == "string" && g.startsWith("co_")) { const t = e.$jazz.raw.lastItemBy(g); if (!t) return; const i = nI(I, t, e.$jazz.loadedAs, g, e.$jazz.schema[AA]); return Object.defineProperty(i, "all", { get: () => { const n = e.$jazz.raw.itemsBy(g); return (function* () { for (; ;) { const r = n.next(); if (r.done) return; yield nI(I, r.value, e.$jazz.loadedAs, g, e.$jazz.schema[AA]) } })() } }), i } else return Reflect.get(e, g, I) }, ownKeys(A) { return Array.from(e.$jazz.raw.accounts()) }, getOwnPropertyDescriptor(A, g) { return typeof g == "string" && g.startsWith("co_") ? { configurable: !0, enumerable: !0, writable: !1 } : Reflect.getOwnPropertyDescriptor(e, g) } }), Jy = (e, A) => ({ get(g, I, t) { if (typeof I == "string" && I.includes("session")) { const i = I, n = e.$jazz.raw.lastItemIn(i); if (!n) return; const r = KA.accountOrAgentIDfromSessionID(i), o = nI(A, n, e.$jazz.loadedAs, KA.isAccountID(r) ? r : void 0, e.$jazz.schema[AA]); return Object.defineProperty(o, "all", { get: () => { const C = e.$jazz.raw.itemsIn(i); return (function* () { for (; ;) { const B = C.next(); if (B.done) return; yield nI(A, B.value, e.$jazz.loadedAs, KA.isAccountID(r) ? r : void 0, e.$jazz.schema[AA]) } })() } }), o } else return Reflect.get(e, I, t) }, ownKeys() { return e.$jazz.raw.sessions() }, getOwnPropertyDescriptor(g, I) { return typeof I == "string" && I.startsWith("co_") ? { configurable: !0, enumerable: !0, writable: !1 } : Reflect.getOwnPropertyDescriptor(g, I) } }), Hy = class extends dg { constructor(e) { super(); let A; "fromRaw" in e ? A = e.fromRaw : A = e.owner.$jazz.raw.createBinaryStream(), Object.defineProperties(this, { [q]: { value: "BinaryCoStream", enumerable: !1 }, $jazz: { value: new Ly(this, A), enumerable: !1 } }) } static create(e) { return new this(fg(e)) } getMetadata() { return this.$jazz.raw.getBinaryStreamInfo() } getChunks(e) { return this.$jazz.raw.getBinaryChunks(e?.allowUnfinished) } isBinaryStreamEnded() { return this.$jazz.raw.isBinaryStreamEnded() } start(e) { this.$jazz.raw.startBinaryStream(e) } push(e) { this.$jazz.raw.pushBinaryStreamChunk(e) } end() { this.$jazz.raw.endBinaryStream() } toBlob(e) { const A = this.getChunks({ allowUnfinished: e?.allowUnfinished }); if (A) return new Blob(A.chunks, { type: A.mimeType }) } static async loadAsBlob(e, A) { let g = await this.load(e, A); if (g.$isLoaded) return g.toBlob({ allowUnfinished: A?.allowUnfinished }) } static async loadAsBase64(e, A) { const g = await this.load(e, A); if (g.$isLoaded) return g.asBase64(A) } asBase64(e) { const A = this.getChunks(e); if (!A) return; const g = []; for (const t of A.chunks) for (const i of t) g.push(String.fromCharCode(i)); const I = btoa(g.join("")); return e?.dataURL ? `data:${A.mimeType};base64,${I}` : I } static async createFromBlob(e, A) { const g = await e.arrayBuffer(); return this.createFromArrayBuffer(g, e.type, e instanceof File ? e.name : void 0, A) } static async createFromArrayBuffer(e, A, g, I) { const t = this.create(I), i = I && "onProgress" in I ? I.onProgress : void 0, n = Date.now(), r = new Uint8Array(e); t.start({ mimeType: A, totalSizeBytes: e.byteLength, fileName: g }); const o = KA.TRANSACTION_CONFIG.MAX_RECOMMENDED_TX_SIZE; let C = Date.now(); for (let Q = 0; Q < r.length; Q += o)t.push(r.slice(Q, Q + o)), Date.now() - C > 100 && (i?.(Q / r.length), C = Date.now()), await new Promise(s => setTimeout(s, 0)); t.end(); const B = Date.now(); return console.debug("Finished creating binary stream in", (B - n) / 1e3, "s - Throughput in MB/s", 1e3 * (e.byteLength / (B - n)) / (1024 * 1024)), i?.(1), t } toJSON() { return { $jazz: { id: this.$jazz.id }, ...this.getChunks() } } [ke]() { return this.toJSON() } static async load(e, A) { const g = await mA(this, e, A); return !A?.allowUnfinished && g.$isLoaded && !g.isBinaryStreamEnded() ? new Promise(I => { TA(this, e, A || {}, (t, i) => { t.isBinaryStreamEnded() && (i(), I(t)) }) }) : g } static subscribe(e, ...A) { const { options: g, listener: I } = yA(A); return TA(this, e, g, I) } }, Ly = class extends Ne { constructor(e, A) { super(e), this.fileStream = e, this.raw = A } get owner() { return Dg(this.fileStream) } subscribe(e) { return Se(this.fileStream, {}, e) } waitForSync(e) { return this.raw.core.waitForSync(e) } }, te = class extends dg { constructor(e) { if (super(), !("fromRaw" in e)) throw new Error("Can only construct account from raw or with .create()"); const A = new Proxy(this, hc); return Object.defineProperties(this, { [q]: { value: "Account", enumerable: !1 }, $jazz: { value: new qy(A, e.fromRaw), enumerable: !1 } }), A } get isMe() { return fA.get().$jazz.id === this.$jazz.id } async acceptInvite(e, A, g) { if (!this.$jazz.isLocalNodeOwner) throw new Error("Only a controlled account can accept invites"); return await this.$jazz.localNode.acceptInvite(e, A), Or(ut(g ?? Ae), e, { loadAs: this }) } getRoleOf(e) { if (e === "me") return this.isMe ? "admin" : void 0; if (e === this.$jazz.id) return "admin" } canRead(e) { const A = e.$jazz.owner; if (!A) return !0; const g = A.getRoleOf(this.$jazz.id); return Xt(g) } canWrite(e) { const A = e.$jazz.owner; if (!A) { if (e[q] === "Group") { const I = e.getRoleOf(this.$jazz.id); return I === "admin" || I === "manager" || I === "writer" } return e[q] === "Account" ? e.$jazz.id === this.$jazz.id : !1 } const g = A.getRoleOf(this.$jazz.id); return g === "admin" || g === "manager" || g === "writer" || g === "writeOnly" } canManage(e) { const A = e.$jazz.owner; if (!A) { if (e[q] === "Group") { const g = e.getRoleOf(this.$jazz.id); return g === "manager" || g === "admin" } return e[q] === "Account" ? e.$jazz.id === this.$jazz.id : !1 } return A.getRoleOf(this.$jazz.id) === "admin" || A.getRoleOf(this.$jazz.id) === "manager" } canAdmin(e) { const A = e.$jazz.owner; return A ? A.getRoleOf(this.$jazz.id) === "admin" : e[q] === "Group" ? e.getRoleOf(this.$jazz.id) === "admin" : e[q] === "Account" ? e.$jazz.id === this.$jazz.id : !1 } static async create(e) { const { node: A } = await Qe.withNewlyCreatedAccount({ ...e, migration: async (g, I, t) => { await new this({ fromRaw: g }).applyMigration?.(t) } }); return this.fromNode(A) } static getMe() { return fA.get() } static async createAs(e, A) { const g = KA.connectedPeers("creatingAccount", "createdAccount", { peer1role: "server", peer2role: "client" }); e.$jazz.localNode.syncManager.addPeer(g[1]); const I = await this.create({ creationProps: A.creationProps, crypto: e.$jazz.localNode.crypto, peers: [g[0]] }); return await I.$jazz.waitForAllCoValuesSync(), I } static fromNode(e) { return new this({ fromRaw: e.expectCurrentAccount("jazz-tools/Account.fromNode") }) } toJSON() { return { $jazz: { id: this.$jazz.id } } } [ke]() { return this.toJSON() } async applyMigration(e) { if (await this.migrate(e), this.profile === void 0 && e) { const g = MA.Group.create({ owner: this }); this.$jazz.set("profile", dc.create({ name: e.name }, g)), g.addMember("everyone", "reader") } const A = this.$jazz.localNode.expectCoValueLoaded(this.$jazz.raw.get("profile")).getCurrentContent(); if (!A.get("inbox")) { const g = Ty(this); A.set("inbox", g.id), A.set("inboxInvite", g.inviteLink) } } migrate(e) { } static load(e, A) { return mA(this, e, A) } static subscribe(e, ...A) { const { options: g, listener: I } = yA(A); return TA(this, e, g, I) } }; te._schema = { profile: { ref: () => dc, optional: !1 }, root: { ref: () => MA.CoMap, optional: !0 } }; var qy = class extends Ne { constructor(e, A) { super(e), this.account = e, this.raw = A, this.isLocalNodeOwner = this.raw.id === this.localNode.getCurrentAgent().id, this.isLocalNodeOwner && (this.sessionID = this.localNode.currentSessionID) } get owner() { } set(e, A) { if (A) { let g = A.$jazz?.id; if (!g) { const I = this.schema[e]; g = ct(I, A, oI(this.account)).$jazz.id } this.raw.set(e, g, "trusting") } } has(e) { const A = this.raw.getRaw(e); return A?.change !== void 0 && A.change.op !== "del" } getDescriptor(e) { if (e === "profile") return this.schema.profile; if (e === "root") return this.schema.root } get refs() { const e = this.raw.get("profile"), A = this.raw.get("root"); return { profile: e ? new Ze(e, this.loadedAs, this.schema.profile, this.account) : void 0, root: A ? new Ze(A, this.loadedAs, this.schema.root, this.account) : void 0 } } ensureLoaded(e) { return lt(this.account, e) } subscribe(...e) { const { options: A, listener: g } = yA(e); return Se(this.account, A, g) } waitForSync(e) { return this.raw.core.waitForSync(e) } waitForAllCoValuesSync(e) { return this.localNode.syncManager.waitForAllCoValuesSync(e?.timeout) } get schema() { return this.account.constructor._schema } get loadedAs() { if (this.isLocalNodeOwner) return this.account; const e = this.localNode.getCurrentAgent(); return e instanceof dr ? Hr.get(e.account, () => te.fromRaw(e.account)) : new Jr(this.localNode) } }, hc = { get(e, A, g) { if (A === "profile" || A === "root") { const I = e.$jazz.raw.get(A); return I ? qr(e, I, A) : void 0 } else return Reflect.get(e, A, g) }, set(e, A, g, I) { return e instanceof te && (A === "profile" || A === "root") && typeof g == "object" && W in g ? (e.constructor._schema ||= {}, e.constructor._schema[A] = g[W], !0) : e instanceof te && (A === "profile" || A === "root") ? (g && e.$jazz.set(A, g), !0) : Reflect.set(e, A, g, I) }, defineProperty(e, A, g) { return (A === "profile" || A === "root") && typeof g.value == "object" && W in g.value ? (e.constructor._schema ||= {}, e.constructor._schema[A] = g.value[W], !0) : Reflect.defineProperty(e, A, g) } }; function xy(e) { return e.$jazz.isLocalNodeOwner } MA.Account = te; var lc = class wc extends dg { constructor(A) { super(); let g; if (A && "fromRaw" in A) g = A.fromRaw; else { const t = A.owner; if (!t) throw new Error("No owner provided"); if (t[q] === "Account" && xy(t)) g = t.$jazz.raw.core.node.createGroup(); else throw new Error("Can only construct group as a controlled account") } const I = new Proxy(this, hc); return Object.defineProperties(this, { $jazz: { value: new zy(I, g), enumerable: !1 } }), I } static create(A) { return new this(Jp(A)) } myRole() { return this.$jazz.raw.myRole() } addMember(A, g) { if (iC(A)) { if (g === "writeOnly") throw new Error("Cannot add group as member with write-only role"); this.$jazz.raw.extend(A.$jazz.raw, g) } else g !== void 0 && g !== "inherit" && this.$jazz.raw.addMember(A === "everyone" ? A : A.$jazz.raw, g) } removeMember(A) { if (iC(A)) this.$jazz.raw.revokeExtend(A.$jazz.raw); else return this.$jazz.raw.removeMember(A === "everyone" ? A : A.$jazz.raw) } getMembersFromKeys(A) { const g = [], I = { ref: () => te, optional: !1 }; for (const t of A) { if (!Oy(t)) continue; const i = this.$jazz.raw.roleOf(t); if (Xt(i)) { const n = new Ze(t, this.$jazz.loadedAs, I, this), r = this; g.push({ id: t, role: i, ref: n, get account() { return Pe(r, t, I) } }) } } return g } get members() { return this.getMembersFromKeys(this.$jazz.raw.getAllMemberKeysSet()) } getDirectMembers() { return this.getMembersFromKeys(this.$jazz.raw.getMemberKeys()) } getRoleOf(A) { const g = A === "me" ? fA.get().$jazz.id : A; return this.$jazz.raw.roleOf(g) } makePublic(A = "reader") { return this.addMember("everyone", A), this } getParentGroups() { return this.$jazz.raw.getParentGroups().map(A => wc.fromRaw(A)) } extend(A, g) { return this.$jazz.raw.extend(A.$jazz.raw, g), this } async revokeExtend(A) { return await this.$jazz.raw.revokeExtend(A.$jazz.raw), this } static load(A, g) { return mA(this, A, g) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } static async createInvite(A, g) { const I = await mA(this, A, { loadAs: g?.loadAs }); if (!I.$isLoaded) throw new Error(`Group with id ${A} not found`); return I.$jazz.createInvite(g?.role ?? "reader") } }; lc.prototype[q] = "Group"; var Ae = lc, zy = class extends Ne { constructor(e, A) { super(e), this.group = e, this.raw = A } get id() { return this.raw.id } get owner() { } ensureLoaded(e) { return lt(this.group, e) } subscribe(...e) { const { options: A, listener: g } = yA(e); return Se(this.group, A, g) } createInvite(e = "reader") { return this.raw.createInvite(e) } waitForSync(e) { return this.raw.core.waitForSync(e) } }; MA.Group = Ae; function Oy(e) { return e.startsWith("co_") } function Dg(e) { const A = Pe(e, e.$jazz.raw.group.id, { ref: MA.Group, optional: !1 }); if (!A) throw new Error("CoValue has no owner"); return A } function iC(e) { return e !== "everyone" && !(e.$jazz.raw instanceof at) } var dc = class extends vr { constructor() { super(...arguments), this.name = iA.string, this.inbox = iA.optional.string, this.inboxInvite = iA.optional.string } static create(e, A) { if ((A !== void 0 && "owner" in A ? A.owner : A)?.[q] === "Account") throw new Error("Profiles should be owned by a group"); return super.create(e, A) } }; function jy(e) { return typeof e == "string" && e.startsWith("co_z") } function Ty(e) { if (!e.$jazz.isLocalNodeOwner) throw new Error("Account is not controlled"); const A = e.$jazz.raw, g = A.core.node.createGroup(), I = g.createStream(), t = A.createMap(), i = A.createStream(), n = A.createStream(), r = `${I.id}/${g.createInvite("writeOnly")}`; return t.set("messages", I.id), t.set("processed", i.id), t.set("failed", n.id), { id: t.id, inviteLink: r } } var Dc = class extends String { constructor(e) { if (!e) { super(""); return } if ("fromRaw" in e) { super(e.fromRaw.toString()); const A = e.fromRaw; Object.defineProperties(this, { [q]: { value: "CoPlainText", enumerable: !1 }, $jazz: { value: new nC(this, A), enumerable: !1 }, $isLoaded: { value: !0, enumerable: !1 } }); return } if ("text" in e && "owner" in e) { super(e.text); const A = e.owner.$jazz.raw.createPlainText(e.text); Object.defineProperties(this, { [q]: { value: "CoPlainText", enumerable: !1 }, $jazz: { value: new nC(this, A), enumerable: !1 }, $isLoaded: { value: !0, enumerable: !1 } }); return } throw new Error("Invalid constructor arguments") } static create(e, A) { const { owner: g } = fg(A); return new this({ text: e, owner: g }) } get length() { return this.$jazz.raw.toString().length } toString() { return this.$jazz.raw.toString() } valueOf() { return this.$jazz.raw.toString() } toJSON() { return this.$jazz.raw.toString() } [ke]() { return this.toJSON() } insertBefore(e, A) { this.$jazz.raw.insertBefore(e, A) } insertAfter(e, A) { this.$jazz.raw.insertAfter(e, A) } deleteRange(e) { this.$jazz.raw.deleteRange(e) } posBefore(e) { return this.$jazz.raw.mapping.opIDbeforeIdx[e] } posAfter(e) { return this.$jazz.raw.mapping.opIDafterIdx[e] } idxBefore(e) { return this.$jazz.raw.mapping.idxBeforeOpID[$t(e)] } idxAfter(e) { return this.$jazz.raw.mapping.idxAfterOpID[$t(e)] } static fromRaw(e) { return new this({ fromRaw: e }) } static load(e, A) { return mA(this, e, A) } static subscribe(e, ...A) { const { options: g, listener: I } = yA(A); return TA(this, e, g, I) } [Symbol.toPrimitive](e) { return e === "number" ? Number(this.$jazz.raw.toString()) : this.$jazz.raw.toString() } }, nC = class extends Ne { constructor(e, A) { super(e), this.coText = e, this.raw = A } get owner() { return Dg(this.coText) } applyDiff(e) { const A = this.raw.toString(), g = this.raw.toGraphemes(A), I = this.raw.toGraphemes(e), t = [...OE.calcPatch(g, I)]; if (t.length !== 0) { this.raw.core.pauseNotifyUpdate(); for (const [i, n, r] of t.reverse()) n > i && this.coText.deleteRange({ from: i, to: n }), r.length > 0 && this.coText.insertBefore(i, this.raw.fromGraphemes(r)); this.raw.core.resumeNotifyUpdate() } } subscribe(e) { return Se(this.coText, {}, e) } }, Zy = class extends Dc { }, Py = class fc extends dg { static Of(A) { return class extends fc { static create(I, t) { return A(new Map(Object.entries(I))).create(I, t) } static fromRaw(I) { return A(I).fromRaw(I) } } } static create(A, g) { throw new Error("Not implemented") } static fromRaw(A) { throw new Error("Not implemented") } static load(A, g) { return mA(this, A, g) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } }, yc = class Ni extends Float32Array { static get [Symbol.species]() { return Float32Array } constructor(A) { const g = new.target.requiredDimensionsCount; if (g === void 0) throw new Error("Instantiating CoVector without a dimensions count is not allowed. Use co.vector(...).create() instead."); super(g); const I = "fromRaw" in A, t = I ? A.fromRaw : A.owner.$jazz.raw.createBinaryStream(); Object.defineProperties(this, { [q]: { value: "BinaryCoStream", enumerable: !1 }, $jazz: { value: new Wy(this, t), enumerable: !1 }, $isLoaded: { value: !0, enumerable: !1 }, _isVectorLoaded: { value: !1, enumerable: !1, writable: !0 }, _requiredDimensionsCount: { value: g, enumerable: !1, writable: !1 } }), I && this.loadVectorData() } static fromRaw(A) { return new this({ fromRaw: A }) } static create(A, g) { const I = A instanceof Float32Array ? A : new Float32Array(A), t = I.byteLength / I.BYTES_PER_ELEMENT; if (this.requiredDimensionsCount !== void 0 && t !== this.requiredDimensionsCount) throw new Error(`Vector dimension mismatch! Expected ${this.requiredDimensionsCount} dimensions, got ${t}`); const i = new this(fg(g)); i.setVectorData(I); const n = Ni.toByteArray(I); i.$jazz.raw.startBinaryStream({ mimeType: "application/vector+octet-stream", totalSizeBytes: n.byteLength }); const r = KA.TRANSACTION_CONFIG.MAX_RECOMMENDED_TX_SIZE; for (let o = 0; o < n.length; o += r)i.$jazz.raw.pushBinaryStreamChunk(n.slice(o, o + r)); return i.$jazz.raw.endBinaryStream(), i } static toByteArray(A) { return new Uint8Array(A.buffer, A.byteOffset, A.byteLength) } static fromByteArray(A) { const g = A.reduce((i, n) => i + n.byteLength, 0); if (g % 4 !== 0) throw new Error("[INTERNAL] Total byte length must be multiple of 4"); const I = new Uint8Array(g); let t = 0; for (const i of A) I.set(i, t), t += i.byteLength; return new Float32Array(I.buffer, I.byteOffset, g / 4) } loadVectorData() { if (this._isVectorLoaded === !0) return; const A = this.$jazz.raw.getBinaryChunks(); if (!A) throw new Error(`CoVector '${this.$jazz.raw.id}' is not loaded`); const g = Ni.fromByteArray(A.chunks); if (g.length !== this._requiredDimensionsCount) throw new Error(`Vector dimension mismatch! CoVector '${this.$jazz.raw.id}' loaded with ${g.length} dimensions, but the schema requires ${this._requiredDimensionsCount} dimensions`); this.setVectorData(g) } setVectorData(A) { super.set(A, 0), this._isVectorLoaded = !0 } toJSON() { return Array.from(this) } [ke]() { return this.toJSON() } static async load(A, g) { const I = await mA(this, A, g); return !I.$isLoaded || !I.$jazz.raw.isBinaryStreamEnded() ? new Promise(t => { TA(this, A, g || {}, (i, n) => { i.$jazz.raw.isBinaryStreamEnded() && (n(), t(i)) }) }) : (I.loadVectorData(), I) } static subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return TA(this, A, I, t) } copyWithin(A, g, I) { throw new Error("Cannot mutate a CoVector using `copyWithin`") } fill(A, g, I) { throw new Error("Cannot mutate a CoVector using `fill`") } reverse() { throw new Error("Cannot mutate a CoVector using `reverse`") } set(A, g) { throw new Error("Cannot mutate a CoVector using `set`") } sort(A) { throw new Error("Cannot mutate a CoVector using `sort`") } }; yc.requiredDimensionsCount = void 0; var Vy = yc, Wy = class extends Ne { constructor(e, A) { super(e), this.coVector = e, this.raw = A } get owner() { return Dg(this.coVector) } subscribe(e) { return Se(this.coVector, {}, e) } waitForSync(e) { return this.raw.core.waitForSync(e) } magnitude() { return De.magnitude(this.coVector) } normalize() { return De.normalize(this.coVector) } dotProduct(e) { return De.dotProduct(this.coVector, e) } cosineSimilarity(e) { return De.cosineSimilarity(this.coVector, e) } }, De = { magnitude: e => { let A = 0; for (const g of e) A += g * g; return Math.sqrt(A) }, normalize: e => { const A = De.magnitude(e); return A === 0 ? new Float32Array(e.length).fill(0) : e.map(g => g / A) }, dotProduct: (e, A) => { if (e.length !== A.length) throw new Error(`Vector dimensions don't match: ${e.length} vs ${A.length}`); return e.reduce((g, I, t) => g + I * A[t], 0) }, cosineSimilarity: (e, A) => { const g = De.magnitude(e), I = De.magnitude(A); return g === 0 || I === 0 ? 0 : De.dotProduct(e, A) / (g * I) } }, pc; pc = q; var Jr = class { constructor(e) { this.node = e, this[pc] = "Anonymous" } }, Xy = class { constructor() { this.activeAccount = null, this.guestMode = !1 } set(e) { this.activeAccount = e, this.guestMode = !1 } setGuestMode() { this.activeAccount = null, this.guestMode = !0 } maybeGet() { return this.activeAccount } get() { if (!this.activeAccount) throw this.guestMode ? new Error("Something that expects a full active account was called in guest mode.") : new Error("No active account"); return this.activeAccount } }, fA = new Xy, Ze = class { constructor(e, A, g, I) { if (this.id = e, this.controlledAccount = A, this.schema = g, this.parent = I, !BA(g)) throw new Error("Ref must be constructed with a ref schema") } async load() { const e = Lr(this.parent); let A; if (e.closed ? A = new LI(e.node, !0, this.id, this.schema, e.skipRetry, e.bestEffortResolution, e.unstable_branch) : (e.subscribeToId(this.id, this.schema), A = e.childNodes.get(this.id)), !A) return qe(this.id, R.LOADING); const g = A.value; return g?.type === R.LOADED ? g.value : new Promise(I => { const t = A.subscribe(i => { i?.type === R.LOADED ? (t(), I(i.value)) : i?.type === R.UNAVAILABLE ? (t(), I(qe(this.id, R.UNAVAILABLE))) : i?.type === R.UNAUTHORIZED && (t(), I(qe(this.id, R.UNAUTHORIZED))), e.closed && A.destroy() }) }) } get value() { return Pe(this.parent, this.id, this.schema) } }; function mc(e, A, g, I, t) { const i = {}; return new Proxy(i, { get(n, r) { if (r === Symbol.iterator) return function* () { for (const C of g()) yield new Ze(A(C), I, t(C), e) }; if (typeof r == "symbol") return; if (r === "length") return g().length; const o = A(r); if (o) return new Ze(o, I, t(r), e) }, ownKeys() { return g().map(n => n.toString()) }, getOwnPropertyDescriptor(n, r) { return A(r) ? { enumerable: !0, configurable: !0, writable: !0 } : Reflect.getOwnPropertyDescriptor(n, r) } }) } var Nc = { Date: { encode: e => e.toISOString(), decode: e => new Date(e) }, OptionalDate: { encode: e => e?.toISOString() || null, decode: e => e === null ? void 0 : new Date(e) } }, _y = { ref: $y, json() { return { [W]: "json" } }, encoded(e) { return { [W]: { encoded: e } } }, string: { [W]: "json" }, number: { [W]: "json" }, boolean: { [W]: "json" }, null: { [W]: "json" }, Date: { [W]: { encoded: Nc.OptionalDate } }, literal(...e) { return { [W]: "json" } } }, iA = { string: { [W]: "json" }, number: { [W]: "json" }, boolean: { [W]: "json" }, null: { [W]: "json" }, Date: { [W]: { encoded: Nc.Date } }, literal(...e) { return { [W]: "json" } }, json() { return { [W]: "json" } }, encoded(e) { return { [W]: { encoded: e } } }, ref: kc, items: AA, optional: _y }; function $y(e) { return kc(e, { optional: !0 }) } function kc(e, A) { return { [W]: { ref: e, optional: A?.optional || !1 } } } function BA(e) { return typeof e == "object" && "ref" in e && "optional" in e && typeof e.ref == "function" } function Gc(e, A) { return ht(e.ref) ? e.ref.fromRaw(A) : e.ref(A).fromRaw(A) } function ct(e, A, g) { if (!ht(e.ref)) throw Error(`Cannot automatically create CoValue from value: ${JSON.stringify(A)}. Use the CoValue schema's create() method instead.`); const t = g.$jazz.localNode.createGroup(), i = new Ae({ fromRaw: t }); return i.addMember(g), e.ref.create(A, i) } function Ap(e) { const A = e.$jazz.raw.core.node, g = A._migratedCoValues ??= new Set; if ("migrate" in e && typeof e.migrate == "function" && e[q] !== "Account" && !g.has(e.$jazz.id)) { g.add(e.$jazz.id); const I = e.migrate?.(e); if (I && "then" in I) throw new Error("Migration function cannot be async") } } var R = { LOADED: "loaded", LOADING: "loading", UNAUTHORIZED: "unauthorized", UNAVAILABLE: "unavailable" }, ep = class { constructor(e, A, g, I, t) { this._unsubscribe = () => { }, this.unsubscribed = !1, this.localNode = e, this.listener = g, this.skipRetry = I, this.branchName = t?.name, this.branchOwnerId = t?.owner?.$jazz.raw.id, this.source = e.getCoValue(A), this.initializeSubscription() } pullValue() { this.unsubscribed && (this.unsubscribed = !1, this.initializeSubscription(), this.unsubscribe()) } initializeSubscription() { if (this.source.isAvailable()) { this.handleAvailableSource(); return } if (this.branchName) { this.handleBranchCheckout(); return } this.loadCoValue() } handleAvailableSource() { if (!this.branchName || !KA.canBeBranched(this.source)) { this.subscribe(this.source.getCurrentContent()); return } const e = this.source.getBranch(this.branchName, this.branchOwnerId); if (e.isAvailable()) { this.subscribe(e.getCurrentContent()); return } else this.source.hasBranch(this.branchName, this.branchOwnerId) ? this.handleBranchCheckout() : (this.source.createBranch(this.branchName, this.branchOwnerId), this.subscribe(e.getCurrentContent())) } handleBranchCheckout() { this.localNode.checkoutBranch(this.source.id, this.branchName, this.branchOwnerId).then(e => { this.unsubscribed || (e !== R.UNAVAILABLE ? this.subscribe(e) : this.handleUnavailableBranch()) }).catch(e => { console.error(e), this.emit(R.UNAVAILABLE) }) } handleUnavailableBranch() { if (this.source.isAvailable()) throw new Error("Branch is unavailable"); this.subscribeToUnavailableSource(), this.emit(R.UNAVAILABLE) } loadCoValue() { this.localNode.loadCoValueCore(this.source.id, void 0, this.skipRetry).then(e => { this.unsubscribed || (e.isAvailable() ? this.subscribe(e.getCurrentContent()) : (this.subscribeToUnavailableSource(), this.emit(R.UNAVAILABLE))) }).catch(e => { console.error(e), this.emit(R.UNAVAILABLE) }) } subscribeToUnavailableSource() { const e = this.source, A = (g, I) => { e.isAvailable() && (I(), this.branchName ? this.handleBranchCheckout() : this.subscribe(e.getCurrentContent())) }; this._unsubscribe = e.subscribe(A) } subscribe(e) { this.unsubscribed || (this._unsubscribe = e.subscribe(A => { this.emit(A) })) } emit(e) { this.unsubscribed || gp(e) && this.listener(e) } unsubscribe() { this.unsubscribed || (this.unsubscribed = !0, this._unsubscribe()) } }; function gp(e) { return e === "unavailable" ? !0 : e.core.verified?.header.meta?.type === "binary" || e.core.isCompletelyDownloaded() } var Ig = class Sc {
      constructor(A, g, I) { this.id = A, this.type = g, this.issues = I } toString() {
        return this.issues.map(A => { let g = `${A.message}`; return this.id && (g += ` from ${this.id}`), A.path.length > 0 && (g += ` on path ${A.path.join(".")}`), g }).join(`
`)
      } prependPath(A) { if (this.issues.length === 0) return this; const g = this.issues.map(I => ({ ...I, path: [A].concat(I.path) })); return new Sc(this.id, this.type, g) }
    }, rC = new WeakMap, Hr = { get: (e, A) => { const g = rC.get(e); if (g) return g; const I = A(); return rC.set(e, I), I } }; function tp(e) { const A = e.group, g = Hr.get(A, () => A instanceof at ? MA.Account.fromRaw(A) : MA.Group.fromRaw(A)); return oI(g).myRole() } function Ft(e, A, g) { const I = Gc(e, A); return Object.defineProperty(I.$jazz, "_subscriptionScope", { value: g, writable: !1, enumerable: !1, configurable: !1 }), { type: R.LOADED, value: I, id: g.id } } var LI = class ki { constructor(A, g, I, t, i = !1, n = !1, r) { this.node = A, this.id = I, this.schema = t, this.skipRetry = i, this.bestEffortResolution = n, this.unstable_branch = r, this.childNodes = new Map, this.childValues = new Map, this.pendingLoadedChildren = new Set, this.pendingAutoloadedChildren = new Set, this.childErrors = new Map, this.validationErrors = new Map, this.dirty = !1, this.idsSubscribed = new Set, this.autoloaded = new Set, this.autoloadedKeys = new Set, this.skipInvalidKeys = new Set, this.totalValidTransactions = 0, this.version = 0, this.migrated = !1, this.migrating = !1, this.closed = !1, this.silenceUpdates = !1, this.handleChildUpdate = (C, B, Q) => { B.type !== R.LOADING && (this.pendingLoadedChildren.delete(C), this.pendingAutoloadedChildren.delete(C), this.childValues.set(C, B), B.type === R.UNAVAILABLE || B.type === R.UNAUTHORIZED ? (this.childErrors.set(C, B.prependPath(Q ?? C)), this.errorFromChildren = this.computeChildErrors()) : this.errorFromChildren && this.childErrors.has(C) && (this.childErrors.delete(C), this.errorFromChildren = this.computeChildErrors()), this.shouldSendUpdates() && this.value.type === R.LOADED && this.updateValue(Ft(this.schema, this.value.value.$jazz.raw, this)), this.triggerUpdate()) }, this.subscribers = new Set, this.resolve = g, this.value = { type: R.LOADING, id: I }; let o; this.subscription = new ep(A, I, C => { if (o = C, i && C === R.UNAVAILABLE) { this.handleUpdate(C); return } if (!this.migrated && C !== R.UNAVAILABLE) { if (this.migrating) return; this.migrating = !0, Ap(Gc(this.schema, C)), this.migrated = !0, this.handleUpdate(o); return } this.handleUpdate(C) }, i, this.unstable_branch) } updateValue(A) { this.value = A, this.dirty = !0 } handleUpdate(A) { if (A === R.UNAVAILABLE) { this.value.type === R.LOADING && this.updateValue(new Ig(this.id, R.UNAVAILABLE, [{ code: R.UNAVAILABLE, message: "The value is unavailable", params: { id: this.id }, path: [] }])), this.triggerUpdate(); return } if (!(A.core.verified.header.ruleset.type !== "ownedByGroup" || tp(A) !== void 0)) { this.value.type !== R.UNAUTHORIZED && (this.updateValue(new Ig(this.id, R.UNAUTHORIZED, [{ code: R.UNAUTHORIZED, message: `The current user (${this.node.getCurrentAgent().id}) is not authorized to access this value`, params: { id: this.id }, path: [] }])), this.triggerUpdate()); return } if (this.silenceUpdates = !0, this.value.type !== R.LOADED) this.updateValue(Ft(this.schema, A, this)), this.loadChildren(); else { const t = A.totalValidTransactions !== this.totalValidTransactions || A.version !== this.version; this.loadChildren() ? this.updateValue(Ft(this.schema, A, this)) : t && this.updateValue(Ft(this.schema, A, this)) } this.totalValidTransactions = A.totalValidTransactions, this.version = A.version, this.silenceUpdates = !1, this.triggerUpdate() } computeChildErrors() { let A = [], g = R.UNAVAILABLE; if (!(this.childErrors.size === 0 && this.validationErrors.size === 0) && !this.bestEffortResolution) { for (const [I, t] of this.childErrors.entries()) this.autoloaded.has(I) || this.skipInvalidKeys.has(I) || (g = t.type, t.issues && A.push(...t.issues)); for (const [I, t] of this.validationErrors.entries()) this.skipInvalidKeys.has(I) || (g = t.type, t.issues && A.push(...t.issues)); if (A.length) return new Ig(this.id, g, A) } } shouldSendUpdates() { return this.value.type === R.LOADING ? !1 : this.value.type !== R.LOADED ? !0 : this.pendingLoadedChildren.size === 0 } getCurrentValue() { return this.value.type === R.UNAUTHORIZED || this.value.type === R.UNAVAILABLE ? (console.error(this.value.toString()), this.value.type) : this.shouldSendUpdates() ? this.errorFromChildren ? (console.error(this.errorFromChildren.toString()), this.errorFromChildren.type) : this.value.type === R.LOADED ? this.value.value : R.LOADING : R.LOADING } triggerUpdate() { if (!this.shouldSendUpdates() || !this.dirty || this.subscribers.size === 0 || this.silenceUpdates) return; const A = this.errorFromChildren, g = this.value; A ? this.subscribers.forEach(I => I(A)) : g.type !== R.LOADING && this.subscribers.forEach(I => I(g)), this.dirty = !1 } subscribe(A) { return this.subscribers.add(A), () => { this.subscribers.delete(A) } } setListener(A) { this.subscribers.add(A), this.triggerUpdate() } subscribeToKey(A) { (this.resolve === !0 || !this.resolve) && (this.resolve = {}); const g = this.resolve; if (!g.$each && !(A in g) && (g[A] = !0, this.autoloadedKeys.add(A)), this.value.type !== R.LOADED) return; const I = this.value.value; if (this.silenceUpdates = !0, I[q] === "CoMap" || I[q] === "Account") { const t = I; this.loadCoMapKey(t, A, !0) } else if (I[q] === "CoList") { const t = I; this.loadCoListKey(t, A, !0) } this.silenceUpdates = !1 } isSubscribedToId(A) { return this.idsSubscribed.has(A) || this.childValues.has(A) || this.pendingAutoloadedChildren.has(A) || this.pendingLoadedChildren.has(A) } pullValue(A) { if (!this.closed) throw new Error("Cannot pull a non-closed subscription scope"); if (this.value.type === R.LOADED) return; this.subscription.pullValue(); const g = this.getCurrentValue(); typeof g != "string" && A({ type: R.LOADED, value: g, id: this.id }) } subscribeToId(A, g) { if (this.isSubscribedToId(A)) { if (!this.closed) return; const t = this.childNodes.get(A); t && t.pullValue(i => this.handleChildUpdate(A, i)); return } this.idsSubscribed.add(A), this.autoloaded.add(A), this.silenceUpdates = !0, this.pendingAutoloadedChildren.add(A); const I = new ki(this.node, !0, A, g, this.skipRetry, this.bestEffortResolution, this.unstable_branch); this.childNodes.set(A, I), I.setListener(t => this.handleChildUpdate(A, t)), this.closed && I.destroy(), this.silenceUpdates = !1 } loadChildren() { const { resolve: A } = this; if (this.value.type !== R.LOADED) return !1; const g = this.value.value, I = typeof A != "object" || A === null ? {} : A; let t = !1; const i = new Set(this.idsSubscribed), n = g[q]; if (Object.keys(I).length > 0) { if (n === "CoMap" || n === "Account" || n === "Group") { const r = g, o = "$each" in I ? r.$jazz.raw.keys() : Object.keys(I); for (const C of o) { const B = this.loadCoMapKey(r, C, I[C] ?? I.$each); B && i.add(B) } } else if (g[q] === "CoList") { const r = g, o = r.$jazz.getItemsDescriptor(); if (o && BA(o)) { r.$jazz.raw.processNewTransactions(); const C = r.$jazz.raw.entries(), B = "$each" in I ? Object.keys(C) : Object.keys(I); for (const Q of B) { const s = this.loadCoListKey(r, Q, I[Q] ?? I.$each); s && i.add(s) } } } else if (g[q] === "CoStream") { const r = g, o = r.$jazz.getItemsDescriptor(); if (o && BA(o)) for (const C of r.$jazz.raw.sessions()) { const B = r.$jazz.raw.items[C] ?? []; for (const [Q, s] of B.entries()) { const E = `${C}/${Q}`; if (!I.$each && !I[E]) continue; const a = s.value; a ? (i.add(a), this.loadChildNode(a, I[E] ?? I.$each, o), this.validationErrors.delete(E)) : o.optional || this.validationErrors.set(E, new Ig(void 0, R.UNAVAILABLE, [{ code: "validationError", message: `The ref on position ${E} requested on ${r.constructor.name} is missing`, params: {}, path: [E] }])) } } } } this.errorFromChildren = this.computeChildErrors(); for (const r of this.childNodes.keys()) if (!i.has(r)) { t = !0; const o = this.childNodes.get(r); o && o.destroy(), this.pendingLoadedChildren.delete(r), this.pendingAutoloadedChildren.delete(r), this.childNodes.delete(r), this.childValues.delete(r) } return t } loadCoMapKey(A, g, I) { if (g === "$onError") return; const t = A.$jazz.raw.get(g), i = A.$jazz.getDescriptor(g); if (i && BA(i)) { if (t) return this.loadChildNode(t, I, i, g), this.validationErrors.delete(g), t; i.optional || this.validationErrors.set(g, new Ig(void 0, R.UNAVAILABLE, [{ code: "validationError", message: `The ref ${g} requested on ${A.constructor.name} is missing`, params: {}, path: [g] }])) } } loadCoListKey(A, g, I) { const t = A.$jazz.getItemsDescriptor(); if (!t || !BA(t)) return; const n = A.$jazz.raw.entries()[Number(g)]; if (!n) return; const r = n.value; if (r) return this.loadChildNode(r, I, t, g), this.validationErrors.delete(g), r; t.optional || this.validationErrors.set(g, new Ig(void 0, R.UNAVAILABLE, [{ code: "validationError", message: `The ref on position ${g} requested on ${A.constructor.name} is missing`, params: {}, path: [g] }])) } loadChildNode(A, g, I, t) { if (this.isSubscribedToId(A)) return; const i = t && this.autoloadedKeys.has(t); i && this.autoloaded.add(A), typeof g == "object" && g.$onError === "catch" && (t && this.skipInvalidKeys.add(t), this.skipInvalidKeys.add(A)); const r = typeof g == "object" && g !== null ? { ...g } : g; i ? this.pendingAutoloadedChildren.add(A) : this.pendingLoadedChildren.add(A); const o = new ki(this.node, r, A, I, this.skipRetry, this.bestEffortResolution, this.unstable_branch); this.childNodes.set(A, o), o.setListener(C => this.handleChildUpdate(A, C, t)), this.closed && o.destroy() } destroy() { this.closed = !0, this.subscription.unsubscribe(), this.subscribers.clear(), this.childNodes.forEach(A => A.destroy()) } }; function Lr(e) { const A = e.$jazz._subscriptionScope; if (A) return A; const g = e.$jazz.raw.core.node, I = !0, t = e.$jazz.id, i = new LI(g, I, t, { ref: e.constructor, optional: !1 }); return Object.defineProperty(e.$jazz, "_subscriptionScope", { value: i, writable: !1, enumerable: !1, configurable: !1 }), i.destroy(), i } function qr(e, A, g) { const I = Lr(e), t = I.childNodes.get(A); I.isSubscribedToId(A) ? t && t.closed && t.pullValue(n => I.handleChildUpdate(A, n)) : I.subscribeToKey(g); const i = I.childValues.get(A); return i?.type === R.LOADED ? i.value : qe(A, i?.type ?? R.LOADING) } function Pe(e, A, g) { const I = Lr(e); I.subscribeToId(A, g); const t = I.childValues.get(A); return t?.type === R.LOADED ? t.value : qe(A, t?.type ?? R.LOADING) } async function Ip({ credentials: e, peers: A, crypto: g, storage: I, AccountSchema: t, sessionProvider: i, onLogOut: n, asActiveAccount: r }) { const { sessionID: o, sessionDone: C } = await i(e.accountID, g), B = t ?? MA.Account, Q = ut(B), s = await Qe.withLoadedAccount({ accountID: e.accountID, accountSecret: e.secret, sessionID: o, peers: A, crypto: g, storage: I, migration: async (a, c, u) => { const h = Q.fromRaw(a); fA.set(h), await h.applyMigration(u) } }), E = Q.fromNode(s); return fA.set(E), { node: s, account: E, done: () => { s.gracefulShutdown(), C() }, logOut: async () => { s.gracefulShutdown(), C(), await n?.() } } } async function ip({ creationProps: e, initialAgentSecret: A, peers: g, crypto: I, AccountSchema: t, onLogOut: i, storage: n }) { const r = t ?? MA.Account, o = ut(r), { node: C } = await Qe.withNewlyCreatedAccount({ creationProps: e, peers: g, crypto: I, initialAgentSecret: A, storage: n, migration: async (Q, s, E) => { const a = o.fromRaw(Q); fA.set(a), await a.applyMigration(E) } }), B = o.fromNode(C); return fA.set(B), { node: C, account: B, done: () => { C.gracefulShutdown() }, logOut: async () => { C.gracefulShutdown(), await i?.() } } } async function np(e) { const A = e.crypto; let g; const I = e.authSecretStorage; await I.migrate(); const t = e.credentials ?? await I.get(); if (t && !e.newAccountProps) g = await Ip({ credentials: { accountID: t.accountID, secret: t.accountSecret }, peers: e.peers, crypto: A, AccountSchema: e.AccountSchema, sessionProvider: e.sessionProvider, onLogOut: () => { I.clearWithoutNotify() }, storage: e.storage, asActiveAccount: !0 }); else { const i = e.crypto.newRandomSecretSeed(), n = e.newAccountProps?.secret ?? A.agentSecretFromSecretSeed(i), r = e.newAccountProps?.creationProps ?? { name: e.defaultProfileName ?? "Anonymous user" }; g = await ip({ creationProps: r, initialAgentSecret: n, peers: e.peers, crypto: A, AccountSchema: e.AccountSchema, onLogOut: async () => { await I.clearWithoutNotify() }, storage: e.storage }), e.newAccountProps || await I.setWithoutNotify({ accountID: g.account.$jazz.id, secretSeed: i, accountSecret: g.node.getCurrentAgent().agentSecret, provider: "anonymous" }) } return { ...g, authSecretStorage: I } } function Mc({ peers: e, crypto: A, storage: g }) { const I = A.newRandomAgentSecret(), t = new Qe(I, A.newRandomSessionID(A.getAgentID(I)), A); for (const i of e) t.syncManager.addPeer(i); return g && t.setStorage(g), fA.setGuestMode(), { agent: new Jr(t), done: () => { }, logOut: async () => { } } } var Fc = class Uc { constructor(A, g) { this.coValueClass = g, this.collaborative = !0, this.builtin = "CoDiscriminatedUnion", this.resolveQuery = !0, this.getDefinition = A.getDefinition } load(A, g) { return this.coValueClass.load(A, sA(g, this.resolveQuery)) } subscribe(A, g, I) { return this.coValueClass.subscribe(A, sA(g, this.resolveQuery), I) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } resolved(A) { const g = this.getDefinition(), I = Rc(g.discriminator, g.options), t = new Uc(I, this.coValueClass); return t.resolveQuery = A, t } }; function Rc(e, A) { return { collaborative: !0, builtin: "CoDiscriminatedUnion", getDefinition: () => ({ discriminator: e, get discriminatorMap() { const g = {}; for (const I of A) { const t = I.getDefinition().discriminatorMap; if (!t || Object.keys(t).length === 0) throw new Error(`Invalid discriminated union option at index "${A.indexOf(I)}"`); for (const [i, n] of Object.entries(t)) { g[i] ??= new Set; for (const r of n) g[i].add(r) } } return g }, get options() { return A } }), resolveQuery: !0 } } var bc = class { constructor(e) { this.innerType = e, this.collaborative = !0, this.builtin = "CoOptional", this.getDefinition = () => ({ innerType: this.innerType }), this.resolveQuery = !0 } getCoValueClass() { return this.innerType.getCoValueClass() } }; function rp() { return { collaborative: !0, builtin: "CoRichText", resolveQuery: !0 } } var Yc = class { constructor(e) { this.coValueClass = e, this.collaborative = !0, this.builtin = "CoRichText", this.resolveQuery = !0 } create(e, A) { return this.coValueClass.create(e, A) } load(e, A) { return this.coValueClass.load(e, A) } subscribe(...e) { return this.coValueClass.subscribe(...e) } unstable_merge(e, A) { return _e(this.coValueClass, e, A) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } }; function op() { return { collaborative: !0, builtin: "Group", resolveQuery: !0 } } var Kc = class { constructor() { this.collaborative = !0, this.builtin = "Group", this.resolveQuery = !0 } getCoValueClass() { return Ae } optional() { return vA(this) } create(e) { return Ae.create(e) } load(e, A) { return Ae.load(e, A) } createInvite(e, A) { return Ae.createInvite(e, A) } subscribe(e, ...A) { return Ae.subscribe(e, ...A) } }, Cp = e => typeof e == "object" && e !== null && "_zod" in e, vc = e => Object.values(Kr(e)).every(A => Cp(A) || Ge(A) || ht(A)), Bp = e => { if (Ge(e)) throw new Error("co.map() expects an object as its argument, not a CoValue schema"); if (!vc(e)) throw new Error("co.map() supports only Zod v4 schemas and CoValue schemas") }, pe = e => { Bp(e); const A = rI(e); return HA(A) }, Qp = (e = { profile: pe({ name: bA(), inbox: ee(bA()), inboxInvite: ee(bA()) }), root: pe({}) }) => { const A = Vc(e); return HA(A) }, sp = () => { const e = op(); return HA(e) }, ap = (e, A) => pe({}).catchall(A), Ep = e => { const A = yp(e); return HA(A) }, cp = e => { if (Ge(e)) throw new Error("co.profile() expects an object as its argument, not a CoValue schema"); if (!vc(e)) throw new Error("co.profile() supports only Zod v4 schemas and CoValue schemas") }, up = (e = {}) => { cp(e); const A = Object.assign(e, { name: bA(), inbox: ee(bA()), inboxInvite: ee(bA()) }); return pe(A) }, hp = e => { const A = pp(e); return HA(A) }, Gi = () => { const e = Np(); return HA(e) }, lp = e => { if (!(Number.isInteger(e) && e > 0)) throw new Error("co.vector() expects the vector dimensions count to be a positive integer"); const g = kp(e); return HA(g) }, wp = () => { const e = mp(); return HA(e) }, dp = () => { const e = rp(); return HA(e) }, Dp = () => Up, vA = e => new bc(e), fp = (e, A) => { const g = Rc(e, A); return HA(g) }, xr = {}; QC(xr, { Account: () => Zc, DiscriminatedUnion: () => Fc, Feed: () => xc, FileStream: () => jc, Group: () => Kc, List: () => Lc, Map: () => Jc, Optional: () => bc, PlainText: () => Oc, RichText: () => Yc, Vector: () => Tc, account: () => Qp, discriminatedUnion: () => fp, feed: () => hp, fileStream: () => Gi, group: () => sp, image: () => Dp, list: () => Ep, map: () => pe, optional: () => vA, plainText: () => wp, profile: () => up, record: () => ap, richText: () => dp, vector: () => lp }); var Jc = class Hc { constructor(A, g) { this.coValueClass = g, this.collaborative = !0, this.builtin = "CoMap", this.resolveQuery = !0, this.shape = A.shape, this.catchAll = A.catchAll, this.getDefinition = A.getDefinition } create(...A) { return this.coValueClass.create(...A) } load(A, g) { return this.coValueClass.load(A, sA(g, this.resolveQuery)) } unstable_merge(A, g) { return _e(this.coValueClass, A, sA(g, this.resolveQuery)) } subscribe(A, g, I) { return this.coValueClass.subscribe(A, sA(g, this.resolveQuery), I) } findUnique(A, g, I) { return this.coValueClass.findUnique(A, g, I) } upsertUnique(A) { return this.coValueClass.upsertUnique(sA(A, this.resolveQuery)) } loadUnique(A, g, I) { return this.coValueClass.loadUnique(A, g, sA(I, this.resolveQuery)) } catchall(A) { const g = rI(this.shape, A); return HA(g) } withMigration(A) { return this.coValueClass.prototype.migrate = A, this } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } pick(A) { const g = new Set(Object.keys(A)), I = {}; for (const [t, i] of Object.entries(this.shape)) g.has(t) && (I[t] = i); return pe(I) } partial(A) { const g = {}; for (const [t, i] of Object.entries(this.shape)) { if (A && !A[t]) { g[t] = i; continue } Ge(i) ? g[t] = vA(i) : g[t] = ee(this.shape[t]) } const I = pe(g); return this.catchAll ? I.catchall(this.catchAll) : I } resolved(A) { const g = rI(this.shape, this.catchAll), I = new Hc(g, this.coValueClass); return I.resolveQuery = A, I } }; function rI(e, A) { return { collaborative: !0, builtin: "CoMap", shape: e, catchAll: A, getDefinition: () => ({ get shape() { return e }, get catchall() { return A }, get discriminatorMap() { const g = {}; for (const I in Kr(e)) { if (Ge(e[I])) continue; const t = e[I]._zod; if (t.values) { g[I] ??= new Set; for (const i of t.values) g[I].add(i) } } return g } }), resolveQuery: !0 } } var Lc = class qc { constructor(A, g) { this.element = A, this.coValueClass = g, this.collaborative = !0, this.builtin = "CoList", this.resolveQuery = !0 } create(A, g) { return this.coValueClass.create(A, g) } load(A, g) { return this.coValueClass.load(A, sA(g, this.resolveQuery)) } unstable_merge(A, g) { return _e(this.coValueClass, A, sA(g, this.resolveQuery)) } subscribe(A, g, I) { return this.coValueClass.subscribe(A, sA(g, this.resolveQuery), I) } getCoValueClass() { return this.coValueClass } findUnique(A, g, I) { return this.coValueClass.findUnique(A, g, I) } upsertUnique(A) { return this.coValueClass.upsertUnique(sA(A, this.resolveQuery)) } loadUnique(A, g, I) { return this.coValueClass.loadUnique(A, g, sA(I, this.resolveQuery)) } optional() { return vA(this) } resolved(A) { const g = new qc(this.element, this.coValueClass); return g.resolveQuery = A, g } }; function yp(e) { return { collaborative: !0, builtin: "CoList", element: e, resolveQuery: !0 } } var xc = class zc { constructor(A, g) { this.element = A, this.coValueClass = g, this.collaborative = !0, this.builtin = "CoFeed", this.resolveQuery = !0 } create(A, g) { return this.coValueClass.create(A, g) } load(A, g) { return this.coValueClass.load(A, sA(g, this.resolveQuery)) } unstable_merge(A, g) { return _e(this.coValueClass, A, sA(g, this.resolveQuery)) } subscribe(A, ...g) { const { options: I, listener: t } = yA(g); return this.coValueClass.subscribe(A, sA(I, this.resolveQuery), t) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } resolved(A) { const g = new zc(this.element, this.coValueClass); return g.resolveQuery = A, g } }; function pp(e) { return { collaborative: !0, builtin: "CoFeed", element: e, resolveQuery: !0 } } function mp() { return { collaborative: !0, builtin: "CoPlainText", resolveQuery: !0 } } var Oc = class { constructor(e) { this.coValueClass = e, this.collaborative = !0, this.builtin = "CoPlainText", this.resolveQuery = !0 } create(e, A) { return this.coValueClass.create(e, A) } load(e, A) { return this.coValueClass.load(e, A) } subscribe(...e) { return this.coValueClass.subscribe(...e) } unstable_merge(e, A) { return _e(this.coValueClass, e, A) } fromRaw(e) { return this.coValueClass.fromRaw(e) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } }; function Np() { return { collaborative: !0, builtin: "FileStream", resolveQuery: !0 } } var jc = class { constructor(e) { this.coValueClass = e, this.collaborative = !0, this.builtin = "FileStream", this.resolveQuery = !0 } create(e) { return this.coValueClass.create(e) } createFromBlob(e, A) { return this.coValueClass.createFromBlob(e, A) } createFromArrayBuffer(...e) { return this.coValueClass.createFromArrayBuffer(...e) } loadAsBlob(e, A) { return this.coValueClass.loadAsBlob(e, A) } load(e, A) { return this.coValueClass.load(e, A) } unstable_merge(e, A) { return _e(this.coValueClass, e, A) } subscribe(...e) { return this.coValueClass.subscribe(...e) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } }; function kp(e) { return { collaborative: !0, builtin: "CoVector", dimensions: e, resolveQuery: !0 } } var Tc = class { constructor(e, A) { this.dimensions = e, this.coValueClass = A, this.collaborative = !0, this.builtin = "CoVector", this.resolveQuery = !0 } create(e, A) { return this.coValueClass.create(e, A) } load(e, A) { return this.coValueClass.load(e, A) } subscribe(...e) { return this.coValueClass.subscribe(...e) } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } }, Zc = class Pc { constructor(A, g) { this.coValueClass = g, this.collaborative = !0, this.builtin = "Account", this.resolveQuery = !0, this.shape = A.shape, this.getDefinition = A.getDefinition } create(A) { return this.coValueClass.create(A) } load(A, g) { return this.coValueClass.load(A, sA(g, this.resolveQuery)) } createAs(A, g) { return this.coValueClass.createAs(A, g) } unstable_merge(A, g) { return _e(this.coValueClass, A, sA(g, this.resolveQuery)) } subscribe(A, g, I) { return this.coValueClass.subscribe(A, sA(g, this.resolveQuery), I) } getMe() { return this.coValueClass.getMe() } withMigration(A) { return this.coValueClass.prototype.migrate = async function (g) { await A(this, g) }, this } getCoValueClass() { return this.coValueClass } optional() { return vA(this) } resolved(A) { const g = Vc(this.shape), I = new Pc(g, this.coValueClass); return I.resolveQuery = A, I } }; function Vc(e) { return { ...rI(e), builtin: "Account" } } function Gp(e) { if (Sp(e)) { const A = e.getDefinition(), { discriminatorMap: g, discriminator: I, options: t } = A, i = g[I]; if (!i) throw new Error("co.discriminatedUnion() of collaborative types with non-existent discriminator key is not supported"); for (const o of i) if (typeof o != "string" && typeof o != "number") throw new Error("co.discriminatedUnion() of collaborative types with non-string or non-number discriminator value is not supported"); const n = []; for (const o of t) if (o.builtin === "CoMap") n.push(o); else if (o.builtin === "CoDiscriminatedUnion") for (const C of o.getDefinition().options) t.includes(C) || t.push(C); else throw new Error("Unsupported zod type in co.discriminatedUnion() of collaborative types"); return o => { const C = new Set; for (const B of n) { const Q = B.getDefinition().shape; for (const [s, E] of Object.entries(Q)) Ge(E) && C.add(s) } for (const B of n) { let Q = !0; const s = B.getDefinition(); for (const E of Object.keys(g)) { const a = s.shape[E], c = o.get(E); if (c && typeof c == "object") throw new Error("Discriminator must be a primitive value"); if (!a) if (E === I) { Q = !1; break } else continue; if (a._zod?.def.type !== "literal") break; const u = a._zod.def; if (!Array.from(u.values).includes(c)) { Q = !1; break } } if (Q) { const a = HA(B).getCoValueClass(), c = Array.from(C).filter(u => !s.shape[u]); return c.length === 0 ? a : class extends a { constructor(...u) { super(...u); for (const h of c) this[h] = iA.null } } } } throw new Error("co.discriminatedUnion() of collaborative types with no matching discriminator value found") } } else throw new Error("co.discriminatedUnion() of non-collaborative types is not supported") } function Sp(e) { return e.getDefinition().options.every(Wc) } function Wc(e) { return e.builtin === "CoMap" ? !0 : e.builtin === "CoDiscriminatedUnion" ? e.getDefinition().options.every(Wc) : !1 } function Xc(e) { return e instanceof uI ? e._zod.def.options.every(Xc) : !Ge(e) } function Mp(e) { return iA.optional.encoded({ encode: A => { if (A !== void 0) return A === null ? null : e._zod.def.reverseTransform(A, { value: A, issues: [] }) }, decode: A => { if (A === null) return null; if (A !== void 0) return e._zod.def.transform(A, { value: A, issues: [] }) } }) } function Ce(e) { if (ht(e)) return iA.ref(e); if (zr(e)) return e.builtin === "CoOptional" ? iA.ref(e.getCoValueClass(), { optional: !0 }) : iA.ref(e.getCoValueClass()); if ("_zod" in e) { const A = e._zod.def; if (A.type === "optional" || A.type === "nullable") { const g = A.innerType, I = Ce(g); if (A.type === "nullable" && I === iA.optional.Date) throw new Error("Nullable z.date() is not supported"); return I } else { if (A.type === "string") return iA.string; if (A.type === "number") return iA.number; if (A.type === "boolean") return iA.boolean; if (A.type === "null") return iA.null; if (A.type === "enum") return iA.string; if (A.type === "readonly") return Ce(e.def.innerType); if (A.type === "date") return iA.optional.Date; if (A.type === "template_literal") return iA.string; if (A.type === "lazy") return Ce(e.unwrap()); if (A.type === "default" || A.type === "catch") return console.warn("z.default()/z.catch() are not supported in collaborative schemas. They will be ignored."), Ce(e.def.innerType); if (A.type === "literal") { if (A.values.some(g => typeof g > "u")) throw new Error("z.literal() with undefined is not supported"); if (A.values.some(g => g === null)) throw new Error("z.literal() with null is not supported"); if (A.values.some(g => typeof g == "bigint")) throw new Error("z.literal() with bigint is not supported"); return iA.literal(...A.values) } else { if (A.type === "object" || A.type === "record" || A.type === "array" || A.type === "tuple" || A.type === "intersection") return iA.json(); if (A.type === "union") { if (Xc(e)) return iA.json(); throw new Error("z.union()/z.discriminatedUnion() of collaborative types is not supported. Use co.discriminatedUnion() instead.") } else if (A.type === "pipe") { if (!(A.transform !== void 0 && A.reverseTransform !== void 0)) throw new Error("z.pipe() is not supported. Only z.codec() is supported."); try { Ce(A.in) } catch (I) { throw I instanceof Error && (I.message = `z.codec() is only supported if the input schema is already supported. ${I.message}`), I } return Mp(e) } else throw new Error(`Unsupported zod type: ${e._zod?.def?.type || JSON.stringify(e)}`) } } } else throw new Error(`Unsupported zod type: ${e}`) } function Ge(e) { return typeof e == "object" && e !== null && "collaborative" in e && e.collaborative === !0 } function zr(e) { return Ge(e) && "getCoValueClass" in e } function HA(e) { var A; if (zr(e)) return e; if (e.builtin === "CoOptional") throw new Error(`co.optional() of collaborative types is not supported as top-level schema: ${JSON.stringify(e)}`); if (e.builtin === "CoMap" || e.builtin === "Account") { const g = e.getDefinition(), I = e.builtin === "Account" ? te : vr, t = class extends I { constructor(r) { super(r); for (const [o, C] of Object.entries(g.shape)) this[o] = Ce(C); g.catchall && (this[iA.items] = Ce(g.catchall)) } }; return I === te ? new Zc(e, t) : new Jc(e, t) } else if (e.builtin === "CoList") { const g = e.element, I = class extends Ry { constructor(n) { super(n), this[iA.items] = Ce(g) } }; return new Lc(g, I) } else if (e.builtin === "CoFeed") { const g = Yy.Of(Ce(e.element)); return new xc(e.element, g) } else if (e.builtin === "FileStream") { const g = Hy; return new jc(g) } else if (e.builtin === "CoVector") { const g = e.dimensions, I = (A = class extends Vy { }, A.requiredDimensionsCount = g, A); return new Tc(g, I) } else if (e.builtin === "CoPlainText") { const g = Dc; return new Oc(g) } else if (e.builtin === "CoRichText") { const g = Zy; return new Yc(g) } else if (e.builtin === "CoDiscriminatedUnion") { const g = Py.Of(Gp(e)); return new Fc(e, g) } else { if (e.builtin === "Group") return new Kc; { const g = e; throw new Error(`Unsupported zod CoValue type for top-level schema: ${JSON.stringify(g, void 0, 2)}`) } } } function ut(e) { if (ht(e)) return e; if (zr(e)) return e.getCoValueClass(); throw new Error(`Unsupported schema: ${JSON.stringify(e)}`) } var Fp = pe({ original: Gi(), originalSize: SI([Og(), Og()]), placeholderDataURL: bA().optional(), progressive: mI() }).catchall(Gi()), Up = Fp, _c = class Jg { constructor() { this.storageInstance = null } static getInstance() { return Jg.instance || (Jg.instance = new Jg), Jg.instance } isInitialized() { return this.storageInstance !== null } initialize(A) { this.storageInstance || (this.storageInstance = A) } getStorage() { if (!this.storageInstance) throw new Error("Storage instance is not initialized."); return this.storageInstance } }, Ut = _c, Rp = "jazz-logged-in-secret", $c = class { constructor(e = Rp) { this.storageKey = e, bA().nonempty().parse(e), this.listeners = new Set, this.isAuthenticated = !1 } getStorageKey() { return this.storageKey } async migrate() { const e = Ut.getInstance().getStorage(); if (!await e.get(this.storageKey)) { const g = await e.get("demo-auth-logged-in-secret"); if (g) { const t = JSON.parse(g); await e.set(this.storageKey, JSON.stringify({ accountID: t.accountID, accountSecret: t.accountSecret, provider: "demo" })), await e.delete("demo-auth-logged-in-secret") } const I = await e.get("jazz-clerk-auth"); if (I) { const t = JSON.parse(I); await e.set(this.storageKey, JSON.stringify({ accountID: t.accountID, accountSecret: t.secret, provider: "clerk" })), await e.delete("jazz-clerk-auth") } } const A = await e.get(this.storageKey); if (A) { const g = JSON.parse(A); "secret" in g && await e.set(this.storageKey, JSON.stringify({ accountID: g.accountID, secretSeed: g.secretSeed, accountSecret: g.secret, provider: g.provider })) } } async get() { const A = await Ut.getInstance().getStorage().get(this.storageKey); if (!A) return null; const g = JSON.parse(A); if (!g.accountID || !g.accountSecret) throw new Error("Invalid auth secret storage data"); return { accountID: g.accountID, secretSeed: g.secretSeed ? new Uint8Array(g.secretSeed) : void 0, accountSecret: g.accountSecret, provider: g.provider } } async setWithoutNotify(e) { await Ut.getInstance().getStorage().set(this.storageKey, JSON.stringify({ accountID: e.accountID, secretSeed: e.secretSeed ? Array.from(e.secretSeed) : void 0, accountSecret: e.accountSecret, provider: e.provider })) } async set(e) { this.setWithoutNotify(e), this.emitUpdate(e) } getIsAuthenticated(e) { return e ? e.provider !== "anonymous" : !1 } onUpdate(e) { return this.listeners.add(e), () => { this.listeners.delete(e) } } emitUpdate(e) { const A = this.getIsAuthenticated(e); if (this.isAuthenticated !== A) { this.isAuthenticated = A; for (const g of this.listeners) g(this.isAuthenticated) } } async clearWithoutNotify() { await Ut.getInstance().getStorage().delete(this.storageKey) } async clear() { await this.clearWithoutNotify(), this.emitUpdate(null) } }, Au = class { constructor() { this.store = {} } async get(e) { const A = this.store[e]; return A || null } async set(e, A) { this.store[e] = A } async delete(e) { delete this.store[e] } async clearAll() { this.store = {} } }; function bp() { const e = Mc({ peers: [], crypto: new HI }); return { guest: e.agent, node: e.agent.node, done: () => { }, logOut: async () => { }, isAuthenticated: !1, authenticate: async () => { }, addConnectionListener: () => () => { }, connected: () => !1, register: async () => { throw new Error("Not implemented") } } } var Yp = class { constructor(e) { this.keepContextOpen = !1, this.authenticatingAccountID = null, this.logOut = async () => { if (!(!this.context || !this.props)) if (this.authenticatingAccountID = null, await this.props.onLogOut?.(), this.props.logOutReplacement) await this.props.logOutReplacement(); else return await this.context.logOut(), this.createContext(this.props) }, this.done = () => { this.context && this.context.done() }, this.shouldMigrateAnonymousAccount = async () => { if (!this.props?.onAnonymousAccountDiscarded) return !1; const A = await this.authSecretStorage.get(); return this.authSecretStorage.getIsAuthenticated(A) === !1 }, this.authenticate = async A => { if (!this.props) throw new Error("Props required"); if (this.authenticatingAccountID && this.authenticatingAccountID === A.accountID) { console.info("Authentication already in progress for account", A.accountID, "skipping duplicate request"); return } if (this.authenticatingAccountID && this.authenticatingAccountID !== A.accountID) throw new Error(`Authentication already in progress for different account (${this.authenticatingAccountID}), cannot authenticate ${A.accountID}`); this.authenticatingAccountID = A.accountID; try { const g = this.context, I = await this.shouldMigrateAnonymousAccount(); this.keepContextOpen = I, await this.createContext(this.props, { credentials: A }).finally(() => { this.keepContextOpen = !1 }), I && await this.handleAnonymousAccountMigration(g) } finally { this.authenticatingAccountID = null } }, this.register = async (A, g) => { if (!this.props) throw new Error("Props required"); if (this.authenticatingAccountID) throw new Error("Authentication already in progress"); this.authenticatingAccountID = "register"; try { const I = this.context, t = await this.shouldMigrateAnonymousAccount(); if (this.keepContextOpen = t, await this.createContext(this.props, { newAccountProps: { secret: A, creationProps: g } }).finally(() => { this.keepContextOpen = !1 }), t && await this.handleAnonymousAccountMigration(I), this.context && "me" in this.context) return this.context.me.$jazz.id; throw new Error("The registration hasn't created a new account") } finally { this.authenticatingAccountID = null } }, this.listeners = new Set, this.subscribe = A => (this.listeners.add(A), () => { this.listeners.delete(A) }), _c.getInstance().initialize(this.getKvStore()), this.authSecretStorage = new $c(e?.authSecretStorageKey), e?.useAnonymousFallback && (this.value = bp()) } getKvStore() { return new Au } async createContext(e, A) { this.props = e; const { promise: g, resolve: I } = Kp(), t = this.contextPromise; this.contextPromise = g, await t; try { const i = await this.getNewContext(e, A); await this.updateContext(e, i, A), I() } catch (i) { throw I(), i } } async getNewContext(e, A) { throw new Error("Not implemented") } async updateContext(e, A, g) { this.keepContextOpen || this.context?.done(), this.context = A, this.props = e, this.value = { ...A, node: A.node, authenticate: this.authenticate, register: this.register, logOut: this.logOut, addConnectionListener: A.addConnectionListener, connected: A.connected }, g?.credentials ? this.authSecretStorage.emitUpdate(g.credentials) : this.authSecretStorage.emitUpdate(await this.authSecretStorage.get()), this.notify() } propsChanged(e) { throw new Error("Not implemented") } getCurrentValue() { return this.value } setCurrentValue(e) { this.value = e } getAuthSecretStorage() { return this.authSecretStorage } getAuthenticatingAccountID() { return this.authenticatingAccountID } async handleAnonymousAccountMigration(e) { if (!this.props) throw new Error("Props required"); const A = this.context; if (e && A && "me" in e && "me" in A) { const [g, I] = KA.connectedPeers(e.me.$jazz.id, A.me.$jazz.id, { peer1role: "client", peer2role: "server" }); e.node.removeStorage(), A.node.syncManager.addPeer(g), e.node.syncManager.addPeer(I); try { await this.props.onAnonymousAccountDiscarded?.(e.me), await e.me.$jazz.waitForAllCoValuesSync() } catch (t) { console.error("Error onAnonymousAccountDiscarded", t) } g.outgoing.close(), I.outgoing.close() } e?.done() } notify() { for (const e of this.listeners) e() } }; function Kp() { let e; return { promise: new Promise(g => { e = g }), resolve: e } } globalThis.devtoolsFormatters = [{ header: e => e[q] === "CoMap" ? ["div", {}, ["span", {}, e.constructor.name]] : e[q] === "CoList" ? ["div", {}, ["span", {}, e.constructor.name + "(" + e.length + ") "]] : e[q] === "Account" ? ["div", {}, ["span", {}, e.constructor.name + "(" + e.$jazz.refs.profile.value?.name + (e.isMe ? " ME" : "") + ")"]] : null, hasBody: function () { return !0 }, body: function (e) { if (e[q] === "CoMap" || e[q] === "Account") return ["div", { style: "margin-left: 15px" }, ["div", "id: ", ["object", { object: e.id }]], ...Object.entries(e).map(([A, g]) => ["div", { style: "white-space: nowrap;" }, ["span", { style: "font-weight: bold; opacity: 0.6" }, A, ": "], ["object", { object: g }], ...typeof e._schema[A] == "function" ? g === null ? [["span", { style: "opacity: 0.5" }, ` (pending ${e._schema[A].name} `, ["object", { object: e.$jazz.refs[A] }], ")"]] : [] : []])]; if (e[q] === "CoList") return ["div", { style: "margin-left: 15px" }, ["div", "id: ", ["object", { object: e.id }]], ...e.map((A, g) => ["div", { style: "white-space: nowrap;" }, ["span", { style: "font-weight: bold; opacity: 0.6" }, g, ": "], ["object", { object: A }], ...typeof e._schema[AA] == "function" ? A === null ? [["span", { style: "opacity: 0.5" }, ` (pending ${e._schema[AA].name} `, ["object", { object: e.$jazz.refs[g] }], ")"]] : [] : []])] } }]; function ht(e) { return typeof e == "function" && e.fromRaw !== void 0 } function qe(e, A) { return { $jazz: { id: e, loadingState: A }, $isLoaded: !1 } } function mA(e, A, g) { return Or(e, A, { ...g, loadAs: g?.loadAs ?? fA.get(), unstable_branch: g?.unstable_branch }) } function Or(e, A, g) { return new Promise(I => { jr(e, A, { resolve: g.resolve, loadAs: g.loadAs, syncResolution: !0, skipRetry: g.skipRetry, onUnavailable: () => { I(qe(A, R.UNAVAILABLE)) }, onUnauthorized: () => { I(qe(A, R.UNAUTHORIZED)) }, unstable_branch: g.unstable_branch }, (t, i) => { I(t), i() }) }) } async function lt(e, A) { const g = await Or(e.constructor, e.$jazz.id, { loadAs: e.$jazz.loadedAs, resolve: A?.resolve, unstable_branch: A?.unstable_branch }); if (!g.$isLoaded) throw new Error("Failed to deeply load CoValue " + e.$jazz.id); return g } function yA(e) { if (e.length === 2) { if (typeof e[0] == "object" && e[0] && typeof e[1] == "function") return { options: { resolve: e[0].resolve, loadAs: e[0].loadAs, onUnauthorized: e[0].onUnauthorized, onUnavailable: e[0].onUnavailable, unstable_branch: e[0].unstable_branch }, listener: e[1] }; throw new Error("Invalid arguments") } else { if (typeof e[0] == "function") return { options: {}, listener: e[0] }; throw new Error("Invalid arguments") } } function TA(e, A, g, I) { return jr(e, A, { ...g, loadAs: g.loadAs ?? fA.get() }, I) } function jr(e, A, g, I) { const t = g.loadAs ?? fA.get(), i = "node" in t ? t.node : t.$jazz.localNode, n = g.resolve ?? !0; let r = !1; const o = new LI(i, n, A, { ref: e, optional: !1 }, g.skipRetry, !1, g.unstable_branch), C = s => { r || (s.type === R.UNAVAILABLE ? (g.onUnavailable?.(), g.skipRetry || console.error(s.toString())) : s.type === R.UNAUTHORIZED ? (g.onUnauthorized?.(), console.error(s.toString())) : s.type === R.LOADED && I(s.value, Q)) }; let B = !g.syncResolution; o.setListener(s => { B ? (B = !1, Promise.resolve().then(() => { C(s) })) : C(s) }); function Q() { r = !0, o.destroy() } return Q } function Se(e, A, g) { return jr(e.constructor, e.$jazz.id, { loadAs: e.$jazz.loadedAs, resolve: A?.resolve, onUnavailable: A?.onUnavailable, onUnauthorized: A?.onUnauthorized, unstable_branch: A?.unstable_branch }, g) } function vp(e) { return typeof e != "object" || e === null ? !1 : q in e && e[q] === "Account" } function fg(e) { const A = MA.Group; if (!e) return { owner: A.create(), uniqueness: void 0 }; if (q in e) { if (e[q] === "Account") return { owner: oI(e), uniqueness: void 0 }; if (e[q] === "Group") return { owner: e, uniqueness: void 0 } } const g = e.unique ? { uniqueness: e.unique } : void 0; return { owner: e.owner ? oI(e.owner) : A.create(), uniqueness: g } } function oI(e) { return e[q] === "Group" ? e : MA.Group.fromRaw(e.$jazz.raw) } function Jp(e) { return e ? q in e && vp(e) ? { owner: e } : { owner: e.owner ?? fA.get() } : { owner: fA.get() } } function eu(e, A) { A ||= fA.get(); const g = A[q] === "Anonymous" ? A.node : A.$jazz.localNode; return KA.idforHeader(e, g.crypto) } async function CI(e, A) { const g = A.owner.$jazz.loadedAs, I = g[q] === "Anonymous" ? g.node : g.$jazz.localNode, t = KA.idforHeader(A.header, I.crypto), i = await mA(e, t, { skipRetry: !0, loadAs: g }), n = I.getCoValue(t).hasVerifiedContent(); if (A.onCreateWhenMissing && !n) return A.onCreateWhenMissing(), mA(e, t, { loadAs: g, resolve: A.resolve }); if (!n) return i; if (A.onUpdateWhenFound) { const r = await mA(e, t, { loadAs: g, resolve: A.resolve }); if (r.$isLoaded) A.onUpdateWhenFound(r); else return r } return mA(e, t, { loadAs: g, resolve: A.resolve }) } function gu(e) { if (!e.unstable_branch) return; function A(g) { g.value.type === R.LOADED && g.value.value.$jazz.raw.core.mergeBranch(); for (const I of g.childNodes.values()) A(I) } A(e) } async function _e(e, A, g) { const I = g.loadAs ?? fA.get(), t = "node" in I ? I.node : I.$jazz.localNode, i = g.resolve ?? !0, n = new LI(t, i, A, { ref: ut(e), optional: !1 }, !1, !1, g.branch); await new Promise((r, o) => { n.setListener(C => { C.type === R.UNAVAILABLE ? o(new Error("Unable to load the branch. " + C.toString())) : C.type === R.UNAUTHORIZED ? o(new Error("Unable to load the branch. " + C.toString())) : C.type === R.LOADED && r(), n.destroy() }) }), gu(n) } function oC(e, A) {
      return e ? `${e}
${JSON.stringify(A)}` : JSON.stringify(A)
    } function Hp(e) {
      if (typeof e != "string") return { ok: !1, error: new Error("Expected a string") }; try {
        return {
          ok: !0, messages: e.split(`
`).map(A => JSON.parse(A))
        }
      } catch (A) { return x.error("Error while deserializing messages", { err: A }), { ok: !1, error: A } }
    } const Lp = 1e5, qp = 10; function vt(e) { return e.readyState === 1 } function tu(e) { return e.bufferedAmount > Lp && vt(e) } function xp(e) { return new Promise(A => { e.readyState === 1 ? A() : e.addEventListener("open", () => A(), { once: !0 }) }) } async function zp(e) { for (; tu(e);)await new Promise(A => setTimeout(A, qp)) } const { CO_VALUE_PRIORITY: Op, getContentMessageSize: jp } = KA, Tp = 25e3; class Zp { constructor(A, g, I, t, i) { this.websocket = A, this.batching = g, this.meta = t, this.backlog = "", this.processing = !1, this.closed = !1, this.closeListeners = new Set, this.egressBytesCounter = (i ?? se.getMeter("cojson-transport-ws")).createCounter("jazz.usage.egress", { description: "Total egress bytes", unit: "bytes", valueType: jA.INT }), this.queue = new Ef(Op.HIGH, "outgoing", { peerRole: I }), this.egressBytesCounter.add(0, this.meta) } push(A) { if (A === "Disconnected") { this.close(); return } this.queue.push(A), !this.processing && this.processQueue().catch(g => { x.error("Error while processing sendMessage queue", { err: g }) }) } async processQueue() { const { websocket: A } = this; this.processing = !0, await new Promise(I => setTimeout(I, 5)); let g = this.queue.pull(); for (; g;) { if (this.closed) return; vt(A) || await xp(A), tu(A) && await zp(A), vt(A) && (this.processMessage(g), g = this.queue.pull()) } this.sendMessagesInBulk(), this.processing = !1 } processMessage(A) { if (A.action === "content" && this.egressBytesCounter.add(jp(A), this.meta), !this.batching) { this.websocket.send(JSON.stringify(A)); return } const g = oC(this.backlog, A), I = g.length >= Tp, t = this.backlog.length > 0; I && t ? (this.sendMessagesInBulk(), this.backlog = oC("", A)) : I ? (this.backlog = g, this.sendMessagesInBulk()) : this.backlog = g } sendMessagesInBulk() { this.backlog.length > 0 && vt(this.websocket) && (this.websocket.send(this.backlog), this.backlog = "") } setBatching(A) { this.batching = A } onClose(A) { this.closeListeners.add(A) } close() { if (this.closed) return; let A = this.queue.pull(); for (; A;)this.processMessage(A), A = this.queue.pull(); this.closed = !0, this.sendMessagesInBulk(); for (const g of this.closeListeners) g(); this.closeListeners.clear() } } const { ConnectedPeerChannel: Pp, getContentMessageSize: Vp } = KA; function Wp(e, A, g) { if (!e) return { reset() { }, clear() { } }; let I = null; return { reset() { I && clearTimeout(I), I = setTimeout(() => { g() }, A) }, clear() { I && clearTimeout(I) } } } function Xp(e = () => { }) { let A = !1; return () => { A || (A = !0, e()) } } function _p({ id: e, websocket: A, role: g, expectPings: I = !0, batchingByDefault: t = !0, deletePeerStateOnClose: i = !1, pingTimeout: n = 1e4, onSuccess: r, onClose: o, meter: C, meta: B }) { const Q = (C ?? se.getMeter("cojson-transport-ws")).createCounter("jazz.usage.ingress", { description: "Total ingress bytes from peer", unit: "bytes", valueType: jA.INT }); Q.add(0, B); const s = new Pp, E = Xp(o); function a() { s.push("Disconnected"), E() } A.addEventListener("close", a), A.addEventListener("error", w => { w.message && x.warn("WebSocket error", { err: w }), a() }); const c = Wp(I, n, () => { s.push("Disconnected"), x.warn("Ping timeout from peer", { peerId: e, peerRole: g }), E() }), u = new Zp(A, t, g, B, C); let h = !0; function d(w) { if (c.reset(), w.data === "") return; const f = Hp(w.data); if (!f.ok) { x.warn("Error while deserializing messages", { err: f.error }); return } h && (r?.(), h = !1); const { messages: F } = f; F.length > 1 && u.setBatching(!0); for (const Y of F) Y && "action" in Y && (s.push(Y), Y.action === "content" && Q.add(Vp(Y), B)) } return A.addEventListener("message", d), u.onClose(() => { A.removeEventListener("message", d), A.removeEventListener("close", a), c.clear(), E(), A.readyState === 0 ? A.addEventListener("open", function () { A.close() }, { once: !0 }) : A.readyState === 1 && A.close() }), { id: e, incoming: s, outgoing: u, role: g, persistent: !i } } class $p { constructor(A) { this.enabled = !1, this.closed = !0, this.connected = !1, this.currentPeer = void 0, this.unsubscribeNetworkChange = void 0, this.reconnectionAttempts = 0, this.onConnectionChangeListeners = new Set, this.waitUntilConnected = async () => { if (this.closed) return new Promise(g => { const I = t => { t && (g(), this.onConnectionChangeListeners.delete(I)) }; this.onConnectionChangeListeners.add(I) }) }, this.subscribe = g => { this.onConnectionChangeListeners.add(g), g(!this.closed) }, this.unsubscribe = g => { this.onConnectionChangeListeners.delete(g) }, this.startConnection = async () => { if (this.enabled) { if (this.currentPeer) { this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.reconnectionAttempts++; const g = this.reconnectionTimeout * this.reconnectionAttempts; x.debug(`Websocket disconnected, trying to reconnect in ${g}ms`), await this.waitForOnline(g) } this.enabled && (this.currentPeer = _p({ websocket: new this.WebSocketConstructor(this.peer), pingTimeout: this.pingTimeout, id: this.peer, role: "server", onClose: () => { this.closed = !0, this.connected = !1; for (const g of this.onConnectionChangeListeners) g(!1); this.startConnection() }, onSuccess: () => { this.closed = !1, this.connected = !0; for (const g of this.onConnectionChangeListeners) g(!0); x.debug("Websocket connection successful"), this.reconnectionAttempts = 0 } }), this.addPeer(this.currentPeer)) } }, this.enable = () => { this.enabled || (this.connected = !0, this.enabled = !0, this.startConnection()) }, this.disable = () => { this.enabled && (this.enabled = !1, this.reconnectionAttempts = 0, this.unsubscribeNetworkChange?.(), this.unsubscribeNetworkChange = void 0, this.currentPeer && (this.removePeer(this.currentPeer), this.currentPeer.outgoing.close(), this.currentPeer = void 0)) }, this.peer = A.peer, this.reconnectionTimeout = A.reconnectionTimeout || 500, this.addPeer = A.addPeer, this.removePeer = A.removePeer, this.WebSocketConstructor = A.WebSocketConstructor || WebSocket, this.pingTimeout = A.pingTimeout || 1e4 } onNetworkChange(A) { return () => { } } waitForOnline(A) { return new Promise(g => { const I = this.onNetworkChange(n => { n && t() }); function t() { clearTimeout(i), I?.(), g() } const i = setTimeout(t, A) }) } } var Am = we.custom(jy), em = we.custom(e => typeof e == "string" && e.startsWith("signature_z")); we.object({ contentPieces: we.array(we.json()), id: Am, createdAt: we.number(), authToken: em, signerID: we.custom(e => typeof e == "string" && e.startsWith("signer_z")) }); class CC { constructor(A) { this.pendingRequests = [], this.rejectHandlers = [], this.id = Math.random(), this.running = !1, this.failed = !1, this.done = !1, this.startedAt = performance.now(), this.db = A, this.refresh() } refresh() { this.tx = this.db.transaction(["coValues", "sessions", "transactions", "signatureAfter"], "readwrite"), this.tx.oncomplete = () => { this.done = !0 }, this.tx.onabort = () => { this.done = !0 } } isReusable() { const A = performance.now() - this.startedAt; return !this.done && !this.failed && A <= 100 } getObjectStore(A) { try { return this.tx.objectStore(A) } catch { return this.refresh(), this.tx.objectStore(A) } } pushRequest(A) { const g = () => { const I = this.pendingRequests.shift(); I ? I(this) : (this.running = !1, this.done = !0) }; return this.running ? new Promise((I, t) => { this.rejectHandlers.push(t), this.pendingRequests.push(async () => { try { const i = await A(this, g); I(i) } catch (i) { t(i) } }) }) : (this.running = !0, A(this, g)) } handleRequest(A) { return this.pushRequest((g, I) => new Promise((t, i) => { const n = A(g); n.onerror = () => { this.failed = !0, this.tx.abort(), console.error(n.error), i(n.error); for (const r of this.rejectHandlers) r() }, n.onsuccess = () => { t(n.result), I() } })) } commit() { this.done || this.tx.commit() } } function Gg(e, A, g) { return new Promise((I, t) => { const i = e.transaction(A, "readonly"), n = g(i.objectStore(A)); n.onerror = () => { t(n.error) }, n.onsuccess = () => { I(n.result), i.commit() } }) } function gm(e, A, g) { return new Promise((I, t) => { const i = e.transaction(A, "readwrite"), n = i.objectStore(A).put(g); n.onerror = () => { t(n.error) }, n.onsuccess = () => { I(n.result), i.commit() } }) } class tm { constructor(A) { this.db = A } makeRequest(A) { if (this.activeTransaction) return this.activeTransaction.handleRequest(A); if (this.autoBatchingTransaction?.isReusable()) return this.autoBatchingTransaction.handleRequest(A); const g = new CC(this.db); return this.autoBatchingTransaction = g, g.handleRequest(A) } async getCoValue(A) { return Gg(this.db, "coValues", g => g.index("coValuesById").get(A)) } async getCoValueRowID(A) { return this.getCoValue(A).then(g => g?.rowID) } async getCoValueSessions(A) { return Gg(this.db, "sessions", g => g.index("sessionsByCoValue").getAll(A)) } async getSingleCoValueSession(A, g) { return Gg(this.db, "sessions", I => I.index("uniqueSessions").get([A, g])) } async getNewTransactionInSession(A, g, I) { return Gg(this.db, "transactions", t => t.getAll(IDBKeyRange.bound([A, g], [A, I]))) } async getSignatures(A, g) { return Gg(this.db, "signatureAfter", I => I.getAll(IDBKeyRange.bound([A, g], [A, Number.POSITIVE_INFINITY]))) } async upsertCoValue(A, g) { return g ? gm(this.db, "coValues", { id: A, header: g }).catch(() => this.getCoValueRowID(A)) : this.getCoValueRowID(A) } async addSessionUpdate({ sessionUpdate: A, sessionRow: g }) { return this.makeRequest(I => I.getObjectStore("sessions").put(g?.rowID ? { rowID: g.rowID, ...A } : A)) } async addTransaction(A, g, I) { await this.makeRequest(t => t.getObjectStore("transactions").add({ ses: A, idx: g, tx: I })) } async addSignatureAfter({ sessionRowID: A, idx: g, signature: I }) { return this.makeRequest(t => t.getObjectStore("signatureAfter").put({ ses: A, idx: g, signature: I })) } closeTransaction(A) { A.commit(), A === this.activeTransaction && (this.activeTransaction = void 0) } async transaction(A) { const g = new CC(this.db); this.activeTransaction = g; try { await A(), g.commit() } finally { this.activeTransaction = void 0 } } } let Im = "jazz-storage"; async function im(e = Im) { const g = await new Promise((I, t) => { const i = indexedDB.open(e, 4); i.onerror = () => { t(i.error) }, i.onsuccess = () => { I(i.result) }, i.onupgradeneeded = async n => { const r = i.result; if (n.oldVersion === 0) { r.createObjectStore("coValues", { autoIncrement: !0, keyPath: "rowID" }).createIndex("coValuesById", "id", { unique: !0 }); const C = r.createObjectStore("sessions", { autoIncrement: !0, keyPath: "rowID" }); C.createIndex("sessionsByCoValue", "coValue"), C.createIndex("uniqueSessions", ["coValue", "sessionID"], { unique: !0 }), r.createObjectStore("transactions", { keyPath: ["ses", "idx"] }) } n.oldVersion <= 1 && r.createObjectStore("signatureAfter", { keyPath: ["ses", "idx"] }) } }); return new hf(new tm(g)) } let D, H = 0, Hg = null; function Cg() { return (Hg === null || Hg.byteLength === 0) && (Hg = new Uint8Array(D.memory.buffer)), Hg } const Jt = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => { throw Error("TextEncoder not available") } }, nm = typeof Jt.encodeInto == "function" ? function (e, A) { return Jt.encodeInto(e, A) } : function (e, A) { const g = Jt.encode(e); return A.set(g), { read: e.length, written: g.length } }; function nA(e, A, g) { if (g === void 0) { const r = Jt.encode(e), o = A(r.length, 1) >>> 0; return Cg().subarray(o, o + r.length).set(r), H = r.length, o } let I = e.length, t = A(I, 1) >>> 0; const i = Cg(); let n = 0; for (; n < I; n++) { const r = e.charCodeAt(n); if (r > 127) break; i[t + n] = r } if (n !== I) { n !== 0 && (e = e.slice(n)), t = g(t, I, I = n + e.length * 3, 1) >>> 0; const r = Cg().subarray(t + n, t + I), o = nm(e, r); n += o.written, t = g(t, I, n, 1) >>> 0 } return H = n, t } let Ue = null; function Re() { return (Ue === null || Ue.buffer.detached === !0 || Ue.buffer.detached === void 0 && Ue.buffer !== D.memory.buffer) && (Ue = new DataView(D.memory.buffer)), Ue } function rg(e) { const A = D.__externref_table_alloc(); return D.__wbindgen_export_4.set(A, e), A } function Sg(e, A) { try { return e.apply(this, A) } catch (g) { const I = rg(g); D.__wbindgen_exn_store(I) } } const Iu = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => { throw Error("TextDecoder not available") } }; typeof TextDecoder < "u" && Iu.decode(); function xA(e, A) { return e = e >>> 0, Iu.decode(Cg().subarray(e, e + A)) } function de(e) { return e == null } function Si(e) {
      const A = typeof e; if (A == "number" || A == "boolean" || e == null) return `${e}`; if (A == "string") return `"${e}"`; if (A == "symbol") { const t = e.description; return t == null ? "Symbol" : `Symbol(${t})` } if (A == "function") { const t = e.name; return typeof t == "string" && t.length > 0 ? `Function(${t})` : "Function" } if (Array.isArray(e)) { const t = e.length; let i = "["; t > 0 && (i += Si(e[0])); for (let n = 1; n < t; n++)i += ", " + Si(e[n]); return i += "]", i } const g = /\[object ([^\]]+)\]/.exec(toString.call(e)); let I; if (g && g.length > 1) I = g[1]; else return toString.call(e); if (I == "Object") try { return "Object(" + JSON.stringify(e) + ")" } catch { return "Object" } return e instanceof Error ? `${e.name}: ${e.message}
${e.stack}` : I
    } function rm(e, A) { const g = A(e.length * 4, 4) >>> 0; for (let I = 0; I < e.length; I++) { const t = rg(e[I]); Re().setUint32(g + 4 * I, t, !0) } return H = e.length, g } function SA(e) { const A = D.__wbindgen_export_4.get(e); return D.__externref_table_dealloc(e), A } function aA(e, A) { const g = A(e.length * 1, 1) >>> 0; return Cg().set(e, g / 1), H = e.length, g } function Me(e, A) { return e = e >>> 0, Cg().subarray(e / 1, e / 1 + A) } function om() { const e = D.newX25519PrivateKey(); var A = Me(e[0], e[1]).slice(); return D.__wbindgen_free(e[0], e[1] * 1, 1), A } function Cm(e) { let A, g; try { const i = aA(e, D.__wbindgen_malloc), n = H, r = D.getSealerId(i, n); var I = r[0], t = r[1]; if (r[3]) throw I = 0, t = 0, SA(r[2]); return A = I, g = t, xA(I, t) } finally { D.__wbindgen_free(A, g, 1) } } function Bm(e, A, g) { const I = aA(e, D.__wbindgen_malloc), t = H, i = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), n = H, r = aA(g, D.__wbindgen_malloc), o = H, C = D.encrypt(I, t, i, n, r, o); if (C[3]) throw SA(C[2]); var B = Me(C[0], C[1]).slice(); return D.__wbindgen_free(C[0], C[1] * 1, 1), B } function Qm(e, A, g) { const I = aA(e, D.__wbindgen_malloc), t = H, i = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), n = H, r = aA(g, D.__wbindgen_malloc), o = H, C = D.decrypt(I, t, i, n, r, o); if (C[3]) throw SA(C[2]); var B = Me(C[0], C[1]).slice(); return D.__wbindgen_free(C[0], C[1] * 1, 1), B } function sm(e, A, g, I) { const t = aA(e, D.__wbindgen_malloc), i = H, n = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), r = H, o = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), C = H, B = aA(I, D.__wbindgen_malloc), Q = H, s = D.seal(t, i, n, r, o, C, B, Q); if (s[3]) throw SA(s[2]); var E = Me(s[0], s[1]).slice(); return D.__wbindgen_free(s[0], s[1] * 1, 1), E } function am(e, A, g, I) { const t = aA(e, D.__wbindgen_malloc), i = H, n = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), r = H, o = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), C = H, B = aA(I, D.__wbindgen_malloc), Q = H, s = D.unseal(t, i, n, r, o, C, B, Q); if (s[3]) throw SA(s[2]); var E = Me(s[0], s[1]).slice(); return D.__wbindgen_free(s[0], s[1] * 1, 1), E } function Em(e) { const A = aA(e, D.__wbindgen_malloc), g = H, I = D.blake3HashOnce(A, g); var t = Me(I[0], I[1]).slice(); return D.__wbindgen_free(I[0], I[1] * 1, 1), t } function cm(e, A) { const g = aA(e, D.__wbindgen_malloc), I = H, t = aA(A, D.__wbindgen_malloc), i = H, n = D.blake3HashOnceWithContext(g, I, t, i); var r = Me(n[0], n[1]).slice(); return D.__wbindgen_free(n[0], n[1] * 1, 1), r } function um(e, A) { let g, I; try { const n = aA(e, D.__wbindgen_malloc), r = H, o = aA(A, D.__wbindgen_malloc), C = H, B = D.sign(n, r, o, C); var t = B[0], i = B[1]; if (B[3]) throw t = 0, i = 0, SA(B[2]); return g = t, I = i, xA(t, i) } finally { D.__wbindgen_free(g, I, 1) } } function hm(e, A, g) { const I = aA(e, D.__wbindgen_malloc), t = H, i = aA(A, D.__wbindgen_malloc), n = H, r = aA(g, D.__wbindgen_malloc), o = H, C = D.verify(I, t, i, n, r, o); if (C[2]) throw SA(C[1]); return C[0] !== 0 } function lm(e) { let A, g; try { const i = aA(e, D.__wbindgen_malloc), n = H, r = D.getSignerId(i, n); var I = r[0], t = r[1]; if (r[3]) throw I = 0, t = 0, SA(r[2]); return A = I, g = t, xA(I, t) } finally { D.__wbindgen_free(A, g, 1) } } function wm() { const e = D.newEd25519SigningKey(); var A = Me(e[0], e[1]).slice(); return D.__wbindgen_free(e[0], e[1] * 1, 1), A } typeof FinalizationRegistry > "u" || new FinalizationRegistry(e => D.__wbg_blake3hasher_free(e >>> 0, 1)); const ni = typeof FinalizationRegistry > "u" ? { register: () => { }, unregister: () => { } } : new FinalizationRegistry(e => D.__wbg_sessionlog_free(e >>> 0, 1)); class BI { static __wrap(A) { A = A >>> 0; const g = Object.create(BI.prototype); return g.__wbg_ptr = A, ni.register(g, g.__wbg_ptr, g), g } __destroy_into_raw() { const A = this.__wbg_ptr; return this.__wbg_ptr = 0, ni.unregister(this), A } free() { const A = this.__destroy_into_raw(); D.__wbg_sessionlog_free(A, 0) } constructor(A, g, I) { const t = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), i = H, n = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), r = H; var o = de(I) ? 0 : nA(I, D.__wbindgen_malloc, D.__wbindgen_realloc), C = H; const B = D.sessionlog_new(t, i, n, r, o, C); return this.__wbg_ptr = B >>> 0, ni.register(this, this.__wbg_ptr, this), this } clone() { const A = D.sessionlog_clone(this.__wbg_ptr); return BI.__wrap(A) } tryAdd(A, g, I) { const t = rm(A, D.__wbindgen_malloc), i = H, n = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), r = H, o = D.sessionlog_tryAdd(this.__wbg_ptr, t, i, n, r, I); if (o[1]) throw SA(o[0]) } addNewPrivateTransaction(A, g, I, t, i, n) { let r, o; try { const E = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), a = H, c = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), u = H, h = nA(I, D.__wbindgen_malloc, D.__wbindgen_realloc), d = H, w = nA(t, D.__wbindgen_malloc, D.__wbindgen_realloc), f = H; var C = de(n) ? 0 : nA(n, D.__wbindgen_malloc, D.__wbindgen_realloc), B = H; const F = D.sessionlog_addNewPrivateTransaction(this.__wbg_ptr, E, a, c, u, h, d, w, f, i, C, B); var Q = F[0], s = F[1]; if (F[3]) throw Q = 0, s = 0, SA(F[2]); return r = Q, o = s, xA(Q, s) } finally { D.__wbindgen_free(r, o, 1) } } addNewTrustingTransaction(A, g, I, t) { let i, n; try { const Q = nA(A, D.__wbindgen_malloc, D.__wbindgen_realloc), s = H, E = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), a = H; var r = de(t) ? 0 : nA(t, D.__wbindgen_malloc, D.__wbindgen_realloc), o = H; const c = D.sessionlog_addNewTrustingTransaction(this.__wbg_ptr, Q, s, E, a, I, r, o); var C = c[0], B = c[1]; if (c[3]) throw C = 0, B = 0, SA(c[2]); return i = C, n = B, xA(C, B) } finally { D.__wbindgen_free(i, n, 1) } } decryptNextTransactionChangesJson(A, g) { let I, t; try { const r = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), o = H, C = D.sessionlog_decryptNextTransactionChangesJson(this.__wbg_ptr, A, r, o); var i = C[0], n = C[1]; if (C[3]) throw i = 0, n = 0, SA(C[2]); return I = i, t = n, xA(i, n) } finally { D.__wbindgen_free(I, t, 1) } } decryptNextTransactionMetaJson(A, g) { const I = nA(g, D.__wbindgen_malloc, D.__wbindgen_realloc), t = H, i = D.sessionlog_decryptNextTransactionMetaJson(this.__wbg_ptr, A, I, t); if (i[3]) throw SA(i[2]); let n; return i[0] !== 0 && (n = xA(i[0], i[1]).slice(), D.__wbindgen_free(i[0], i[1] * 1, 1)), n } } async function dm(e, A) { if (typeof Response == "function" && e instanceof Response) { if (typeof WebAssembly.instantiateStreaming == "function") try { return await WebAssembly.instantiateStreaming(e, A) } catch (I) { if (e.headers.get("Content-Type") != "application/wasm") console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", I); else throw I } const g = await e.arrayBuffer(); return await WebAssembly.instantiate(g, A) } else { const g = await WebAssembly.instantiate(e, A); return g instanceof WebAssembly.Instance ? { instance: g, module: e } : g } } function Dm() { const e = {}; return e.wbg = {}, e.wbg.__wbg_String_8f0eb39a4a4c2f66 = function (A, g) { const I = String(g), t = nA(I, D.__wbindgen_malloc, D.__wbindgen_realloc), i = H; Re().setInt32(A + 4, i, !0), Re().setInt32(A + 0, t, !0) }, e.wbg.__wbg_buffer_609cc3eee51ed158 = function (A) { return A.buffer }, e.wbg.__wbg_call_672a4d21634d4a24 = function () { return Sg(function (A, g) { return A.call(g) }, arguments) }, e.wbg.__wbg_call_7cccdd69e0791ae2 = function () { return Sg(function (A, g, I) { return A.call(g, I) }, arguments) }, e.wbg.__wbg_crypto_574e78ad8b13b65f = function (A) { return A.crypto }, e.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function () { return Sg(function (A, g) { A.getRandomValues(g) }, arguments) }, e.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function (A) { return A.msCrypto }, e.wbg.__wbg_new_a12002a7f91c75be = function (A) { return new Uint8Array(A) }, e.wbg.__wbg_newnoargs_105ed471475aaf50 = function (A, g) { return new Function(xA(A, g)) }, e.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function (A, g, I) { return new Uint8Array(A, g >>> 0, I >>> 0) }, e.wbg.__wbg_newwithlength_a381634e90c276d4 = function (A) { return new Uint8Array(A >>> 0) }, e.wbg.__wbg_node_905d3e251edff8a2 = function (A) { return A.node }, e.wbg.__wbg_process_dc0fbacc7c1c06f7 = function (A) { return A.process }, e.wbg.__wbg_randomFillSync_ac0988aba3254290 = function () { return Sg(function (A, g) { A.randomFillSync(g) }, arguments) }, e.wbg.__wbg_require_60cc747a6bc5215a = function () { return Sg(function () { return module.require }, arguments) }, e.wbg.__wbg_set_65595bdd868b3009 = function (A, g, I) { A.set(g, I >>> 0) }, e.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function () { const A = typeof global > "u" ? null : global; return de(A) ? 0 : rg(A) }, e.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function () { const A = typeof globalThis > "u" ? null : globalThis; return de(A) ? 0 : rg(A) }, e.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function () { const A = typeof self > "u" ? null : self; return de(A) ? 0 : rg(A) }, e.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function () { const A = typeof window > "u" ? null : window; return de(A) ? 0 : rg(A) }, e.wbg.__wbg_subarray_aa9065fa9dc5df96 = function (A, g, I) { return A.subarray(g >>> 0, I >>> 0) }, e.wbg.__wbg_versions_c01dfd4722a88165 = function (A) { return A.versions }, e.wbg.__wbindgen_debug_string = function (A, g) { const I = Si(g), t = nA(I, D.__wbindgen_malloc, D.__wbindgen_realloc), i = H; Re().setInt32(A + 4, i, !0), Re().setInt32(A + 0, t, !0) }, e.wbg.__wbindgen_error_new = function (A, g) { return new Error(xA(A, g)) }, e.wbg.__wbindgen_init_externref_table = function () { const A = D.__wbindgen_export_4, g = A.grow(4); A.set(0, void 0), A.set(g + 0, void 0), A.set(g + 1, null), A.set(g + 2, !0), A.set(g + 3, !1) }, e.wbg.__wbindgen_is_function = function (A) { return typeof A == "function" }, e.wbg.__wbindgen_is_object = function (A) { const g = A; return typeof g == "object" && g !== null }, e.wbg.__wbindgen_is_string = function (A) { return typeof A == "string" }, e.wbg.__wbindgen_is_undefined = function (A) { return A === void 0 }, e.wbg.__wbindgen_memory = function () { return D.memory }, e.wbg.__wbindgen_string_get = function (A, g) { const I = g, t = typeof I == "string" ? I : void 0; var i = de(t) ? 0 : nA(t, D.__wbindgen_malloc, D.__wbindgen_realloc), n = H; Re().setInt32(A + 4, n, !0), Re().setInt32(A + 0, i, !0) }, e.wbg.__wbindgen_string_new = function (A, g) { return xA(A, g) }, e.wbg.__wbindgen_throw = function (A, g) { throw new Error(xA(A, g)) }, e } function fm(e, A) { return D = e.exports, iu.__wbindgen_wasm_module = A, Ue = null, Hg = null, D.__wbindgen_start(), D } async function iu(e) { if (D !== void 0) return D; if (typeof e < "u" && (Object.getPrototypeOf(e) === Object.prototype ? { module_or_path: e } = e : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof e > "u") throw new Error; const A = Dm(); (typeof e == "string" || typeof Request == "function" && e instanceof Request || typeof URL == "function" && e instanceof URL) && (e = fetch(e)); const { instance: g, module: I } = await dm(await e, A); return fm(g, I) } const ym = "data:application/wasm;base64,AGFzbQEAAAAB4QM+YAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGAABH9/f39gAX8Bf2AFf39/f38AYAABf2AEf39/fwBgAAJ/f2ACf38Ef39/f2ABbwFvYAAAYAV/f39+fwBgB39/f39/f38AYAV/f39/fwF/YAR/f39/AX9gBH9/f38Ef39/f2ABbwF/YAZ/f39/f38Bf2AAA39/f2ACf38Bb2ACf28AYAABb2ACb28AYANvf38Bb2ACf34AYAd/f39/f39/AX9gBn9/f39/fwBgCH9/f39/f39/BH9/f39gBn9/f39/fwR/f39/YAZ/f39/f38Df39/YAJ/fwJ/f2ACb28Bb2ADb29vAW9gA29vfwBgAX8Bb2AGf39/f35/AGAIf39/f39/fn8AYAJ8fwF/YAd/f39+f39/AX9gBH9/f34AYAJ+fwBgCX9/f39/f35+fgBgAn5/AX9gC39/f39/f39/f39/AX9gA39+fgBgAAF+YAR/fn5/AGAMf39/f39/f39/fH9/BH9/f39gCH9/f39/fH9/BH9/f39gBn9/f39/fwJ/f2AEf39/fwJ/f2ACf3wAYAF/An9/YAV/f35/fwBgBH9+f38AYAV/f3x/fwBgBH98f38AYAV/f31/fwBgBH99f38AAr4JIQN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ABYDd2JnFF9fd2JpbmRnZW5fZXJyb3JfbmV3ABYDd2JnHV9fd2JnX1N0cmluZ184ZjBlYjM5YTRhNGMyZjY2ABcDd2JnHV9fd2JnX2NyeXB0b181NzRlNzhhZDhiMTNiNjVmAAwDd2JnFF9fd2JpbmRnZW5faXNfb2JqZWN0ABMDd2JnHl9fd2JnX3Byb2Nlc3NfZGMwZmJhY2M3YzFjMDZmNwAMA3diZx9fX3diZ192ZXJzaW9uc19jMDFkZmQ0NzIyYTg4MTY1AAwDd2JnG19fd2JnX25vZGVfOTA1ZDNlMjUxZWRmZjhhMgAMA3diZxRfX3diaW5kZ2VuX2lzX3N0cmluZwATA3diZx5fX3diZ19yZXF1aXJlXzYwY2M3NDdhNmJjNTIxNWEAGAN3YmcWX193YmluZGdlbl9pc19mdW5jdGlvbgATA3diZx9fX3diZ19tc0NyeXB0b19hNjFhZWIzNWEyNGMxMzI5AAwDd2JnJV9fd2JnX3JhbmRvbUZpbGxTeW5jX2FjMDk4OGFiYTMyNTQyOTAAGQN3YmcmX193YmdfZ2V0UmFuZG9tVmFsdWVzX2I4ZjVkYmQ1ZjM5OTVhOWUAGQN3YmcgX193YmdfbmV3bm9hcmdzXzEwNWVkNDcxNDc1YWFmNTAAFgN3YmcbX193YmdfY2FsbF82NzJhNGQyMTYzNGQ0YTI0ACIDd2JnFV9fd2JpbmRnZW5fc3RyaW5nX2dldAAXA3diZxdfX3diaW5kZ2VuX2lzX3VuZGVmaW5lZAATA3diZxtfX3diZ19jYWxsXzdjY2NkZDY5ZTA3OTFhZTIAIwN3YmcyX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF9USElTXzU2NTc4YmU3ZTlmODMyYjAACAN3YmcrX193Ymdfc3RhdGljX2FjY2Vzc29yX1NFTEZfMzdjNWQ0MThlNGJmNTgxOQAIA3diZy1fX3diZ19zdGF0aWNfYWNjZXNzb3JfV0lORE9XXzVkZTM3MDQzYTkxYTljNDAACAN3YmctX193Ymdfc3RhdGljX2FjY2Vzc29yX0dMT0JBTF84OGE5MDJkMTNhNTU3ZDA3AAgDd2JnHV9fd2JnX2J1ZmZlcl82MDljYzNlZWU1MWVkMTU4AAwDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2Q5N2U2MzdlYmUxNDVhOWEAGgN3YmcaX193YmdfbmV3X2ExMjAwMmE3ZjkxYzc1YmUADAN3YmcaX193Ymdfc2V0XzY1NTk1YmRkODY4YjMwMDkAJAN3YmckX193YmdfbmV3d2l0aGxlbmd0aF9hMzgxNjM0ZTkwYzI3NmQ0ACUDd2JnH19fd2JnX3N1YmFycmF5X2FhOTA2NWZhOWRjNWRmOTYAGgN3YmcXX193YmluZGdlbl9kZWJ1Z19zdHJpbmcAFwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAYA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA0DngOcAyYOBicACSgCAwMCBgMCBwMCAgIDKQIAAwICBAACAw8AAQIDAxsDKgMCBgMDFAMDDgMCDwIBAQQEAwADGwAJAQEDBwEJAwMPBhQJAgMDAwIJAw8PAgMH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AjAgAyACICNqNgIsIAMgBCAiajYCKCADIBcgIWo2AiQgAyAKICBqNgIgIAMgCyAfajYCHCADIAUgHmo2AhggAyAGIB1qNgIUIAMgDyAaajYCECADIBAgFWo2AgwgAyAMIBRqNgIIIAMgCCARajYCBCADIAcgE2o2AgAgA0G4AWoiCUIANwMAIANBsAFqIgRCADcDACADQagBaiIFQgA3AwAgA0GgAWoiBkIANwMAIANBmAFqIghCADcDACADQZABaiIHQgA3AwAgA0GIAWoiDkIANwMAIANB+ABqIBggGUEGdCICaiIBQThqKQAANwMAIANB8ABqIAFBMGopAAA3AwAgA0HoAGogAUEoaikAADcDACADQeAAaiABQSBqKQAANwMAIANB2ABqIAFBGGopAAA3AwAgA0HQAGogAUEQaikAADcDACADQcgAaiABQQhqKQAANwMAIANCADcDgAEgAyABKQAANwNAIAIgEmohAkFAIQEDQCADQYABaiABaiIKQUBrIAEgA2oiC0FAay0AACADQUBrIAFqIgxBQGstAABzOgAAIApBwQBqIAtBwQBqLQAAIAxBwQBqLQAAczoAACABQQJqIgENAAsgAiADKQOAATcAACACQThqIAkpAwA3AAAgAkEwaiAEKQMANwAAIAJBKGogBSkDADcAACACQSBqIAYpAwA3AAAgAkEYaiAIKQMANwAAIAJBEGogBykDADcAACACQQhqIA4pAwA3AAAgHCAZQQFqIhlHDQALCyAbRQ0AIBIgDUFAcSIBaiEZIAEgGGohGCAAKAI8IQEgACgCOCEWIAAoAjQhDiAAKAIwIQkgACgCLCECIAAoAighBCAAKAIkIRcgACgCICEKIAAoAhwhCyAAKAIYIQUgACgCFCEGIAAoAhAhDyAAKAIMIRAgACgCCCEMIAAoAgQhCCAAKAIAIQdBCiETA0AgBiAIakEHdyAXcyISIAZqQQl3IA5zIhEgByAJakEHdyAPcyIPIAdqQQl3IApzIhQgD2pBDXcgCXMiFSABIAJqQQd3IBBzIhAgAWpBCXcgC3MiCyAQakENdyACcyIKIAtqQRJ3IAFzIgEgBCAFakEHdyAWcyICakEHd3MiCSABakEJd3MiDiAJakENdyACcyIWIA5qQRJ3IAFzIQEgAiACIARqQQl3IAxzIgxqQQ13IAVzIgUgDGpBEncgBHMiBCASakEHdyAKcyICIARqQQl3IBRzIgogAmpBDXcgEnMiFyAKakESdyAEcyEEIBEgESASakENdyAIcyIIakESdyAGcyIGIA9qQQd3IAVzIgUgBmpBCXcgC3MiCyAFakENdyAPcyIPIAtqQRJ3IAZzIQYgECAUIBVqQRJ3IAdzIgdqQQd3IAhzIgggB2pBCXcgDHMiDCAIakENdyAQcyIQIAxqQRJ3IAdzIQcgE0EBayITDQALIAApAiAhKSAAKAIAIRMgACgCBCESIAAoAgghESAAKAIMIRQgACgCECEVIAAoAhQhHCAAKAIYIRogACgCHCEdIAAoAiAhHiAAKAIkIR8gACgCKCEgIAAoAiwhISAAKAIwISIgACgCNCEjIAAoAjghJCAAIAAoAjwgAWo2AnwgACAWICRqNgJ4IAAgDiAjajYCdCAAIAkgImo2AnAgACACICFqNgJsIAAgBCAgajYCaCAAIBcgH2o2AmQgACAKIB5qNgJgIAAgCyAdajYCXCAAIAUgGmo2AlggACAGIBxqNgJUIAAgDyAVajYCUCAAIBAgFGo2AkwgACAMIBFqNgJIIAAgCCASajYCRCAAIAcgE2o2AkAgACApQgF8Iik+AiAgACApQiCIPgIkQQAhASAbQQFHBEAgDUE+cSECA0AgASAZaiIJIAAgAWoiBEFAay0AACABIBhqIgUtAABzOgAAIAlBAWogBEHBAGotAAAgBUEBai0AAHM6AAAgAiABQQJqIgFHDQALCyANQQFxRQ0AIAEgGWogAEFAayABai0AACABIBhqLQAAczoAAAsgJSAbOgAAQQALIANBwAFqJAALnzECEH8kfiMAQeAFayIEJAAgBEHgAGoiBUEAQeAA/AsAIARB2ABqIgcgAUHYAWopAgA3AwAgBEHQAGoiBiABQdABaikCADcDACAEQZADakGg78AAKQMANwMAIARBmANqQajvwAApAwA3AwAgBEGgA2pBsO/AACkDADcDACAEQagDakG478AAKQMANwMAIARBsANqQcDvwAApAwA3AwAgBEG4A2pByO/AACkDADcDACAEIAFByAFqKQIANwNIIAQgASkCwAE3A0AgBEGQ78AAKQMANwOAAyAEQZjvwAApAwA3A4gDIARCADcDyAMgBEIANwPAAyAEQdADaiIIIARBQGsiCUGAAfwKAAAgBEEgOgDQBCAEQfgAaiIKQgA3AwAgBEHwAGoiDUIANwMAIARB6ABqIgtCADcDACAFQgA3AwAgB0IANwMAIAZCADcDACAEQcgAakIANwMAIARCADcDQCAEQYADaiAIIAkQOCAEQegEaiIIIAspAwA3AwAgBEHwBGoiDCANKQMANwMAIARB+ARqIg8gCikDADcDACAELQBAIQ4gBEG3BWogBEHXAGopAAA3AAAgBEGxBWogBEHRAGopAAA3AAAgBEGpBWogBEHJAGopAAA3AAAgBCAFKQMANwPgBCAEIAQpAEE3AKEFIAQgBC0AX0E/cUHAAHI6AL8FIAQgDkH4AXE6AKAFIAQgBEGgBWoQgQIgBEEoaiIOIAgpAwA3AAAgBEEwaiIIIAwpAwA3AAAgBEE4aiIMIA8pAwA3AAAgBCAEKQPgBDcAICAKQbjywAApAwA3AwAgDUGw8sAAKQMANwMAIAtBqPLAACkDADcDACAFQaDywAApAwA3AwAgB0GY8sAAKQMANwMAIAZBkPLAACkDADcDACAEQgA3A4gBIARCADcDgAEgBEGI8sAAKQMANwNIIARBgPLAACkDADcDQCAEQbABaiIFQQBB4AD8CwAgBEGoAWogDCkAADcDACAEQaABaiAIKQAANwMAIARBmAFqIA4pAAA3AwAgBEEgOgCQAiAEIAQpACA3A5ABIARBkAFqIQcCQCADQeAATwRAIAUgAkHgAPwKAAAgBEIANwOIASAEQgE3A4ABIAkgB0EBEKADIAJB4ABqIQogA0HgAGsiBkH/AHEhBSAGQYABTwRAIAQgBCkDgAEiFCAGQQd2Ig2tfCIVNwOAASAEIAQpA4gBIBQgFVatfDcDiAEgCSAKIA0QoAMLIAVFDQEgByAKIAZBgH9xaiAF/AoAAAwBCyADBEAgBEGwAWogAiAD/AoAAAsgA0EgaiEFCyAEIAU6AJACIARBgANqIgUgBEFAa0HgAfwKAAAgBEGoBWoiBkIANwMAIARBsAVqIglCADcDACAEQbgFaiIKQgA3AwAgBEHABWoiDUIANwMAIARByAVqIgtCADcDACAEQdAFaiIIQgA3AwAgBEHYBWoiDEIANwMAIARCADcDoAUgBSAEQdADaiAEQaAFahA4IARBmAVqIAwpAwA3AwAgBEGQBWogCCkDADcDACAEQYgFaiALKQMANwMAIARBgAVqIA0pAwA3AwAgBEH4BGogCikDADcDACAEQfAEaiAJKQMANwMAIARB6ARqIAYpAwA3AwAgBCAEKQOgBTcD4AQgBEGgAmoiBiAEQeAEahDFAiAFIAYQoQMgBEHAAmoiCSAFEHwgB0EAQYEB/AsAIARB+ABqQbjywAApAwA3AwAgBEHwAGpBsPLAACkDADcDACAEQegAakGo8sAAKQMANwMAIARB4ABqQaDywAApAwA3AwAgBEHYAGpBmPLAACkDADcDACAEQdAAakGQ8sAAKQMANwMAIARCADcDiAEgBEIANwOAASAEQYjywAApAwA3A0ggBEGA8sAAKQMANwNAAkAgBC0AkAIiBUHgAE8EQEGAASAFayIGBEAgBSAHaiAJIAb8CgAACyAEQgA3A4gBIARCATcDgAEgBEFAayAHQQEQoAMgBUHgAGsiBUUNASAHIARBwAJqIAZqIAVBgH9xaiAF/AoAAAwBCyAFIAdqIgYgBCkAwAI3AAAgBkEYaiAEQdgCaikAADcAACAGQRBqIARB0AJqKQAANwAAIAZBCGogBEHIAmopAAA3AAAgBUEgaiEFCyAEIAU6AJACIAVB/wBxIQYCQCAFQf8BcUHgAE8EQEGAASAGayIJBEAgBiAHaiABIAn8CgAACyAEIAQpA4ABQgF8IhQ3A4ABIAQgBCkDiAEgFFCtfDcDiAEgBEFAayAHQQEQoAMgBkHgAGsiBUUNASAHIAEgCWogBUGAf3FqIAX8CgAADAELIAYgB2oiBSABKQAANwAAIAVBGGogAUEYaikAADcAACAFQRBqIAFBEGopAAA3AAAgBUEIaiABQQhqKQAANwAAIAZBIGohBQsgBCAFOgCQAgJAAkBBgAEgBUH/AHEiBmsiASADTQRAIAVB/wFxRQ0BIAEEQCAGIAdqIAIgAfwKAAALIAQgBCkDgAFCAXwiFDcDgAEgBCAEKQOIASAUUK18NwOIASAEQUBrIAdBARCgAyABIAJqIQIgAyABayEDDAELIAMEQCAGIAdqIAIgA/wKAAALIAMgBmohAQwBCyADQf8AcSEBIANBgAFPBEAgBCAEKQOAASIUIANBB3YiBa18IhU3A4ABIAQgBCkDiAEgFCAVVq18NwOIASAEQUBrIAIgBRCgAwsgAUUNACAHIAIgA0GAf3FqIAH8CgAACyAEIAE6AJACIARBgANqIgEgBEFAa0HgAfwKAAAgBEGoBWoiB0IANwMAIARBsAVqIgZCADcDACAEQbgFaiIJQgA3AwAgBEHABWoiAkIANwMAIARByAVqIgNCADcDACAEQdAFaiIFQgA3AwAgBEHYBWoiCkIANwMAIARCADcDoAUgASAEQdADaiAEQaAFaiINEDggBEGYBWogCikDADcDACAEQZAFaiAFKQMANwMAIARBiAVqIAMpAwA3AwAgBEGABWogAikDADcDACAEQfgEaiAJKQMANwMAIARB8ARqIAYpAwA3AwAgBEHoBGogBykDADcDACAEIAQpA6AFNwPgBCAEQeACaiIBIARB4ARqIgoQxQIjAEHwAGsiBSQAIAVBKGoiAiABEHQgBUHMAGoiASAEEHQjAEHQAGsiAyQAIAMgASgCACILrSIWIAIoAgAiCK0iF34iG0Kb/NGSAX5C/////wGDIhhC0rHMBH4gAigCBCIMrSIaIBZ+IAEoAgQiD60iHCAXfnwiMnwgGELtp9fnAX4gG3xCHYh8IitCm/zRkgF+Qv////8BgyIZQhSGIAEoAgwiDq0iHyAafiACKAIIIhCtIiAgASgCCCIRrSIdfnwgAigCDCISrSIiIBx+fCABNQIQIhQgF358IAI1AhAiFSAWfnwiM30gCCACKAIUIhNqrSIeIBR+fCALIAEoAhQiCGqtIiQgFX58IBAgAigCHCILaq0iJSARIAEoAhwiEGqtIiF+fCAOIAEoAiAiEWqtIiYgDCACKAIYIg5qrSIjfnwgAigCICICIBJqrSInIAEoAhgiASAPaq0iKH58IBGtIikgDq0iKn4gC60iLCAQrSItfnwgAq0iLiABrSIvfnwiNH0gHSAifiAfICB+fCAUIBp+fCAVIBx+fCAIrSIwIBOtIjF+fSI1IBlCzQJ+IBt9fCAeICR+fCAXIB1+IBogHH58IBYgIH58IjYgGEKW65zvAX58IBlC0rHMBH58IBlC7afX5wF+ICt8Qh2IfCIrQpv80ZIBfkL/////AYMiG0LF+s7vAX58IBwgIH4gGiAdfnwgFyAffnwgFiAifnwiNyAYQsX6zu8BfnwgGUKW65zvAX58IBtC0rHMBH58IBtC7afX5wF+ICt8Qh2IfCIXQpv80ZIBfkL/////AYMiFkKW65zvAX58IBlCxfrO7wF+IBhCzQJ+fCAzfCAbQpbrnO8BfnwgFkLSscwEfnwgFkLtp9fnAX4gF3xCHYh8IhdCm/zRkgF+Qv////8BgyIZQtKxzAR+fCAZQu2n1+cBfiAXfEIdiHwiGkKb/NGSAX5C/////wGDIhdCzQJ+fCAUICB+IB8gIn58IBUgHX58ICogMH4gLyAxfnx9IiAgHiAofiAyfSAjICR+fHwgG0LNAn58IBZCxfrO7wF+fCAZQpbrnO8BfnwgF0LSscwEfnwgF0Ltp9fnAX4gGnxCHYh8IhxCm/zRkgF+Qv////8BgyIaQsX6zu8BfnwgFSAffiAUICJ+fCAtIDF+ICogL358ICwgMH58fSIfICMgKH4gNn0gHiAhfnwgJCAlfnx8IBZCzQJ+fCAZQsX6zu8BfnwgF0KW65zvAX58IBpC0rHMBH58IBpC7afX5wF+IBx8Qh2IfCIdQpv80ZIBfkL/////AYMiHEKW65zvAX58IBhCFIYgN30gFCAVfnwgISAjfnwgJSAofnwgHiAmfnwgJCAnfnwgLCAvfiAqIC1+fCApIDF+fCAuIDB+fCIifSAZQs0CfnwgF0LF+s7vAX58IBpCluuc7wF+fCAcQtKxzAR+fCAcQu2n1+cBfiAdfEIdiHwiHUKb/NGSAX5C/////wGDIhhC0rHMBH58IBhC7afX5wF+IB18Qh2IfCIdp0H/////AXE2AiwgAyAVICh+IDV9IBQgI358IBtCFIZ8ICUgJn58ICEgJ358IC0gLn4gKSAsfnwiG30gGkLNAn58IBxCxfrO7wF+fCAYQpbrnO8BfnwgHUIdiHwiHadB/////wFxNgIwIAMgFSAhfiAUICV+fCAgICkgLn4iHnx9ICYgJ358IBZCFIZ8IBxCzQJ+fCAYQsX6zu8BfnwgHUIdiHwiFqdB/////wFxNgI0IAMgFCAnfiAVICZ+fCAffSAZQhSGfCAYQs0CfnwgFkIdiHwiFKdB/////wFxNgI4IAMgF0IUhiAifCAUQh2IfCIUp0H/////AXE2AjwgAyAaQhSGIDR8IBRCHYh8IhSnQf////8BcTYCQCADIBxCFIYgG3wgFEIdiHwiFKdB/////wFxNgJEIAMgGEIUhiAefCAUQh2IfCIUQh2IPgJMIAMgFKdB/////wFxNgJIIANBCGogA0EsaiIBQcDywAAQZiADIAM1AhgiFEKOkb78AH4gAygCDCICrSIWQtfu/KEBfiADKAIIIgutIhVCga/LywF+fCADKAIQIgitIhdCvf61rAF+fCADKAIUIgytIhpCl7bQ8AF+fCAUQpK6/toAfnwiIX0gCyADKAIcIg9qrSIcQoGvy8sBfnwgAiADKAIgIgtqrSIfQsT3kKIBfnwgCCADKAIkIgJqrSIgQtuYl50DfnwgFkKSuv7aAH4gFUKXttDwAX58IiYgFULm2bGCAX5C/v///wGDIhhC0rHMBH58IBVCkrr+2gB+IhsgGELtp9fnAX58Qh2IfCIjQpv80ZIBfkL/////AYMiGUIUhnwgDCADKAIoIghqrSIdQtTEi9gDfnwgAq0iIkKemuHwAX4gC60iHkLtiBR+fCAIrSIkQr2Ou+cBfnwiJ30gF0LX7vyhAX4gFkKBr8vLAX58IBpCvf61rAF+fCAUQpe20PABfnwgD60iJUKEqcBefnwiKCAbfSAcQo6RvvwAfnwgGULNAn58IBZCl7bQ8AF+IBVCvf61rAF+fCAXQpK6/toAfnwiKSAYQpbrnO8BfnwgGULSscwEfnwgGULtp9fnAX4gI3xCHYh8IiNCm/zRkgF+Qv////8BgyIbQsX6zu8BfnwgFkK9/rWsAX4gFULX7vyhAX58IBdCl7bQ8AF+fCAaQpK6/toAfnwiKiAYQsX6zu8BfnwgGUKW65zvAX58IBtC0rHMBH58IBtC7afX5wF+ICN8Qh2IfCIWQpv80ZIBfkL/////AYMiFUKW65zvAX58ICEgGELNAn58IBlCxfrO7wF+fCAbQpbrnO8BfnwgFULSscwEfnwgFULtp9fnAX4gFnxCHYh8IhZCm/zRkgF+Qv////8BgyIZQtKxzAR+fCAZQu2n1+cBfiAWfEIdiHwiIUKb/NGSAX5C/////wGDIhZCzQJ+fCAaQtfu/KEBfiAXQoGvy8sBfnwgFEK9/rWsAX58ICVCw/HEmH5+fCAeQoSpwF5+fCIjIBxC1MSL2AN+ICZ9IB9CjpG+/AB+fHwgG0LNAn58IBVCxfrO7wF+fCAZQpbrnO8BfnwgFkLSscwEfnwgFkLtp9fnAX4gIXxCHYh8IiFCm/zRkgF+Qv////8BgyIXQsX6zu8BfnwgFELX7vyhAX4gGkKBr8vLAX58ICVC4uWej35+fCAeQsPxxJh+fnwgIkKEqcBefnwiJiAcQtuYl50DfiApfSAfQtTEi9gDfnwgIEKOkb78AH58fCAVQs0CfnwgGULF+s7vAX58IBZCluuc7wF+fCAXQtKxzAR+fCAXQu2n1+cBfiAhfEIdiHwiIUKb/NGSAX5C/////wGDIhpCluuc7wF+fCAYQhSGICp9IBRCga/LywF+fCAcQsT3kKIBfnwgH0LbmJedA358ICBC1MSL2AN+fCAdQo6RvvwAfnwgHkKemuHwAX4gJULtiBR+fCAiQr2Ou+cBfnwgJEL81r8hfnwiHH0gGULNAn58IBZCxfrO7wF+fCAXQpbrnO8BfnwgGkLSscwEfnwgGkLtp9fnAX4gIXxCHYh8Ih5Cm/zRkgF+Qv////8BgyIYQtKxzAR+fCAYQu2n1+cBfiAefEIdiHwiHqdB/////wFxNgIsIAMgFELUxIvYA34gKH0gH0KBr8vLAX58ICBCxPeQogF+fCAdQtuYl50DfnwgJEKemuHwAX4gIkLtiBR+fCIffSAbQhSGfCAXQs0CfnwgGkLF+s7vAX58IBhCluuc7wF+fCAeQh2IfCIbp0H/////AXE2AjAgAyAUQtuYl50DfiAgQoGvy8sBfnwgIyAkQu2IFH4iIHx9IB1CxPeQogF+fCAVQhSGfCAaQs0CfnwgGELF+s7vAX58IBtCHYh8IhWnQf////8BcTYCNCADIBRCxPeQogF+ICZ9IB1Cga/LywF+fCAZQhSGfCAYQs0CfnwgFUIdiHwiFKdB/////wFxNgI4IAMgFkIUhiAcfCAUQh2IfCIUp0H/////AXE2AjwgAyAXQhSGICd8IBRCHYh8IhSnQf////8BcTYCQCADIBpCFIYgH3wgFEIdiHwiFKdB/////wFxNgJEIAMgGEIUhiAgfCAUQh2IfCIUQh2IPgJMIAMgFKdB/////wFxNgJIIAVBBGoiAiABQcDywAAQZiADQdAAaiQAIAogAhB9IAVB8ABqJAAgCSAEQbgCaikAADcDACAGIARBsAJqKQAANwMAIAcgBEGoAmopAAA3AwAgBCAEKQCgAjcDoAUjAEGQAWsiASQAIAFBJGogChB0IAFByABqIA0QdCABIAEoAkggASgCJGoiAkH/////AXE2AmwgASABKAJMIAEoAiggAkEddmpqIgJB/////wFxNgJwIAEgASgCUCABKAIsIAJBHXZqaiICQf////8BcTYCdCABIAEoAlQgASgCMCACQR12amoiAkH/////AXE2AnggASABKAJYIAEoAjQgAkEddmpqIgJB/////wFxNgJ8IAEgASgCXCABKAI4IAJBHXZqaiICQf////8BcTYCgAEgASABKAJgIAEoAjwgAkEddmpqIgJB/////wFxNgKEASABIAEoAmQgASgCQCACQR12amoiAkH/////AXE2AogBIAEgASgCaCABKAJEIAJBHXZqakH/////AXE2AowBIAEgAUHsAGpBwPLAABBmIARBoANqIgIgARB9IAFBkAFqJAAgBEGIA2ogBEHIAmopAAAiFDcDACAEQZADaiAEQdACaikAACIVNwMAIARBmANqIARB2AJqKQAAIhg3AwAgACAEKQDAAiIZNwABIABBCWogFDcAACAAQRFqIBU3AAAgAEEZaiAYNwAAIABBIWogAikDADcAACAAQSlqIARBqANqKQMANwAAIABBMWogBEGwA2opAwA3AAAgAEE5aiAEQbgDaikDADcAACAEIBk3A4ADIABBADoAACAEEMwBIARBADoAICAEQQA6ACEgBEEAOgAiIARBADoAIyAEQQA6ACQgBEEAOgAlIARBADoAJiAEQQA6ACcgBEEAOgAoIARBADoAKSAEQQA6ACogBEEAOgArIARBADoALCAEQQA6AC0gBEEAOgAuIARBADoALyAEQQA6ADAgBEEAOgAxIARBADoAMiAEQQA6ADMgBEEAOgA0IARBADoANSAEQQA6ADYgBEEAOgA3IARBADoAOCAEQQA6ADkgBEEAOgA6IARBADoAOyAEQQA6ADwgBEEAOgA9IARBADoAPiAEQQA6AD8gBEHgBWokAAuGEwIHfwd+IwBBoAJrIgQkACAAvSIMQv////////8HgyEJIAxCAFMEQCABQS06AABBASEGCwJAAn8CfwJAAkACQCAMQjSIp0H/D3EiAkUgCVBxRQRAIAJBAkkgCUIAUnIhAyAJQoCAgICAgIAIhCAJIAIbIglCAoYhCiAJQgGDIQ8gAkG1CGtBzHcgAhsiAkEASARAIARBkAJqQaCIxAAgAiACQYWiU2xBFHYgAkF/R2siAmoiBUEEdCIHaykDACIJIApCAoQiCxDrASAEQYACakGoiMQAIAdrKQMAIgwgCxDrASAEQfABaiAEKQOYAiILIAQpA4ACfCINIAQpA4gCIAsgDVat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Ck8EQCADQQo2ApgBIAMgCRCFAiADQZgBaiADKAIAIAMoAgQQmgIhAgwECyADQZgBaiABQQEQcSADKQOYASITQgNRBEAgACADKAKgATYCBCAAQZWAgIB4NgIADAkLIAAgAykDoAE3AwggAEEANgIEIAAgE6dBAnRB4OXAAGooAgA2AgAMCAsgA0EYNgKYASADQegAaiAJEIUCIANBmAFqIAMoAmggAygCbBCaAiEBIABBlYCAgHg2AgAgACABNgIEDAcLIAMoApwBIQILIARBlYCAgHhGDQAgACAINgIMIAAgBTYCCCAAIAI2AgQgACAENgIADAULIwBBEGsiCCQAAkAgAigCDARAIAIhAQwBCyAIQQhqIAFBDGoQngIgAiAIKAIIIAgoAgwQmgIhASACQRRBBBCHAwsgCEEQaiQAIABBlYCAgHg2AgAgACABNgIEDAQLIANBGDYCmAEgA0FAayAJEIUCIANBmAFqIAMoAkAgAygCRBCaAiEBIABBlYCAgHg2AgAgACABNgIEDAMLIAEEQCAIIAQgAfwKAAALIAAgATYCDCAAIAg2AgggACABNgIEIABBjICAgHg2AgAMAgsgAEGVgICAeDYCACAAIAQ2AgQMAQsgACADKAKgATYCBCAAQZWAgIB4NgIACyADQcABaiQAC68WAhh/A34jAEGQAmsiAyQAAkACQAJAAkACQAJAAkACQAJAIAApA5ABIhtC/////////x+DIhxQBEAgAC0AiAEhBSAALQCJASEEDAELIAApA4ABIR0gA0KACCAceoYiHDcDACACrSAbIB19QgqGIBx8IAAtAIgBIgWtQv8BgyAALQCJASIErUL/AYNCBoZ8fVYNAQsgAEEgaiEWAkAgBEH/AXFBBnQgBWoiBQRAIBYgASACQYAIIAVrIgUgAiAFSRsiChB7IQUgAiAKayICRQ0BIANByAFqIg4gAEHoAGoiBCkDADcDACADQdABaiIQIABB8ABqIgcpAwA3AwAgA0HYAWoiESAAQfgAaiIJKQMANwMAIANBiAFqIhIgBUEIaikDADcDACADQZABaiITIAVBEGopAwA3AwAgA0GYAWoiFCAFQRhqKQMANwMAIANBoAFqIhUgBUEgaikDADcDACADQagBaiIXIAVBKGopAwA3AwAgA0GwAWoiGCAFQTBqKQMANwMAIANBuAFqIhkgBUE4aikDADcDACADIAApA2A3A8ABIAMgBSkDADcDgAEgAC0AigEhBiAALQCJASEMIAMgAC0AiAEiCDoA6AEgAyAAKQOAASIbNwPgASADIAYgDEVyQQJyIgY6AOkBIANBKGoiDCAJKQIANwMAIANBIGoiCSAHKQIANwMAIANBGGoiDyAEKQIANwMAIAMgACkCYDcDECADQRBqIANBgAFqIhogCCAbIAYQIiAMKAIAIQcgCSgCACEJIA8oAgAhBiADKAIsIQwgAygCJCEIIAMoAhwhDyADKAIUIQsgAygCECENIAAgGxBFIAAoApgBIgRBN08NAyAAIARBAWo2ApgBIAAgBEEFdGoiBCAMNgK4ASAEIAc2ArQBIAQgCDYCsAEgBCAJNgKsASAEIA82AqgBIAQgBjYCpAEgBCALNgKgASAEIA02ApwBIBJCADcDACATQgA3AwAgFEIANwMAIBVCADcDACAXQgA3AwAgGEIANwMAIBlCADcDACAOIABBCGopAwA3AwAgECAAQRBqKQMANwMAIBEgAEEYaikDADcDACADQgA3A4ABIAMgACkDADcDwAEgACkDgAEhGyAFIBpB4AD8CgAAIABBADsBiAEgACAbQgF8NwOAASABIApqIQELIAJBgQhPBEAgAEGcAWohDyAAKQOAASEbIANB0ABqIQwgA0HAAWohCSADQaABaiEKA0AgG0IKhiEcQX8gAkEBdmd2QQFqIQQDQCAEIgVBAXYhBCAcIAVBAWutg0IAUg0ACyAFQQp2rSEcAkAgBUGBCE8EQCACIAVJDQcgA0GAAWohByAALQCKASELIwBB4ABrIgQkACAEQThqIg1CADcDACAEQTBqIg5CADcDACAEQShqIhBCADcDACAEQSBqIhFCADcDACAEQRhqIhJCADcDACAEQRBqIhNCADcDACAEQQhqIhRCADcDACAEQgA3AwAgASAFIAAgGyALIARBwAAQNSEIIARB2ABqQgA3AwAgBEHQAGpCADcDACAEQcgAakIANwMAIARCADcDQAJAAkACQAJAIAhBA08EQANAIAhBBXQiBkHBAE8NAiAEIAYgACALIARBQGsiFUEgEGkiCEEFdCIGQcEATw0DIAZBIU8NBCAGBEAgBCAVIAb8CgAACyAIQQJLDQALCyAHIAQpAwA3AAAgB0E4aiANKQMANwAAIAdBMGogDikDADcAACAHQShqIBApAwA3AAAgB0EgaiARKQMANwAAIAdBGGogEikDADcAACAHQRBqIBMpAwA3AAAgB0EIaiAUKQMANwAAIARB4ABqJAAMAwsgBkHAAEGc6cAAEIsDAAsgBkHAAEGs6cAAEIsDAAsgBkEgQbzpwAAQiwMACyAAIAApA4ABEEUgACgCmAEiBEE3Tw0IIAAgBEEBajYCmAEgDyAEQQV0aiIEIAMpAIABNwAAIARBGGogA0GYAWopAAA3AAAgBEEQaiADQZABaikAADcAACAEQQhqIANBiAFqKQAANwAAIAAgACkDgAEgHEIBiHwQRSAAKAKYASIEQTdPDQkgACAEQQFqNgKYASAPIARBBXRqIgQgCikAADcAACAEQRhqIApBGGopAAA3AAAgBEEQaiAKQRBqKQAANwAAIARBCGogCkEIaikAADcAAAwBCyADQYgBakIANwMAIANBkAFqQgA3AwAgA0GYAWpCADcDACAKQgA3AwAgA0GoAWpCADcDACADQbABakIANwMAIANBuAFqQgA3AwAgCSAAKQMANwMAIAlBCGoiByAAQQhqKQMANwMAIAlBEGoiBiAAQRBqKQMANwMAIAlBGGoiCCAAQRhqKQMANwMAIANCADcDgAEgA0EAOwHoASADIBs3A+ABIAMgAC0AigE6AOoBIANBgAFqIAEgBRB7IQQgDCAJKQMANwMAIAxBCGogBykDADcDACAMQRBqIAYpAwA3AwAgDEEYaiAIKQMANwMAIANBGGogBEEIaikDADcDACADQSBqIARBEGopAwA3AwAgA0EoaiAEQRhqKQMANwMAIANBMGogBEEgaikDADcDACADQThqIARBKGopAwA3AwAgA0FAayAEQTBqKQMANwMAIANByABqIARBOGopAwA3AwAgAyAEKQMANwMQIAMtAOoBIQQgAy0A6QEhCyADIAMtAOgBIg06AHggAyADKQPgASIbNwNwIAMgBCALRXJBAnIiBDoAeSADQYgCaiILIAgpAgA3AwAgA0GAAmoiCCAGKQIANwMAIANB+AFqIg4gBykCADcDACADIAkpAgA3A/ABIANB8AFqIANBEGogDSAbIAQQIiALKAIAIQcgCCgCACEGIA4oAgAhCCADKAKMAiELIAMoAoQCIQ0gAygC/AEhDiADKAL0ASEQIAMoAvABIREgACAAKQOAARBFIAAoApgBIgRBN08NCSAAIARBAWo2ApgBIA8gBEEFdGoiBCALNgIcIAQgBzYCGCAEIA02AhQgBCAGNgIQIAQgDjYCDCAEIAg2AgggBCAQNgIEIAQgETYCAAsgACAAKQOAASAcfCIbNwOAASACIAVJDQkgASAFaiEBIAIgBWsiAkGACEsNAAsLIAJFDQAgFiABIAIQexogACAAKQOAARBFCyADQZACaiQADwsgAyAbQgqGNwPwASADIAI2AgwgA0EENgIUIANBtOrAADYCECADQgM3AhwgAyADQQxqrUKAgICAwAiENwOQASADIAOtQoCAgICwCoQ3A4gBIAMgA0HwAWqtQoCAgICwCoQ3A4ABIAMgA0GAAWo2AhggA0EQakHU6sAAEMcCAAsgAyAMNgKcASADIAc2ApgBIAMgCDYClAEgAyAJNgKQASADIA82AowBIAMgBjYCiAEgAyALNgKEASADIA02AoABQcjswABBKyADQYABakGE7cAAQezpwAAQ7gEACyAFIAJB5OrAABCLAwALIANBKGogA0GYAWopAAA3AwAgA0EgaiADQZABaikAADcDACADQRhqIANBiAFqKQAANwMAIAMgAykAgAE3AxAMAwsgA0EoaiAKQRhqKQAANwMAIANBIGogCkEQaikAADcDACADQRhqIApBCGopAAA3AwAgAyAKKQAANwMQDAILIAMgCzYCjAIgAyAHNgKIAiADIA02AoQCIAMgBjYCgAIgAyAONgL8ASADIAg2AvgBIAMgEDYC9AEgAyARNgLwAUHI7MAAQSsgA0HwAWpBhO3AAEHs6cAAEO4BAAsgBSACQfTqwAAQigMAC0HI7MAAQSsgA0EQakGE7cAAQezpwAAQ7gEAC6waAhB/A34jAEGwEGsiAyQAIANBADYCECADQQA2AghBAkEBEPoCIgQEQCAEQencATsAACADQQI2AqgPIAMgBDYCpA8gA0ECNgKgDyADQSBqIgRBBHIgARD0ASADQQM6ACAgA0G4D2ogA0EIaiADQaAPaiAEEHACQAJAAkACQCADLQC4Dw4HAwMDAQIAAwALIAMoArwPIgQEfyADIAMoAsAPIgY2AjwgAyAENgI4IANBADYCNCADIAY2AiwgAyAENgIoIANBADYCJCADKALEDyEFQQEFQQALIQQgAyAFNgJAIAMgBDYCMCADIAQ2AiAgA0EgahA7DAILIAMoArwPIgRFDQEgAygCwA8gBEEBEIcDDAELIANBuA9qQQRyELoBCyADQQA2AhwgA0EANgIUQQlBARD6AiIEBEAgBEEIakGc0MAALQAAOgAAIARBlNDAACkAADcAACADQQk2AqgPIAMgBDYCpA8gA0EJNgKgDyADQSBqIgRBBHIgAUEMahD0ASADQQM6ACAgA0G4D2ogA0EUaiADQaAPaiAEEHACQAJAAkACQCADLQC4Dw4HAwMDAQIAAwALIAMCfyADKAK8DyIBRQRAQQAhBEEADAELIAMgAygCwA8iBDYCPCADIAE2AjggA0EANgI0IAMgBDYCLCADIAE2AiggA0EANgIkQQEhBCADKALEDws2AkAgAyAENgIwIAMgBDYCICADQSBqEDsMAgsgAygCvA8iAUUNASADKALADyABQQEQhwMMAQsgA0G4D2pBBHIQugELQQdBARD6AiIEBEBBACEBIARBA2pBs9DAACgAADYAACAEQbDQwAAoAAA2AAAgA0EHNgKoDyADIAQ2AqQPIANBBzYCoA8gAyACrTcDMCADQgA3AyggA0ECOgAgIANBuA9qIANBFGogA0GgD2ogA0EgahBwAkACQAJAAkAgAy0AuA8OBwMDAwECAAMAC0EAIQQgAygCvA8iAgRAIAMgAygCwA8iATYCPCADIAI2AjggA0EANgI0IAMgATYCLCADIAI2AiggA0EANgIkIAMoAsQPIQRBASEBCyADIAQ2AkAgAyABNgIwIAMgATYCICADQSBqEDsMAgsgAygCvA8iAUUNASADKALADyABQQEQhwMMAQsgA0G4D2pBBHIQugELQQJBARD6AiIBBEAgAUH08AE7AAAgA0ECNgKoDyADIAE2AqQPIANBAjYCoA8gA0EsaiADQRxqKAIANgIAIAMgAykCFDcCJCADQQU6ACAgA0G4D2ogA0EIaiADQaAPaiADQSBqEHACQAJAAkACQCADLQC4Dw4HAwMDAQIAAwALIAMCfyADKAK8DyIBRQRAQQAhBEEADAELIAMgAygCwA8iAjYCPCADIAE2AjggA0EANgI0IAMgAjYCLCADIAE2AiggA0EANgIkQQEhBCADKALEDws2AkAgAyAENgIwIAMgBDYCICADQSBqEDsMAgsgAygCvA8iAUUNASADKALADyABQQEQhwMMAQsgA0G4D2pBBHIQugELIAMoAgghCSADKAIMIQwgAygCECELQYABQQEQ+gIiAQRAIAMgATYCJCADQYABNgIgIAMgA0EgajYCoA8gAUH7ADoAACADQQE2AigCQAJAAn8CQAJAAkACQCALRQRAIAFB/QA6AAEgA0ECNgIoDAELIANBgAI2ArgPIAMgA0GgD2oiATYCvA8gCQR/QQAhBCAMIQYgCSEBIAshCgNAAkACQCAERQRAQQAhByAGRQ0BIAYiBEEHcSICBEADQCAEQQFrIQQgASgCmAMhASACQQFrIgINAAsLIAZBCEkNAQNAIAEoApgDKAKYAygCmAMoApgDKAKYAygCmAMoApgDKAKYAyEBIARBCGsiBA0ACwwBCyABIQcMAQsgASEEQQAhBgsCQCAELwGSAyAGSwRAIAQhASAGIQgMAQsDQCAEKAKIAiIBRQ0KIAdBAWohByAELwGQAyEIIAggASIELwGSA08NAAsLIAhBAWohBgJAIAdFBEAgASEEDAELIAEgBkECdGpBmANqIQICQCAHQQdxIgZFBEAgByEFDAELIAchBQNAIAVBAWshBSACKAIAIgRBmANqIQIgBkEBayIGDQALC0EAIQYgB0EISQ0AA0AgAigCACgCmAMoApgDKAKYAygCmAMoApgDKAKYAygCmAMiBEGYA2ohAiAFQQhrIgUNAAsLAn8gASAIQQxsakGMAmohAiABIAhBGGxqIQ0jAEEQayIBJAAgA0G4D2oiCC0AAEEBRwRAIAIoAgghDiACKAIEIQ8gCCgCBCEHIAgtAAFBAUcEQCAHKAIAIgIoAgAgAigCCCIFRgRAIAIgBUEBEKoBIAIoAgghBQsgAiAFQQFqNgIIIAIoAgQgBWpBLDoAAAsgCEECOgABIAEgByAPIA4QZAJ/IAEtAABBBEcEQCABIAEpAwA3AwggAUEIahCtAgwBCyAHKAIAIgIoAgAgAigCCCIFRgRAIAIgBUEBEKoBIAIoAgghBQsgAiAFQQFqNgIIIAIoAgQgBWpBOjoAACANIAcQNwsgAUEQaiQADAELQaDiwABBKEHI4sAAEKACAAsiAQ0DQQAhASAKQQFrIgoNAAsgAygCuA8iAUEBcQ0GIAFBgP4DcUUNASADKAK8DwUgAQsoAgAiASgCACABKAIIIgJGBH8gASACQQEQqgEgASgCCAUgAgsgASgCBGpB/QA6AAAgASABKAIIQQFqNgIICyADKAIkIQEgAygCICIKQYCAgIB4Rg0BIAMoAighBiADQfAPakIANwMAIANB6A9qQgA3AwAgA0HgD2pCADcDACADQdgPakIANwMAIANB0A9qQgA3AwAgA0HID2pCADcDACADQcAPakIANwMAIANBgBBqQcDQwAApAgAiEzcDACADQYgQakHI0MAAKQIAIhQ3AwAgA0GQEGpB0NDAACkCACIVNwMAIANBKGogEzcDACADQTBqIBQ3AwAgA0E4aiAVNwMAIANCADcDuA8gA0G40MAAKQIAIhM3A/gPIAMgEzcDICADQUBrIANBuA9qIgJB4AD8CgAAIANBpwFqQQA2AAAgA0IANwOgASADQQA2ArgBIANCADcDsAEgA0EgaiIEIAEgBhApIANBsA9qIg1CADcDACADQagPaiIOQgA3AwAgA0IANwOgDyMAQSBrIgYkAAJAIAQpA5ABUARAIAIgBBAuIAJBADoAcCAGQSBqJAAMAQsgBkIANwIUIAZCgYCAgMAANwIMIAZB2OvAADYCCCAEQZABakGA6MAAIAZBCGpB8OvAABCuAgALIANBoA9qIQZBGCEFIwBBQGoiByQAAkACQCACLQBwBEAgByACQUBrIAIgAi0AaCACKQNgIAItAGlBCHIQISACLQBwIgRBwABLDQFBGEHAACAEayIFIAVBGE8bIggEQCAGIAQgB2ogCPwKAAALIAIgBCAIaiIEOgBwIARB/wFxQcAARgRAIAJBADoAcCACIAIpA2BCAXw3A2ALQRggCGshBSAGIAhqIQYLIAVBP00NASACQUBrIQ9BACAFQUBxIhBrIQggAi0AaUEIciERIAItAGghEiACKQNgIhQhEyAGIQQDQCAHIA8gAiASIBMgERAhIARBOGogB0E4aikAADcAACAEQTBqIAdBMGopAAA3AAAgBEEoaiAHQShqKQAANwAAIARBIGogB0EgaikAADcAACAEQRhqIAdBGGopAAA3AAAgBEEQaiAHQRBqKQAANwAAIARBCGogB0EIaikAADcAACAEIAcpAAA3AAAgE0IBfCETIARBQGshBCAIQUBrIggNAAsgAiAUIAVBBnatfDcDYCAGIBBqIQYgBUE/cSEFDAELIARBwABBgOzAABCKAwALAkAgBUUNACAHIAJBQGsgAiACLQBoIAIpA2AgAi0AaUEIchAhIAItAHAiBEHAAE0EQEHAACAEayIIIAUgBSAISxsiBQRAIAYgBCAHaiAF/AoAAAsgAiACLQBwIAVqIgQ6AHAgBEH/AXFBwABHDQEgAkEAOgBwIAIgAikDYEIBfDcDYAwBCyAEQcAAQYDswAAQigMACyAHQUBrJAAgAEEQaiANKQMANwAAIABBCGogDikDADcAACAAIAMpA6APNwAAIAoEQCABIApBARCHAwsgCQ0CQQAhC0EADAMLIAMoAiAiAEUNACADKAIkIABBARCHAwsgAyABNgIgQejQwABBKyADQSBqQdjQwABBlNHAABDuAQALIAMgDDYCPCADIAk2AjggA0EANgI0IAMgDDYCLCADIAk2AiggA0EANgIkQQELIQAgAyALNgJAIAMgADYCMCADIAA2AiAgA0EgahA7IANBsBBqJAAPC0HMz8AAQShB9M/AABCgAgALQaTOwAAQjQMAC0EBQYABQZTOwAAQ4gIAC0EBQQJBvM/AABDiAgALQQFBB0G8z8AAEOICAAtBAUEJQbzPwAAQ4gIAC0EBQQJBvM/AABDiAgAL1A4CKH8IfiMAQfACayICJAAgAkGgAmoiAyABEFIgAiACKQPoAiACKQPgAiACKQPYAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrQhqIfCIvQhmIfCIwQhqIfCItQhmIQhN+IAIpA6ACIi5C////H4N8IjGnQf///x9xIgc2AgggAiACKQOoAiAuQhqIfCIuQv///w+DIDFCGoh8pyIINgIMIAIgLEL///8PgyAqQv///x+DIAIpA7gCIAIpA7ACIC5CGYh8IipCGoh8IixCGYh8Ii5CGoh8pyIJNgIcIAIgLqdB////H3EiBDYCGCACICynQf///w9xIgo2AhQgAiAvp0H///8PcSILNgIkIAIgLadB////D3EiDDYCLCACICqnQf///x9xIg02AhAgAiArp0H///8fcSIFNgIgIAIgMKdB////H3EiBjYCKCADIAFBKGoQUiACIAIpA+gCIAIpA+ACIAIpA9gCIAIpA9ACIAIpA8gCIAIpA8ACIipCGoh8IixCGYh8IitCGoh8Ii9CGYh8IjBCGoh8Ii1CGYhCE34gAikDoAIiLkL///8fg3wiMadB////H3EiDjYCMCACIAIpA6gCIC5CGoh8Ii5C////D4MgMUIaiHynIg82AjQgAiAsQv///w+DICpC////H4MgAikDuAIgAikDsAIgLkIZiHwiKkIaiHwiLEIZiHwiLkIaiHynIhA2AkQgAiAup0H///8fcSIRNgJAIAIgLKdB////D3EiEjYCPCACIC+nQf///w9xIhM2AkwgAiAtp0H///8PcSIUNgJUIAIgKqdB////H3EiFTYCOCACICunQf///x9xIhY2AkggAiAwp0H///8fcSIXNgJQIAMgAUHQAGoQUiACIAIpA9ACQgGGIAIpA8gCQgGGIAIpA8ACQgGGIipCGoh8IixCGYh8IiunQf///x9xNgJwIAIgAikDsAJCAYYgAikDqAJCAYYgAikDoAJCAYYiL0IaiHwiMEIZiHwiLadB////H3E2AmAgAiACKQPYAkIBhiArQhqIfCIrp0H///8PcTYCdCACIAIpA7gCQgGGIC1CGoh8Ii2nQf///w9xNgJkIAIgAikD4AJCAYYgK0IZiHwiK6dB////H3E2AnggAiAsQv///w+DICpC/v//H4MgLUIZiHwiKkIaiHw+AmwgAiAqp0H///8fcTYCaCACIAIpA+gCQgGGICtCGoh8IiqnQf///w9xNgJ8IAIgMEL///8PgyAqQhmIQhN+IC9C/v//H4N8IipCGoh8PgJcIAIgKqdB////H3E2AlggASgCKCEYIAEoAgAhGSABKAIsIRogASgCBCEbIAEoAjAhHCABKAIIIR0gASgCNCEeIAEoAgwhHyABKAI4ISAgASgCECEhIAEoAjwhIiABKAIUISMgASgCQCEkIAEoAhghJSABKAJEISYgASgCHCEnIAEoAkghKCABKAIgISkgAiABKAJMIAEoAiRqNgKkASACICggKWo2AqABIAIgJiAnajYCnAEgAiAkICVqNgKYASACICIgI2o2ApQBIAIgICAhajYCkAEgAiAeIB9qNgKMASACIBwgHWo2AogBIAIgGiAbajYChAEgAiAYIBlqNgKAASADIAJBgAFqEFIgAiACKQPQAiACKQPIAiACKQPAAiIqQhqIfCIsQhmIfCIrp0H///8fcTYCwAEgAiACKQOwAiACKQOoAiACKQOgAiIvQhqIfCIwQhmIfCItp0H///8fcTYCsAEgAiACKQPYAiArQhqIfCIrp0H///8PcTYCxAEg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0PfEACkDADcDMCADQcj3xAApAwA3AyggA0HA98QAKQMANwMgIANBuPfEACkDADcDGCASKAIAIgJBBGooAgAgAkEIaigCACADEGwgCgJ+IAMtADhFBEAgAykDEAwBCyADKQMYIAMpAwiFIhNCIIgiFyADKQMQIAMpAwCFIhVCIIgiFn4gE0L/////D4MiEyAVQv////8PgyIVfoUgEyAWfiAVIBd+hUIgiIULpyIQcSIHIQIgBiAHaikAAEKAgYKEiJCgwIB/gyITUARAQQghCwNAIAIgC2ohAiALQQhqIQsgBiACIApxIgJqKQAAQoCBgoSIkKDAgH+DIhNQDQALCyAGIBN6p0EDdiACaiAKcSICaiwAAEEATgRAIAYpAwBCgIGChIiQoMCAf4N6p0EDdiECCyACIAdrIAUgB2tzIApxQQhPBEAgAiAGaiIHLQAAIAcgEEEZdiIHOgAAIAkgAkEIayAKcWogBzoAACAGIAJBA3RrQQhrIQJB/wFGDQIgAigAACEHIAIgBCgAADYAACAEIAc2AAAgBCgABCEHIAQgAigABDYABCACIAc2AAQMAQsLIA8gEEEZdiICOgAAIAkgBUEIayAKcWogAjoAAAwBCyAPQf8BOgAAIAkgBUEIayAKcWpB/wE6AAAgAiAEKQAANwAACyAIIAggDEkiAmohBCACDQALCyABIA4gDWs2AghBgYCAgHghCQwBCwwBCyAAIA42AgQgACAJNgIAIANBQGskAA8LIANBADYCECADQQE2AgQgA0G8x8AANgIAIANCBDcCCCADQcTHwAAQxwIAC8oMAhJ/BH4jAEHQAWsiAiQAAkAgASgCmAEiBEUEQCAAIAEpA2A3A0AgACABKQMgNwMAIABByABqIAFB6ABqKQMANwMAIABB0ABqIAFB8ABqKQMANwMAIABB2ABqIAFB+ABqKQMANwMAIABBCGogAUEoaikDADcDACAAQRBqIAFBMGopAwA3AwAgAEEYaiABQThqKQMANwMAIABBIGogAUFAaykDADcDACAAQShqIAFByABqKQMANwMAIABBMGogAUHQAGopAwA3AwAgAEE4aiABQdgAaikDADcDACABLQCKASEEIAEtAIkBIQMgACABLQCIAToAaCAAIAEpA4ABNwNgIAAgBCADRXJBAnI6AGkMAQsCQAJAAkACQCABLQCIASIHIAEtAIkBIgZBBnRyBEAgAkG4AWogAUHoAGopAwA3AwAgAkHAAWogAUHwAGopAwA3AwAgAkHIAWogAUH4AGopAwA3AwAgAkH4AGogAUEoaikDADcDACACQYABaiABQTBqKQMANwMAIAJBiAFqIAFBOGopAwA3AwAgAkGQAWogAUFAaykDADcDACACQZgBaiABQcgAaikDADcDACACQaABaiABQdAAaikDADcDACACQagBaiABQdgAaikDADcDACACIAEpA2A3A7ABIAIgASkDIDcDcCABLQCKASEDIAEpA4ABIRQgAiACQfAAakHgAPwKAAAgAiADIAZFckECciIFOgBpIAIgBzoAaCACIBQ3A2AgA0EEciEGIAQhAwwBCyAEQQJrIQMgBEEBRg0DIAEtAIoBIQggAkEYaiIHIAFBnAFqIgUgA0EFdGoiBkEYaikAADcDACACQRBqIgkgBkEQaikAADcDACACQQhqIgogBkEIaikAADcDACACQSBqIgsgBSAEQQV0akEgayIFKQAANwMAIAJBKGoiDCAFQQhqKQAANwMAIAJBMGoiDSAFQRBqKQAANwMAIAJBOGoiDiAFQRhqKQAANwMAIAIgBikAADcDACACQcgBaiABQRhqKQMANwMAIAJBwAFqIAFBEGopAwA3AwAgAkG4AWogAUEIaikDADcDACACIAEpAwA3A7ABIAJBqAFqIA4pAwA3AwAgAkGgAWogDSkDADcDACACQZgBaiAMKQMANwMAIAJBkAFqIAspAwA3AwAgAkGIAWogBykDADcDACACQYABaiAJKQMANwMAIAJB+ABqIAopAwA3AwAgAiACKQMANwNwIAIgAkHwAGpB4AD8CgAAIAIgCEEEciIGOgBpQcAAIQcgAkHAADoAaCACQgA3A2AgBiEFIANFDQELIANBAWsiCCAETw0BIAJBiAFqIgkgAkFAayIEQRhqIgopAgA3AwAgAkGAAWoiCyAEQRBqIgwpAgA3AwAgAkH4AGoiDSAEQQhqIg4pAgA3AwAgAiAEKQIANwNwIAJB8ABqIAIgByAUIAUQIiANKQMAIRQgCykDACEVIAkpAwAhFiACKQNwIRcgAkEIaiIHIAFBnAFqIAhBBXRqIgVBCGopAgA3AwAgAkEQaiIPIAVBEGopAgA3AwAgAkEYaiIQIAVBGGopAgA3AwAgBCABKQMA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Qf///w9xNgIkIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIEIAIgCKdB////H3E2AgAgBSACEFIgAiACKQOABiACKQP4BSACKQPwBSIIQhqIfCILQhmIfCIJp0H///8fcTYCwAUgAiACKQPgBSACKQPYBSACKQPQBSIMQhqIfCINQhmIfCIKp0H///8fcTYCsAUgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCxAUgAiACKQPoBSAKQhqIfCIKp0H///8PcTYCtAUgAiACKQOQBiAJQhmIfCIJp0H///8fcTYCyAUgAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+ArwFIAIgCKdB////H3E2ArgFIAIgAikDmAYgCUIaiHwiCKdB////D3E2AswFIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgKsBSACIAinQf///x9xNgKoBSAFIAJBqAVqIgYQUiACIAIpA4AGIAIpA/gFIAIpA/AFIghCGoh8IgtCGYh8IgmnQf///x9xNgJAIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AjAgAiACKQOIBiAJQhqIfCIJp0H///8PcTYCRCACIAIpA+gFIApCGoh8IgqnQf///w9xNgI0IAIgAikDkAYgCUIZiHwiCadB////H3E2AkggAiALQv///w+DIAhC////H4MgCkIZiHwiCEIaiHw+AjwgAiAIp0H///8fcTYCOCACIAIpA5gGIAlCGoh8IginQf///w9xNgJMIAIgDUL///8PgyAIQhmIQhN+IAxC////H4N8IghCGoh8PgIsIAIgCKdB////H3E2AiggAkHQAGoiBCABIAJBKGoQNCACQfgAaiIBIAIgBBA0IAUgARBSIAIgAikDgAYgAikD+AUgAikD8AUiCEIaiHwiC0IZiHwiCadB////H3E2ArgBIAIgAikD4AUgAikD2AUgAikD0AUiDEIaiHwiDUIZiHwiCqdB////H3E2AqgBIAIgAikDiAYgCUIaiHwiCadB////D3E2ArwBIAIgAikD6AUgCkIaiHwiCqdB////D3E2AqwBIAIgAikDkAYgCUIZiHwiCadB////H3E2AsABIAIgC0L///8PgyAIQv///x+DIApCGYh8IghC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AX4gFX0gFELuyvX/AX58IAxCFIZ8IAtCzQJ+fCAJQh2IfCIHp0H/////AXE2AlggAiAIQhSGIBB8IAdCHYh8IgenQf////8BcTYCXCACIA1CFIYgHHwgB0IdiHwiB6dB/////wFxNgJgIAIgDkIUhiARfCAHQh2IfCIHp0H/////AXE2AmQgAiALQhSGIAp8IAdCHYh8IgdCHYg+AmwgAiAHp0H/////AXE2AmggAkEoaiIBIAJBzABqQZz0wAAQZiAAIAEQfSACQfAAaiQAC6UNAgx/BH4jAEHABmsiAiQAIAJBCGohBSMAQeAAayIDJAAgA0HYAGpCADcDACADQdAAakIANwMAIANByABqQgA3AwAgA0FAa0IANwMAIANBOGpCADcDACADQTBqQgA3AwAgA0EoakIANwMAIANCADcDIANAIANBIGogBGoiBkEBaiABLQAAIgdBBHY6AAAgBiAHQQ9xOgAAIAZBA2ogAUEBai0AACIHQQR2OgAAIAZBAmogB0EPcToAACABQQJqIQEgBEEEaiIEQcAARw0AC0EAIQEgAy0AICEEA0AgA0EgaiABaiIGIAQgBEEIaiIHQfABcWs6AAAgBkEBaiIEIAQtAAAgB8BBBHVqIgc6AAAgAUE+RwRAIAQgByAHQQhqIgRB8AFxazoAACAGQQJqIgYgBi0AACAEwEEEdWoiBDoAACABQQJqIQEMAQsLIAUgAykDIDcAACAFQThqIANB2ABqKQMANwAAIAVBMGogA0HQAGopAwA3AAAgBUEoaiADQcgAaikDADcAACAFQSBqIANBQGspAwA3AAAgBUEYaiADQThqKQMANwAAIAVBEGogA0EwaikDADcAACAFQQhqIANBKGopAwA3AAAgA0HgAGokACACQegAakIANwMAIAJB4ABqQgA3AwAgAkHYAGpCADcDACACQdAAakIANwMAQQAhASACQfgAakHw9MAAKQIAIg43AwAgAkGAAWpB+PTAACkCACIPNwMAIAJBiAFqQYD1wAApAgAiEDcDACACQZABakGI9cAAKQIAIhE3AwAgAkGgAWogDjcDACACQagBaiAPNwMAIAJBsAFqIBA3AwAgAkG4AWogETcDACACQgA3A0ggAkHo9MAAKQIAIg43A3AgAiAONwOYASACQeABakIANwMAIAJB2AFqQgA3AwAgAkHQAWpCADcDACACQcgBakIANwMAIAJCADcDwAEgAkGABGohCiACQdgDaiEJIAJBsANqIQsgAkHwBWohBCACQcgFaiEGIAJBmAZqIQcgAkGYAWohAyACQfAAaiEFA0ACQAJAIAFBwABHBEAgAUEBcQ0BDAILIAJB8ARqIAVBIGopAgA3AwAgAkHoBGogBUEYaikCADcDACACQeAEaiAFQRBqKQIANwMAIAJB2ARqIAVBCGopAgA3AwAgAkGABWogA0EIaikCADcDACACQYgFaiADQRBqKQIANwMAIAJBkAVqIANBGGopAgA3AwAgAkGYBWogA0EgaikCADcDACACIAUpAgA3A9AEIAIgAykCADcD+AQgAkHIBGogAkHoAGopAwA3AwAgAkHABGogAkHgAGopAwA3AwAgAkG4BGogAkHYAGopAwA3AwAgAkGwBGogAkHQAGopAwA3AwAgAiACKQNINwOoBCACQaAFaiIDIAJBqARqECtBACIBRQRAIAJBiANqIANBoAH8CgAACyACQaAFaiIDIAJBiANqIgkgAkGABGoiBRA0IAJByAVqIgQgAkGwA2oiCiACQdgDaiIGEDQgAkHwBWoiByAGIAUQNCACQagEaiIIIANB+AD8CgAAIAMgCBArIAkgA0GgAfwKAAAgAyAJIAUQNCAEIAogBhA0IAcgBiAFEDQgCCADQfgA/AoAACADIAgQKyAJIANBoAH8CgAAIAMgCSAFEDQgBCAKIAYQNCAHIAYgBRA0IAggA0H4APwKAAAgAyAIECsgAkHoAWoiCSADIAJBmAZqIggQNCACQZACaiAEIAcQNCACQbgCaiAHIAgQNCACQeACaiADIAQQNCACQcgAaiAJQaAB/AoAAANAAkACQCABQcAARwRAIAFBAXFFDQEMAgsgACACQcgAakGgAfwKAAAgAkHABmokAA8LIAFBAXYhAyABQcAASQRAIAJB6AFqIgkgA0HAB2xBuLLBAGogAkEIaiABai0AABBhIAJBoAVqIgMgAkHIAGoiCyAJEEQgAkGIA2oiCSADIAgQNCAKIAQgBxA0IAYgByAIEDQgBSADIAQQNCALIAlBoAH8CgAAIAFBAWohAQwCCyADQSBBuPXAABD2AQALIAFBAWohAQwACwALIAFBAXYhCCABQcAASQRAIAJB6AFqIgwgCEHAB2xBuLLBAGogAkEIaiAB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/wNxQQF0QcbgwABqLwAAOwAAIAFBBGshASAHQv/B1y9WIAYhBw0ACwwBCyAAKwMIIgm9Qv///////////wCDQoCAgICAgID4/wBaBEAgAigCACACKAIIIgFrQQNNBEAgAiABQQQQqgEgAigCCCEBCyACIAFBBGo2AgggAigCBCABakHu6rHjBjYAAAwDCyAJIANBCGoQJyIBIAIoAgAgAigCCCIAa0sEQCACIAAgARCqASACKAIIIQALIAEEQCACKAIEIABqIANBCGogAfwKAAALIAIgACABajYCCAwCCyAGQuMAVgRAIAFBAmsiASADQQhqaiAGpyIAIABB//8DcUHkAG4iAEHkAGxrQf//A3FBAXRBxuDAAGovAAA7AAAgAK0hBgsCQCAGQgpaBEAgAUECayIAIANBCGpqIAanQQF0QcbgwABqLwAAOwAADAELIAFBAWsiACADQQhqaiAGp0EwcjoAAAsgCEIAUwRAIABBAWsiACADQQhqakEtOgAAC0EUIABrIgQgAigCACACKAIIIgFrSwRAIAIgASAEEKoBIAIoAgghAQsgBARAIAIoAgQgAWogA0EIaiAAaiAE/AoAAAsgAiABIARqNgIIDAELIAZC4wBWBEAgAUECayIBIANBCGpqIAanIgAgAEH//wNxQeQAbiIAQeQAbGtB//8DcUEBdEHG4MAAai8AADsAACAArSEGCwJAIAZCCloEQCABQQJrIgEgA0EIamogBqdBAXRBxuDAAGovAAA7AAAMAQsgAUEBayIBIANBCGpqIAanQTByOgAAC0EUIAFrIgQgAigCACACKAIIIgBrSwRAIAIgACAEEKoBIAIoAgghAAsgBARAIAIoAgQgAGogA0EIaiABaiAE/AoAAAsgAiAAIARqNgIICyADQTBqJAAL8hYCKX8BfiMAQRBrIhUkACAALQCAASEGAkACQAJAAkACQCAAKAIkQX9GBEAgACgCICEEIAIhAyAGBEAgAkHAACAGa0H/AXEiA00NAiACIANrIQMLIANBBnYgA0E/cUEAR2ogBEF/c0sNAgsgBkUNAwtBwAAgBmsiByACSwRAAkAgAkUNACACQQNxIQhBACEEIAJBBE8EQCAAIAZqIQkgAkF8cSELA0AgASAEaiIDIAQgCWoiB0FAay0AACADLQAAczoAACADQQFqIgogB0HBAGotAAAg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AhAgAiATNgIMIAIgATYCCCACIBo3AwAgA0EFRg0CIAJBBTYCQCADQfv///8AakH/////AHFBBWogEkGcwcAAEOoBIQEgCEIDNwMAIAggATYCCCACKAIQIgEEQCACKAIUIAFBARCHAwsgAigCHCIBBEAgAigCICABQQEQhwMLIAIoAjQiAUGAgICAeEYgAUVyRQRAIAIoAjggAUEBEIcDCyACKAIoIgEEQCACKAIsIAFBARCHAwsMEwtBBEGIwsAAQZDCwAAQ6gELIQEgDEGAgICAeHJBgICAgHhHBEAgCSAMQQEQhwMLDA4LIAggAikDADcDACAIQThqIAJBOGopAwA3AwAgCEEwaiACQTBqKQMANwMAIAhBKGogAkEoaikDADcDACAIQSBqIAJBIGopAwA3AwAgCEEYaiACQRhqKQMANwMAIAhBEGogAkEQaikDADcDACAIQQhqIAJBCGopAwA3AwAMEAsgBSgCCCIBRQRAQYGAgIB4IRBBgICAgHghCQwFCyAFKAIEIRcgAUEFdCEYQYGAgIB4IRBBgICAgHghCUGAgICAeCEMQgMhGgNAIAEhCgJAAkACQAJAAkACQAJAAkBBFSAOIBdqIgMoAgAiAUGAgICAeHMgAUEAThtBAWsODwEAAAIAAAAAAAAAAwQFBgALIAMgAkFAa0H8wMAAEMkCIQEgAkEBOgAAIAIgATYCBAwGCyACQQA6AAAgAkEFIANBBGotAAAiASABQQVPGzoAAQwFCyACQQA6AAAgAkIFIANBCGopAwAiHCAcQgVaGzwAAQwECyACIANBCGooAgAgA0EMaigCABDaAQwDCyACIANBBGooAgAgA0EIaigCABDaAQwCCyACIANBCGooAgAgA0EMaigCABB1DAELIAIgA0EEaigCACADQQhqKAIAEHULAkACQAJAAkACQAJAIAItAABBAUYEQCACKAIEIQMMAQsgA0EQaiESIAohAQJAAkACQCACLQABDgUAAQIFBggLIAxBgICAgHhHBEBBoMLAAEEQEPkBIQNBAAwPCyACIBIQlQEgAigCBCEDIAIoAgAiDEGAgICAeEYEQEGAgICAeCEMQQAMDwsgAigCCCEUIAMhBAwHCyAJQYCAgIB4RwRAQbDCwABBBxD5ASEDQQAMDgsgAiASEJUBIAIoAgQhAyACKAIAIglBgICAgHhGBEBB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Gmo2AkAgACAXIBhqNgI8IAAgDCAVajYCOCAAIAogC2o2AjQgACAIIAlqNgIwIAAgBiAHajYCLCAAIAQgBWo2AiggAygCqAEhBCADKAKsASEFIAMoArABIQYgAygCtAEhByADKAK4ASEIIAMoArwBIQkgAygCwAEhCiADKALEASELIAMoAsgBIQwgACADKALMASAUajYCdCAAIAwgE2o2AnAgACALIBJqNgJsIAAgCiARajYCaCAAIAkgEGo2AmQgACAIIA9qNgJgIAAgByAOajYCXCAAIAYgDWo2AlggACACIAVqNgJUIAAgASAEajYCUCAAQfgAaiADQfgBaiAWEHggA0GgAmokAAubBwEcfyMAQfABayIDJAAgASgCACENIAEoAighDiABKAIEIQ8gASgCLCEQIAEoAgghESABKAIwIRIgASgCDCETIAEoAjQhFCABKAIQIQQgASgCOCEFIAEoAhQhBiABKAI8IQcgASgCGCEIIAEoAkAhCSABKAIcIQogASgCRCELIAEoAiAhDCABKAJIIRUgAyABKAIkIAEoAkxqNgIkIAMgDCAVajYCICADIAogC2o2AhwgAyAIIAlqNgIYIAMgBiAHajYCFCADIAQgBWo2AhAgAyATIBRqNgIMIAMgESASajYCCCADIA8gEGo2AgQgAyANIA5qNgIAIANBKGoiBCABQShqIAEQeCADQdAAaiIFIAMgAhA0IANB+ABqIgYgBCACQShqEDQgA0GgAWoiFiABQfgAaiACQdAAahA0IAMgASgCUEEBdCICNgLIASADIAEoAlRBAXQiDTYCzAEgAyABKAJYQQF0Ig42AtABIAMgASgCXEEBdCIPNgLUASADIAEoAmBBAXQiEDYC2AEgAyABKAJkQQF0IhE2AtwBIAMgASgCaEEBdCISNgLgASADIAEoAmxBAXQiEzYC5AEgAyABKAJwQQF0IhQ2AugBIAMgASgCdEEBdCIBNgLsASAAIAUgBhB4IAMoAnghBCADKAJQIQUgAygCfCEGIAMoAlQhByADKAKAASEIIAMoAlghCSADKAKEASEKIAMoAlwhCyADKAKIASEMIAMoAmAhFSADKAKMASEXIAMoAmQhGCADKAKQASEZIAMoAmghGiADKAKUASEbIAMoAmwhHCADKAKYASEdIAMoAnAhHiAAIAMoApwBIAMoAnRqNgJMIAAgHSAeajYCSCAAIBsgHGo2AkQgACAZIBpqNgJAIAAgFyAYajYCPCAAIAwgFWo2AjggACAKIAtqNgI0IAAgCCAJajYCMCAAIAYgB2o2AiwgACAEIAVqNgIoIAMoAqABIQQgAygCpAEhBSADKAKoASEGIAMoAqwBIQcgAygCsAEhCCADKAK0ASEJIAMoArgBIQogAygCvAEhCyADKALAASEMIAAgAygCxAEgAWo2AnQgACAMIBRqNgJwIAAgCyATajYCbCAAIAogEmo2AmggACAJIBFqNgJkIAAgCCAQajYCYCAAIAcgD2o2AlwgACAGIA5qNgJYIAAgBSANajYCVCAAIAIgBGo2AlAgAEH4AGogA0HIAWogFhB4IANB8AFqJAAL7QYBGX8jAEHQAWsiAiQAAkACQCAAKAKYASIHIAEgACkDkAF9e6ciFUsEQCAHQQV0IQ4gB0EBayEIIAAtAIoBQQRyIQ8gAkHgAGohCiACQbABaiEJIAJBCGohECACQRBqIREgAkEYaiESIAdBAmtBN0khFgNAIAAgCDYCmAEgECAAIA5qIgNBhAFqKQAANwMAIBEgA0GMAWopAAA3AwAgEiADQZQBaikAADcDACACIANB/ABqKQAANwMAIAhFDQIgACAIQQFrIgc2ApgBIAJBqAFqIgQgA0H0AGoiFykAADcDACACQaABaiIFIANB7ABqIhgpAAA3AwAgAkGYAWoiBiADQeQAaiIZKQAANwMAIAIgA0HcAGoiGikAADcDkAEgCUEYaiASKQMANwAAIAlBEGogESkDADcAACAJQQhqIBApAwA3AAAgCSACKQMANwAAIAogACkDADcDACAKQQhqIABBCGoiCykDADcDACAKQRBqIABBEGoiDCkDADcDACAKQRhqIABBGGoiDSkDADcDACACQShqIAYpAwA3AwAgAkEwaiAFKQMANwMAIAJBOGogBCkDADcDACACQUBrIAkpAwA3AwAgAkHIAGogAkG4AWopAwA3AwAgAkHQAGogAkHAAWopAwA3AwAgAkHYAGogAkHIAWopAwA3AwAgAiACKQOQATcDICACQcAAOgCIASACIA86AIkBIAJCADcDgAEgBCANKQIANwMAIAUgDCkCADcDACAGIAspAgA3AwAgAiAAKQIANwOQASACQZABaiACQSBqQcAAQgAgDxAiIAQoAgAh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ASAANgIIIAEgAEEIaiIFNgIEIAFB6AFqIABBgAFqKQMANwMAIAFB4AFqIABB+ABqKQMANwMAIAFB2AFqIABB8ABqKQMANwMAIAFBmAFqIABBMGopAwA3AwAgAUGgAWogAEE4aikDADcDACABQagBaiAAQUBrKQMANwMAIAFBsAFqIABByABqKQMANwMAIAFBuAFqIABB0ABqKQMANwMAIAFBwAFqIABB2ABqKQMANwMAIAFByAFqIABB4ABqKQMANwMAIAEgACkDaDcD0AEgASAAKQMoNwOQASAAKQOIASENIAApA5gBIQ4gAC0AkgEhByAALQCRASEIIAAtAJABIQkgACgCoAEiBAR/IARBBXQiCkEgayABQZgCakEEciEMQQAhAgNAIAJB4A1GBEBBlKzAABCIAwsgAiAMaiIDIAAgAmpBpAFqIgQpAAA3AAAgA0EYaiAEQRhqKQAANwAAIANBEGogBEEQaikAADcAACADQQhqIARBCGopAAA3AAAgCiACQSBqIgJHDQALIAYoAgBBAWshAiAAKAIAQQFrIQNBBXZBAWoFQQALIQQgAUEYaiAFQQhqKQMANwMAIAFBIGogBUEQaikDADcDACABQShqIAVBGGopAwA3AwAgASAENgKYAiABIAUpAwA3AxAgAUEwaiABQZABakHgAPwKAAAgACADNgIAIAYgAjYCACACRQRAIAFBDGoQoQILIAFBlAFqIAFBEGpBgAH8CgAAQZAPQQgQ+gIiAEUNAyAAQQA2AgggAEKBgICAEDcDACAAQQxqIAFBkAFqQYQB/AoAACAAIA43A6ABIAAgBzoAmgEgACAIOgCZASAAIAk6AJgBIAAgDTcDkAEgAEGoAWogAUGYAmpB5A38CgAAIAFBgBBqJAAgAEEIag8LEKMDCwALEKQDAAtBCEGQDxCsAwAL3AUCDH8DfiMAQaABayIJJAAgCUEAQaAB/AsAAkACQAJAIAIgACgCoAEiBU0EQCAFQSlPDQEgASACQQJ0aiEMAkACQCAFBEAgBUEBaiENIAVBAnQhCgNAIAkgBkECdGohAwNAIAYhAiADIQQgASAMRg0IIANBBGohAyACQQFqIQYgASgCACEHIAFBBGoiCyEBIAdFDQALIAetIRFCACEPIAohByACIQEgACEDA0AgAUEoTw0EIAQgDyAENQIAfCADNQIAIBF+fCIQPgIAIBBCIIghDyAEQQRqIQQgAUEBaiEBIANBBGohAyAHQQRrIgcNAAsgCCAQQoCAgIAQWgR/IAIgBWoiAUEoTw0DIAkgAUECdGogDz4CACANBSAFCyACaiIBIAEgCEkbIQggCyEBDAALAAsDQCABIAxGDQYgBEEBaiEEIAEoAgAgAUEEaiEBRQ0AIAggBEEBayICIAIgCEkbIQgMAAsACyABQShBpPLEABD2AQALIAFBKEGk8sQAEPYBAAsgBUEpTw0BIAJBAnQhDCACQQFqIQ0gACAFQQJ0aiEOIAAhAwJAA0AgCSAHQQJ0aiEGA0AgByELIAYhBCADIA5GDQUgBEEEaiEGIAdBAWohByADKAIAIQogA0EEaiIFIQMgCkUNAAsgCq0hEUIAIQ8gDCEKIAshAyABIQYDQCADQShPDQIgBCAPIAQ1AgB8IAY1AgAgEX58IhA+AgAgEEIgiCEPIARBBGohBCADQQFqIQMgBkEEaiEGIApBBGsiCg0ACwJAIAggEEKAgICAEFoEfyACIAtqIgNBKE8NASAJIANBAnRqIA8+AgAgDQUgAgsgC2oiAyADIAhJGyEIIAUhAwwBCwsgA0EoQaTyxAAQ9gEACyADQShBpPLEABD2AQALIAVBKEGk8sQAEIsDAAsgBUEoQaTyxAAQiwMACyAAIAlBoAH8CgAAIAAgCDYCoAEgCUGgAWokAAvdBQEBfyAAQQAgAkH/AXFrIgIgACgCACIDIAEoAgBzcSADczYCACAAIAAoAgQiAyABKAIEcyACcSADczYCBCAAIAAoAggiAyABKAIIcyACcSADczYCCCAAIAAoAgwiAyABKAIMcyACcSADczYCDCAAIAAoAhAiAyABKAIQcyACcSADczYCECAAIAAoAhQiAyABKAIUcyACcSADczYCFCAAIAAoAhgiAyABKAIYcyACcSADczYCGCAAIAAoAhwiAyABKAIccyACcSADczYCHCAAIAAoAiAiAyABKAIgcyACcSADczYCICAAIAAoAiQiAyABKAIkcyACcSADczYCJCAAIAAoAigiAyABKAIocyACcSADczYCKCAAIAAoAiwiAyABKAIscyACcSADczYCLCAAIAAoAjAiAyABKAIwcyACcSADczYCMCAAIAAoAjQiAyABKAI0cyACcSADczYCNCAAIAAoAjgiAyABKAI4cyACcSADczYCOCAAIAAoAjwiAyABKAI8cyACcSADczYCPCAAIAAoAkAiAyABKAJAcyACcSADczYCQCAAIAAoAkQiAyABKAJEcyACcSADczYCRCAAIAAoAkgiAyABKAJIcyACcSADczYCSCAAIAAoAkwiAyABKAJMcyACcSADczYCTCAAIAAoAlAiAyABKAJQcyACcSADczYCUCAAIAAoAlQiAyABKAJUcyACcSADczYCVCAAIAAoAlgiAyABKAJYcyACcSADczYCWCAAIAAoAlwiAyABKAJccyACcSADczYCXCAAIAAoAmAiAyABKAJgcyACcSADczYCYCAAIAAoAmQiAyABKAJkcyACcSADczYCZCAAIAAoAmgiAyABKAJocyACcSADczYCaCAAIAAoAmwiAyABKAJscyACcSADczYCbCAAIAAoAnAiAyABKAJwcyACcSADczYCcCAAIAAoAnQiACABKAJ0cyACcSAAczYCdAvaBQIHfwF+An8gAUUEQCAAKAIIIQdBLSELIAVBAWoMAQtBK0GAgMQAIAAoAggiB0GAgIABcSIBGyELIAFBFXYgBWoLIQkCQCAHQYCAgARxRQRAQQAhAgwBCwJAIANBEE8EQCACIAMQQCEBDAELIANFBEBBACEBDAELIANBA3EhCgJAIANBBEkEQEEAIQEMAQsgA0EMcSEMQQAhAQNAIAEgAiAIaiIGLAAAQb9/SmogBkEBaiwAAEG/f0pqIAZBAmosAABBv39KaiAGQQNqLAAAQb9/SmohASAMIAhBBGoiCEcNAAsLIApFDQAgAiAIaiEGA0AgASAGLAAAQb9/SmohASAGQQFqIQYgCkEBayIKDQALCyABIAlqIQkLAkAgAC8BDCIIIAlLBEACQAJAIAdBgICACHFFBEAgCCAJayEIQQAhAUEAIQkCQAJAAkAgB0EddkEDcUEBaw4DAAEAAgsgCCEJDAELIAhB/v8DcUEBdiEJCyAHQf///wBxIQogACgCBCEHIAAoAgAhAANAIAFB//8DcSAJQf//A3FPDQJBASEGIAFBAWohASAAIAogBygCEBEAAEUNAAsMBAsgACAAKQIIIg2nQYCAgP95cUGwgICAAnI2AghBASEGIAAoAgAiByAAKAIEIgogCyACIAMQqgINA0EAIQEgCCAJa0H//wNxIQIDQCABQf//A3EgAk8N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CUL///8PgyAEQhmIQhN+IAhC////H4N8IgRCGoh8PgIMIAMgBKdB////H3E2AgggAkECTwRAIAJBAWshAgNAIANBMGogA0EIahBSIAMgAykDYCADKQNYIAMpA1AiBEIaiHwiB0IZiHwiBadB////H3E2AiAgAyADKQNAIAMpAzggAykDMCIIQhqIfCIJQhmIfCIGp0H///8fcTYCECADIAMpA2ggBUIaiHwiBadB////D3E2AiQgAyADKQNIIAZCGoh8IganQf///w9xNgIUIAMgAykDcCAFQhmIfCIFp0H///8fcTYCKCADIAdC////D4MgBEL///8fgyAGQhmIfCIEQhqIfD4CHCADIASnQf///x9xNgIYIAMgAykDeCAFQhqIfCIEp0H///8PcTYCLCADIAlC////D4MgBEIZiEITfiAIQv///x+DfCIEQhqIfD4CDCADIASnQf///x9xNgIIIAJBAWsiAg0ACwsgACADKQIINwIAIABBIGogA0EoaikCADcCACAAQRhqIANBIGopAgA3AgAgAEEQaiADQRhqKQIANwIAIABBCGogA0EQaikCADcCACADQYABaiQAC8YFAgh/AnwjAEEwayIFJABBASEJIAEgASgCFCIHQQFqIgY2AhQgAUEMaiEIAkAgBiABKAIQIgpPDQACQAJAIAgoAgAgBmotAABBK2sOAwECAAILQQAhCQsgASAHQQJqIgY2AhQLAkACQCAGIApJBEAgASAGQQFqIgc2AhQgASgCDCIMIAZqLQAAQTBrQf8BcSIGQQpPBEAgBUENNgIkIAVBEGogCBCeAiAFQSRqIAUoAhAgBSgCFBCaAiEBIABBATYCACAAIAE2AgQMAwsgByAKTw0BA0AgByAMai0AAEEwa0H/AXEiC0EKTw0CIAEgB0EBaiIHNgIUIAZBzJmz5gBHIAtBB0tyIAZBy5mz5gBKcUUEQCAGQQpsIAtqIQYgByAKRw0BDAMLCyAAIAEgAiADUCAJENABDAILIAVBBTYCJCAFQRhqIAgQngIgBUEkaiAFKAIYIAUoAhwQmgIhASAAQQE2AgAgACABNgIEDAELIAO6IQ0gAAJ/AkACQAJAAkACfyAJRQRAIAQgBmsiAUEfdUGAgICAeHMgASABIARIIAZBAEpzGwwBCyAEIAZqIgFBH3VBgICAgHhzIAEgBkEASCAB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ACAIIAgpAwA3AEMgCEHYAGohMiMAQaALayIEJAAgBEHwA2oiBUIANwMAIARB+ANqIgdCADcDACAEQYAEaiIJQgA3AwAgBEGIBGoiHEIANwMAIARBkARqIgpCADcDACAEQZgEaiIOQgA3AwAgBEHwB2oiESAIQRhqIjMiBkEQaiIpKQAANwMAIARB+AdqIiEgBkEYaiIiKQAANwMAIARCADcD4AMgBEIANwPoAyAEIAYpAAA3A+AHIAQgBkEIaiIqKQAANwPoByAEQdgJaiIMIAFBGGopAgA3AwAgBEHQCWoiCyABQRBqKQIANwMAIAQgAUEIaikCADcDyAkgBCABKQIANwPACSAEQbgCakHI8MAAKQMANwMAIARBsAJqQcDwwAApAwA3AwAgBEGoAmpBuPDAACkDADcDACAEQaACakGw8MAAKQMANwMAIARBmAJqQajwwAApAwA3AwAgBEGQAmpBoPDAACkDADcDACAEQYgCakGY8MAAKQMANwMAIARBkPDAACkDADcDgAIgBEIANwPIAiAEQgA3A8ACIARB6AJqICEpAwA3AwAgBEHgAmogESkDADcDACAEQdgCaiAEKQPoBzcDACAEIAQpA+AHNwPQAiAEQYgDaiAMKQMANwMAIARBgANqIAspAwA3AwAgBEH4AmogBCkDyAk3AwAgBCAEKQPACTcD8AIgBEHIA2ogDikDADcDACAEQcADaiAKKQMANwMAIARBuANqIBwpAwA3AwAgBEGwA2ogCSkDADcDACAEQagDaiAHKQMANwMAIARBoANqIAUpAwA3AwAgBEGYA2ogBCkD6AM3AwAgBCAEKQPgAzcDkAMgBEHAADoA0AMgBEHYA2ogBEHnCmopAAA3AAAgBCAEKQDgCjcA0QMgBCABQcAB/AoAACAEQfgBaiAGQThqKQAANwMAIARB8AFqIAZBMGopAAA3AwAgBEHoAWogBkEoaikAADcDACAEQeABaiAGQSBqKQAANwMAIARB2AFqICIpAAA3AwAgBEHQAWogKSkAADcDACAEQcgBaiAqKQAANwMAIAQgBikAADcDwAEgBEHQAmohASAEQYACaiEHAkACQEGAASAELQDQAyIGayIFIANNBEAgBkUNASAFBEAgASAGaiACIAX8CgAACyAEIAQpA8ACQgF8IjU3A8ACIAQgBCkDyAIgNVCtfDcDyAIgByABQQEQoAMgAiAFaiECIAMgBWshAwwBCyADBEAgASAGaiACIAP8CgAACyADIAZqIQYMAQsgA0H/AHEhBiADQYABTwRAIAQgBCkDwAIiNSADQQd2IgWtfCI2NwPAAiAEIAQpA8gCIDUgNlatfDcDyAIgByACIAUQoAMLIAZFDQAgASACIANBgH9xaiAG/AoAAAsgBCAGOgDQAyAEQeADaiAEQeAD/AoAACAEQeAHaiIcIAdB4AH8CgAAIARByAlqIgFCADcDACAEQdAJaiICQgA3AwAgBEHYCWoiA0IANwMAIARB4AlqIgZCADcDACAEQegJaiIHQgA3AwAgBEHwCWoiCUIANwMAIARB+AlqIgpCADcDACAEQgA3A8AJIBwgBEGwCGogBEHACWoiBRA4IARBmAtqIAopAwA3AwAgBEGQC2ogCSkDADcDACAEQYgLaiAHKQMANwMAIARBgAtqIAYpAwA3AwAgBEH4CmogAykDADcDACAEQfAKaiACKQMANwMAIARB6ApqIAEpAwA3AwAgBCAEKQPACTcD4AogBEHAB2oiAiAEQeAKahDFAiAFIARBgARqIgEQkgEgBUHIAGogAUHIAGopAgA3AgAgBUFAayABQUBrKQIANwIAIAVBOGogAUE4aikCADcCACAFQTBqIAFBMGopAgA3AgAgBSABKQIoNwIoIAUgASkCUDcCUCAFQdgAaiABQdgAaikCADcCACAFQeAAaiABQeAAaikCADcCACAFQegAaiABQegAaikCADcCACAFQfAAaiABQfAAaikCADcCACAFQfgAaiABQfgAahCSASMAQYAUayIGJAAgBkEIaiACQQUQhgEgBkGIAmogBEHABWpBCBCGAUH/ASEDA0AgAyICIAZBCGpqLQAAIANFckUEQCADQQFrIQMgBkGIAmogAmotAABFDQELCyMAQYAPayIBJAAgBUEIaiIKKAIAIQMgBUEwaiIOKAIAIQcgBUEQaiIRKAIAIQkgBUE4aiIpKAIAISEgBUEYaiIMKAIAISIgBUFAayIqKAIAIQsgBUEgaiIPKAIAIRQgBUHIAGoiFigCACEXIAUoAgAhGCAFKAIoIRkgBSgCBCEaIAUoAiwhDSAFKAIMIRAgBSgCNCEVIAUoAhQhGyAFKAI8ISMgBSgCHCErIAUoAkQhLSABIAUoAiQgBSgCTGo2AoQOIAEgFCAXajYCgA4gASArIC1qNgL8DSABIAsgImo2AvgNIAEgGyAjajYC9A0gASAJICFqNgLwDSABIBAgFWo2AuwNIAEgAyAHajYC6A0gASANIBpqNgLkDSABIBggGWo2AuANIAFBiA5qIgcgBUEoaiAFEHggAUHQDmogBUHwAGoiCykCADcCACABQcgOaiAFQegAaiIUKQIANwIAIAFBwA5qIAVB4ABqIiIpAgA3AgAgAUG4DmogBUHYAGoiISkCADcCACABIAUpAlA3ArAOIAFB2A5qIgkgBUH4AGpBkPXAABA0IAEgAUHgDWoiA0GgAfwKAAAgAUGgAWoiDSADQaAB/AoAACABQcACaiIQIANBoAH8CgAAIAFB4ANqIhUgA0GgAfwKAAAgAUGABWoiGyADQaAB/AoAACABQaAGaiIjIANBoAH8CgAAIAFBwAdqIisgA0GgAfwKAAAgAUHgCGoiLSADQaAB/AoAACABQYgNaiAWKQIANwMAIAFBgA1qICopAgA3AwAgAUH4DGogKSkCADcDACABQfAMaiAOKQIANwMAIAFBmA1qIikgISkCADcDACABQaANaiIhICIpAgA3AwAgAUGoDWoiIiAUKQIANwMAIAFBsA1qIiogCykCADcDACABIAUpAig3A+gMIAEgBSkCUDcDkA0gAUHgDGogDykCADcDACABQdgMaiAMKQIANwMAIAFB0AxqIBEpAgA3AwAgAUHIDGogCikCADcDACABIAUpAgA3A8AMIAMgAUHADGoiChArIAFBgApqIgwiDiADIAkQNCABQagKaiAHIAFBsA5qIgUQNCABQdAKaiAFIAkQNCABQfgKaiADIAcQNCADIA4gARBDIAogAyAJEDQgAUHoDGoiDiAHIAUQNCABQZANaiILIAUgCRA0IAFBuA1qIhEgAyAHEDQgASgCwAwhDyABKALoDCEUIAEoAsQMIRYgASgC7AwhFyABKALIDCEYIAEoAvAMIRkgASgCzAwhGiABKAL0DCESIAEoAtAMIRMgASgC+AwhHSABKALUDCEeIAEoAvwMIR8gASgC2AwhICABKAKADSEkIAEoAtwMISUgASgChA0hJiABKALgDCEnIAEoAogNISggASABKALkDCABKAKMDWo2AsQLIAEgJyAoajYCwAsgASAlICZqNgK8CyABICAgJGo2ArgLIAEgHiAfajYCtAsgASATIB1qNgKwCyABIBIgGmo2AqwLIAEgGCAZajYCqAsgASAWIBdqNgKkCyABIA8gFGo2AqALIAFByAtqIg8gDiAKEHggAUGQDGoiFCAqKQIANwIAIAFBiAxqIhYgIikCADcCACABQYAMaiIXICEpAgA3AgAgAUH4C2oiGCApKQIANwIAIAEgASkCkA03AvALIAFBmAxqIhkgEUGQ9cAAEDQgDSABQaALaiIaQaAB/AoAACADIAwgDRBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhDSABKALoDCESIAEoAsQMIRMgASgC7AwhHSABKALIDCEeIAEoAvAMIR8gASgCzAwhICABKAL0DCEkIAEoAtAMISUgASgC+AwhJiABKALUDCEnIAEoAvwMISggASgC2AwhLCABKAKADSEuIAEoAtwMIS8gASgChA0hMCABKALgDCExIAEoAogNITQgASABKALkDCABKAKMDWo2AsQLIAEgMSA0ajYCwAsgASAvIDBqNgK8CyABICwgLmo2ArgLIAEgJyAoajYCtAsgASAlICZqNgKwCyABICAgJGo2AqwLIAEgHiAfajYCqAsgASATIB1qNgKkCyABIA0gEmo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgECAaQaAB/AoAACADIAwgEBBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhDSABKALoDCEQIAEoAsQMIRIgASgC7AwhEyABKALIDCEdIAEoAvAMIR4gASgCzAwhHyABKAL0DCEgIAEoAtAMISQgASgC+AwhJSABKALUDCEmIAEoAvwMIScgASgC2AwhKCABKAKADSEsIAEoAtwMIS4gASgChA0hLyABKALgDCEwIAEoAogNITEgASABKALkDCABKAKMDWo2AsQLIAEgMCAxajYCwAsgASAuIC9qNgK8CyABICggLGo2ArgLIAEgJiAnajYCtAsgASAkICVqNgKwCyABIB8gIGo2AqwLIAEgHSAeajYCqAsgASASIBNqNgKkCyABIA0gEGo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgFSAaQaAB/AoAACADIAwgFRBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhDSABKALoDCEQIAEoAsQMIRUgASgC7AwhEiABKALIDCETIAEoAvAMIR0gASgCzAwhHiABKAL0DCEfIAEoAtAMISAgASgC+AwhJCABKALUDCElIAEoAvwMISYgASgC2AwhJyABKAKADSEoIAEoAtwMISwgASgChA0hLiABKALgDCEvIAEoAogNITAgASABKALkDCABKAKMDWo2AsQLIAEgLyAwajYCwAsgASAsIC5qNgK8CyABICcgKGo2ArgLIAEgJSAmajYCtAsgASAgICRqNgKwCyABIB4gH2o2AqwLIAEgEyAdajYCqAsgASASIBVqNgKkCyABIA0gEGo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgGyAaQaAB/AoAACADIAwgGxBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhDSABKALoDCEQIAEoAsQMIRUgASgC7AwhGyABKALIDCESIAEoAvAMIRMgASgCzAwhHSABKAL0DCEeIAEoAtAMIR8gASgC+AwhICABKALUDCEkIAEoAvwMISUgASgC2AwhJiABKAKADSEnIAEoAtwMISggASgChA0hLCABKALgDCEuIAEoAogNIS8gASABKALkDCABKAKMDWo2AsQLIAEgLiAvajYCwAsgASAoICxqNgK8CyABICYgJ2o2ArgLIAEgJCAlajYCtAsgASAfICBqNgKwCyABIB0gHmo2AqwLIAEgEiATajYCqAsgASAVIBtqNgKkCyABIA0gEGo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgIyAaQaAB/AoAACADIAwgIxBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhDSABKALoDCEQIAEoAsQMIRUgASgC7AwhGyABKALIDCEjIAEoAvAMIRIgASgCzAwhEyABKAL0DCEdIAEoAtAMIR4gASgC+AwhHyABKALUDCEgIAEoAvwMISQgASgC2AwhJSABKAKADSEmIAEoAtwMIScgASgChA0hKCABKALgDCEsIAEoAogNIS4gASABKALkDCABKAKMDWo2AsQLIAEgLCAuajYCwAsgASAnIChqNgK8CyABICUgJmo2ArgLIAEgICAkajYCtAsgASAeIB9qNgKwCyABIBMgHWo2AqwLIAEgEiAjajYCqAsgASAVIBtqNgKkCyABIA0gEGo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgKyAaQaAB/AoAACADIAwgKxBDIAogAyAJEDQgDiAHIAUQNCALIAUgCRA0IBEgAyAHEDQgASgCwAwhAyABKALoDCEFIAEoAsQMIQcgASgC7AwhCSABKALIDCEMIAEoAvAMIQsgASgCzAwhDSABKAL0DCEQIAEoAtAMIRUgASgC+AwhGyABKALUDCEjIAEoAvwMISsgASgC2AwhEiABKAKADSETIAEoAtwMIR0gASgChA0hHiABKALgDCEfIAEoAogNISAgASABKALkDCABKAKMDWo2AsQLIAEgHyAgajYCwAsgASAdIB5qNgK8CyABIBIgE2o2ArgLIAEgIyArajYCtAsgASAVIBtqNgKwCyABIA0gEGo2AqwLIAEgCyAMajYCqAsgASAHIAlqNgKkCyABIAMgBWo2AqALIA8gDiAKEHggFCAqKQIANwIAIBYgIikCADcCACAXICEpAgA3AgAgGCApKQIANwIAIAEgASkCkA03AvALIBkgEUGQ9cAAEDQgLSAaQaAB/AoAACAGQYgEaiABQYAK/AoAACABQYAPaiQAIAZBqA5qQgA3AwAgBkGgDmpCADcDACAGQZgOakIANwMAIAZBkA5qQgA3AwAgBkG4DmpB0LHBACkCACI1NwMAIAZBwA5qQdixwQApAgAiNjcDACAGQcgOakHgscEAKQIAIjc3AwAgBkHQDmpB6LHBACkCACI4NwMAIAZB4A5qIDU3AwAgBkHoDmogNjcDACAGQfAOaiA3NwMAIAZB+A5qIDg3AwAgBkIANwOIDiAGQcixwQApAgAiNTcDsA4gBiA1NwPYDiAGQbATaiEOIAZBiBNqIREgBkHYE2ohKSAGQbgSaiEhIAZBkBJqISIgBkHoEWohKiAGQdAPaiEHIAZBqA9qIQogBkH4D2ohCQNAIAZBgA9qIAZBiA5qECsCQAJAAkACQCAGQQhqIAJqLAAAIgFBAEogAUEASGtB/wFxDgIDAQALIAZBwBFqIAZBgA9qIgMgCRA0ICogCiAHEDQgIiAHIAkQNCAhIAMgChA0QQAgAWsiAcBBAXYhAyABQf8BcUEQSQ0BIANBCEHwscEAEPYBAAsgBkHAEWogBkGAD2oiAyAJEDQgKiAKIAcQNCAiIAcgCRA0ICEgAyAKEDQgAUEBdiEDIAFBEE8EQCADQQhB8LHBABD2AQALIAZB4BJqIgEgBkGIBGogA0GgAWxqQaAB/AoAACAGQaAQaiIDIAZBwBFqIAEQQyAGQYAPaiADQaAB/AoAAAwBCyAGQeASaiIBIAZBiARqIANBoAFsakGgAfwKAAAjAEGgAmsiAyQAIAZBwBFqIgUoAgAhDCAFKAIoIQsgBSgCBCEPIAUoAiwhFCAFKAIIIRYgBSgCMCEXIAUoAgwhGCAFKAI0IRkgBSgCECEaIAUoAjghDSAFKAIUIRAgBSgCPCEVIAUoAhghGyAFKAJAISMgBSgCHCErIAUoAkQhLSAFKAIgIRIgBSgCSCETIAMgBSgCJCAFKAJMajYCLCADIBIgE2o2AiggAyArIC1qNgIkIAMgGyAjajYCICADIBAgFWo2AhwgAyANIBpqNgIYIAMgGCAZajYCFCADIBYgF2o2AhAgAyAPIBRqNgIMIAMgCyAMajYCCCADQTBqIgwgBUEoaiAFEHggA0HYAGoiCyADQQhqIAFBKGoQNCADQYABaiIPIAwgARA0IANBqAFqIgwgBUH4AGogAUH4AGoQNCADQdABaiAFQdAAaiABQdAAahA0IAMgAygC0AFBAXQiBTYC+AEgAyADKALUAUEBdCIUNgL8ASADIAMoAtgBQQF0IhY2AoACIAMgAygC3AFBAXQiFzYChAIgAyADKALgAUEBdCIYNgKIAiADIAMoAuQBQQF0Ihk2AowCIAMgAygC6AFBAXQiGjYCkAIgAyADKALsAUEBdCINNgKUAiADIAMoAvABQQF0IhA2ApgCIAMgAygC9AFBAXQiFTYCnAIgBkGgEGoiASALIA8QeCADKAKAASELIAMoAlghDyADKAKEASEbIAMoAlwhIyADKAKIASErIAMoAmAhLSADKAKMASESIAMoAmQhEyADKAKQASEdIAMoAmghHiADKAKUASEfIAMoAmwhICADKAKYASEkIAMoAnAhJSADKAKcASEmIAMoAnQhJyADKAKgASEoIAMoAnghLCABIAMoAqQBIAMoAnxqNgJMIAEgKCAsajYCSCABICYgJ2o2AkQgASAkICVqNgJAIAEgHyAgajYCPCABIB0gHmo2AjggASASIBNqNgI0IAEgKyAtajYCMCABIBsgI2o2AiwgASALIA9qNgIoIAFB0ABqIANB+AFqIAwQeCABIAMoAswBIBVqNgKcASABIAMoAsgBIBBqNgKYASABIAMoAsQBIA1qNgKUASABIAMoAsABIBpqNgKQASABIAMoArwBIBlqNgKMASABIAMoArgBIBhqNgKIASABIAMoArQBIBdqNgKEASABIAMoArABIBZqNgKAASABIAMoAqwBIBRqNgJ8IAEgAygCqAEgBWo2AnggA0GgAmokACAGQYAPaiABQaAB/AoAAAsCQAJAAkACQCAGQYgCaiACaiwAACIBQQBKIAFBAEhrQf8BcQ4CAwEACyAGQeASaiAGQYAPaiIDIAkQNCARIAogBxA0IA4gByAJEDQgKSADIAoQNEEAIAFrwCIDQQF2IQEgA0EATg0BIAFBwABBgLLBABD2AQALIAZB4BJqIAZBgA9qIgMgCRA0IBEgCiAHEDQgDiAHIAkQNCApIAMgChA0IAFBAXYhAyABQQBIBEAgA0HAAEGAssEAEPYBAAsgBkGgEGoiASADQfgAbEHI9cAAakH4APwKAAAgBkHAEWoiAyAGQeASaiABEEQgBkGAD2ogA0GgAfwKAAAMAQsgBkGgEGoiBSABQfgAbEHI9cAAakH4APwKAAAjAEHwAWsiASQAIAZB4BJqIgMoAgAhDCADKAIoIQsgAygCBCEPIAMoAiwhFCADKAIIIRYgAygCMCEXIAMoAgwhGCADKAI0IRkgAygCECEaIAMoAjghDSADKAIUIRAgAygCPCEVIAMoAhghGyADKAJAISMgAygCHCErIAMoAkQhLSADKAIgIRIgAygCSCETIAEgAygCJCADKAJMajYCJCABIBIgE2o2AiAgASArIC1qNgIcIAEgGyAjajYCGCABIBAgFWo2AhQgASANIBpqNgIQIAEgGCAZajYCDCABIBYgF2o2AgggASAPIBRqNgIEIAEgCyAMajYCACABQShqIgwgA0EoaiADEHggAUHQAGoiCyABIAVBKGoQNCABQfgAaiIPIAwgBRA0IAFBoAFqIgwgA0H4AGogBUHQAGoQNCABIAMoAlBBAXQiBTYCyAEgASADKAJUQQF0IhQ2AswBIAEgAygCWEEBdCIWNgLQASABIAMoAlxBAXQiFzYC1AEgASADKAJgQQF0Ihg2AtgBIAEgAygCZEEBdCIZNgLcASABIAMoAmhBAXQiGjYC4AEgASADKAJsQQF0Ig02AuQBIAEgAygCcEEBdCIQNgLoASABIAMoAnRBAXQiFTYC7AEgBkHAEWoiAyALIA8QeCABKAJ4IQsgASgCUCEPIAEoAnwhGyABKAJUISMgASgCgAEhKyABKAJYIS0gASgChAEhEiABKAJcIRMgASgCiAEhHSABKAJgIR4gASgCjAEhHyABKAJkISAgASgCkAEhJCABKAJoISUgASgClAEhJiABKAJsIScgASgCmAEhKCABKAJwISwgAyABKAKcASABKAJ0ajYCTCADICggLGo2AkggAyAmICdqNgJEIAMgJCAlajYCQCADIB8gIGo2AjwgAyAdIB5qNgI4IAMgEiATajYCNCADICsgLWo2AjAgAyAbICNqNgIsIAMgCyAPajYCKCADQdAAaiABQcgBaiAMEHggAyABKALEASAVajYCnAEgAyABKALAASAQajYCmAEgAyABKAK8ASANajYClAEgAyABKAK4ASAaajYCkAEgAyABKAK0ASAZajYCjAEgAyABKAKwASAYajYCiAEgAyABKAKsASAXajYChAEgAyABKAKoASAWajYCgAEgAyABKAKkASAUajYCfCADIAEoAqABIAVqNgJ4IAFB8AFqJAAgBkGAD2ogA0GgAfwKAAALIAZB4BJqIgEgBkGAD2ogCRA0IBEgCiAHEDQgDiAHIAkQNCAGQYgOaiABQfgA/AoAACACBEAgAkEBayECDAELCyMAQdAAayIBJAAgHCAGQYgOaiICIAJB0ABqIgMQNCAcQShqIAJBKGoiBSADEDQgASADEFIgHCABKQMwIAEpAyggASkDICI1QhqIfCI2QhmIfCI3p0H///8fcTYCaCAcIAEpAxAgASkD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KAIgayABKAIcIAIoAhxrIAEoAhggAigCGGsgASgCFCACKAIUayABKAIQIAIoAhBrIAEoAgwgAigCDGsgASgCCCACKAIIayABKAIEIAEoAgAgAigCAGsiBEEfdWogAigCBGsiAkEfdWoiBUEfdWoiBkEfdWoiB0EfdWoiCEEfdWoiCUEfdWoiCkEfdWoiC0EfdSIBNgIMIAMoAgwhDCADIAE2AgwgAygCDCENIAMgATYCDCADKAIMIQ4gAyABNgIMIAMoAgwhDyADIAE2AgwgAygCDCEQIAMgATYCDCADKAIMGiADIAE2AgwgAygCDBogAyABNgIMIAMoAgwaIAMgATYCDCADKAIMIQEgACAKQf////8BcSAJQf////8BcSAIQf////8BcSAHQf////8BcSAGQf////8BcSAFQf////8BcSACQf////8BcSAMQe2n1+cBcSAEQf////8BcWoiAkEddmogDUHSscwEcWoiA0EddmogDkGW65zvAXFqIgRBHXZqIA9BxfrO7wFxaiIFQR12aiAQQc0CcWoiBkEddmoiB0EddmoiCEEddmoiCUH/////AXE2AhwgACAIQf////8BcTYCGCAAIAdB/////wFxNgIUIAAgBkH/////AXE2AhAgACAFQf////8BcTYCDCAAIARB/////wFxNgIIIAAgA0H/////AXE2AgQgACACQf////8BcTYCACAAIAlBHXYgC2ogAUGAgMAAcWpB/////wFxNgIgC/4DAg1/AX4gAyABKAIYIgsgBWsiCEsEQCABKAIMIgkgBSAFIAlJGyEPIARBAWshESABKAIgIQ0gASgCECEQIAEpAwAhFANAAkACQCAUIAIgCGoiEjEAAIhCAYNQBEAgASAINgIYIAUhByAIIQsgBkUNAQwCCwJAAkACQAJAAkAgBSAJIA0gCSAJIA1LGyAGGyIHQQFrIgpLBEAgByARaiEMQQAgB2shCiAHIAhqQQFrIQcDQCAKRQ0CIAMgB00NAyAKQQFqIQogAiAHaiEOIAwtAAAgB0EBayEHIAxBAWshDCAOLQAARg0ACyALIAlrIAprIQsgBSEHIAYNBwwGCyAHDQILIAUgDSAGGyIHIAkgByAJSxshCiAJIQcDQCAHIApGBEAgASAINgIYIAZFBEAgASAFNgIgCyAAIAs2AgggACAINgIEIABBATYCAA8LIAcgD0YNAyAHIAhqIANPDQQgByASaiEMIAQgB2ogB0EBaiEHLQAAIAwtAABGDQALIAsgEGshCyAQIQcgBkUNBAwFCyAHIANBmMfDABD2AQALIAogBUGIx8MAEPYBAAsgDyAFQejGwwAQ9gEACyADIAggCWoiACAAIANJGyADQfjGwwAQ9gEACyABIAc2AiAgByENCyALIAVrIgggA0kNAAsLIAFBADYCGCAAQQA2AgAL5wQBBn8jAEEgayIBJAAgABBYAkACQAJAAkAgACgCCCIEIAAoAgQiA0cEQANAIAMgBE0NAiAAKAIAIgYgBGotAAAiAkHcAEcEQCACQSJHBEAgAUEQNgIUIAAgAUEUahCjAiEADAcLIAAgBEEBajYCCEEAIQAMBgsgACAEQQFqIgU2AggCQAJAAkACfyADIAVLBEAgACAEQQJqIgI2AgggBSAGai0AAAwBCyABQQQ2AhQgAUEMaiAAIAFBFGoQkgIgAS0ADEEBcQ0HIAUhAiABLQANC0H/AXFBImsOVAIAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAACAAAAAgAAAAAAAAACAAAAAgACAQALIAFBDDYCFCAAIAFBFGoQowIhAAwHCyACIANLDQUCQCADIAJrQQNNBEAgACADNgIIIAFBBDYCFCABQQxqIAAgAUEUahCTAgwBCyAAIAJBBGo2AgggAiAGaiICLQABQQF0QaDRwwBqLwEAIAItAABBAXRBoNXDAGovAQByIAItAAJBAXRBoNXDAGovAQByIAItAANBAXRBoNHDAGovAQBywUEATgRAIAFBADsBDAwBCyABQQw2AhQgAUEMaiAAIAFBFGoQkwILIAEvAQxBAUcNACABKAIQIQAMBgsgABBYIAAoAggiBCAAKAIEIgNHDQALCyABQQQ2AhQgACABQRRqEKMCIQAMAwsgBCADQfDPwwAQ9gEACyABKAIQIQAMAQsgAiADQYDQwwAQigMACyABQSBqJAAgAAvNBAEKfyMAQTBrIgYkAAJAAkACQAJ/QQAgAUFAcSIKRQ0AGiAGQQhqIAA2AgBBASAKQcAARg0AGiAGIABBQGs2AgwgCkGAAUcNAUECCyEHIAFBP3EhASAFQQV2IgkgByAHIAlLGyIIBEAgBkEIaiEJIANBBHIhCyAIQQV0IQxBACEDA0AgCSgCACEIIAZBKGoiDSACQRhqKQIANwMAIAZBIGoiDiACQRBqKQIANwMAIAZBGGoiDyACQQhqKQIANwMAIAYgAikCADcDECAGQRBqIAhBwABCACALECIgAyAEaiIIQRhqIA0pAwA3AAAgCEEQaiAOKQMANwAAIAhBCGogDykDADcAACAIIAYpAxA3AAAgCUEEaiEJIAwgA0EgaiIDRw0ACwsCQCABBEAgBSAHQQV0IgJJDQEgBSACayIDQR9NDQMgAUEgRw0EIAIgBGoiASAAIApqIgApAAA3AAAgAUEYaiAAQRhqKQAANwAAIAFBEGogAEEQaikAADcAACABQQhqIABBCGopAAA3AAAgB0EBaiEHCyAGQTBqJAAgBw8LIAIgBUHM6MAAEIoDAAsgBiAAQYABajYCEEHI7MAAQSsgBkEQakH07MAAQdzowAAQ7gEAC0EgIANBrOjAABCLAwALIwBBMGsiACQAIABBIDYCBCAAIAE2AgAgAEEDNgIMIABBlPXEADYCCCAAQgI3AhQgACAAQQRqrUKAgICAwAiENwMoIAAgAK1CgICAgMAIhDcDICAAIABBIGo2AhAgAEEIakG86MAAEMcCAAvNAwIMfwF+IwBBEGsiByQAIAMEQANAIANBECADIANBEE8bIgRrIAIgBGoCQCADQQ9LBEAgASACQQAQbgwBCyAEIAdqIQNBECAEayIFBEAgA0EAIAX8CwALIAQEQCAHIAIgBPwKAAALIANBAToAACABIAdBARBuCyECIgMNAAsLIAAgASgCJCABKAI0IAEoAjAgASgCLCABKAIoIgJBGnZqIgNBGnZqIgZBGnZqIghBGnZBBWxqIgRB////H3EiBUEFaiIJQRp2IAJB////H3EgBEEadmoiAmoiBEEadiADQf///x9xIgpqIgtBGnYgBkH///8fcSIGaiIMQRp2IAhB////H3FqIg1BgICAIGsiDkEfdkEBayIPQf///x9xIgMgBHEgAiAOQR91IgJxciIEQRp0IAIgBXEgAyAJcXJyIgUgASgCAGoiCTYAACAAIAUgCUutIAE1AgQgAyALcSACIApxciIFQRR0IARBBnZyrXx8IhA+AAQgACABNQIIIAMgDHEgAiAGcXIiA0EOdCAFQQx2cq18IBBCIIh8IhA+AAggACABNQIMIA0gD3EgAiAIcXJBCHQgA0ESdnKtfCAQQiCIfD4ADCAHQRBqJAALiAQBA38jAEHAI2siAiQAAkACQAJAIAFFBEAgAEUNASAAQQhrIgEoAgBBAUcNAiACQeARaiAAQeAR/AoAACABQQA2AgACQCABQX9GDQAgAEEEayIAIAAoAgBBAWsiADYCACAADQAgAUHoEUEIEIcDCyACQQhqIAJB6BFqQdgR/AoAACACKAKgAQRAIAJBADYCoAELIAIoApAQIQMgAigClBAiAQRAIAMhAANAIAAoAgAiBARAIABBBGooAgAgBEEBEIcDCyAAQQxqIQAgAUEBayIBDQALCyACKAKMECIABEAgAyAAQQxsQQQQhwMLIAIoAoAQIgBBgICAgHhGIABFckUEQCACKAKEECAAQQEQhwMLIAIoAugPIgAEQCACKALsDyAAQQEQhwMLIAIoAvQPIgAEQCACKAL4DyAAQQEQhwMLIAJBkA9qEJMBAkAgAigClA8iAEUNACAAIABBA3RBD2pBeHEiAWpBCWoiAEUNACACKAKQDyABayAAQQgQhwMLIAJBwA9qEIQBIAIoAsQPIgBFDQMgACAAQQN0QQ9qQXhxIgFqQQlqIgBFDQMgAigCwA8gAWsgAEEIEIcDDAMLIABFDQAgAiAAQQhrIgA2AuARIAAgACgCAEEBayIANgIAIAANAiACQeARahCJAQwCCxCjAwALQcCqwABBPxCiAwALIAJBwCNqJAALqA0CCH4GfyMAQRBrIg0kACACKQMQIAGtiiEDIAICfiABQRFPBEAgAikDICADfCEEIAFBgAJPBEACfiAAIQwgAikDKCADfCEGIAIpAzAgA3whBSACKQMYIQggAUFAcSILBEBBACALayELA0AgAEE4aikAACAIhSIHQiCIIgkgAEEYaikAACAFhSIFQiCIIgp+IAdC/////w+DIgcgBUL/////D4MiBX6FIAcgCn4gBSAJfoVCIImFIQUgAEEwaikAACAIhSIHQiCIIgkgAEEQaikAACAGhSIGQiCIIgp+IAdC/////w+DIgcgBkL/////D4MiBn6FIAcgCn4gBiAJfoVCIImFIQYgAEEoaikAACAIhSIHQiCIIgkgAEEIaikAACAEhSIEQiCIIgp+IAdC/////w+DIgcgBEL/////D4MiBH6FIAcgCn4gBCAJfoVCIImFIQQgAEEgaikAACAIhSIHQiCIIgkgACkAACADhSIDQiCIIgp+IAdC/////w+DIgcgA0L/////D4MiA36FIAcgCn4gAyAJfoVCIImFIQMgAEFAayEAIAtBQGsiCw0ACwsgBCAFhSEFIAMgBoUhBgJAAkAgAUE/cSIARQ0AIAFBECAAIABBEE0bIgtrIQAgAUEQSQ0BIAAgDGoiACAAIAtBD3EiAWoiDCALQTBxIgtqIg5PDQAgDCALQRBrIg9qIhApAAggCIUiA0IgiCIEIAApAAggBYUiBUIgiCIHfiADQv////8PgyIDIAVC/////w+DIgV+hSADIAd+IAQgBX6FQiCJhSEFIBApAAAgCIUiA0IgiCIEIAApAAAgBoUiBkIgiCIHfiADQv////8PgyIDIAZC/////w+DIgZ+hSADIAd+IAQgBn6FQiCJhSEGIA9FIAEgD3JBEUhyDQAgDCALQSBrIgtqIgwpAAggCIUiA0IgiCIEIAApABggBYUiBUIgiCIHfiADQv////8PgyIDIAVC/////w+DIgV+hSADIAd+IAQgBX6FQiCJhSEFIAwpAAAgCIUiA0IgiCIEIAApABAgBoUiBkIgiCIHfiADQv////8PgyIDIAZC/////w+DIgZ+hSADIAd+IAQgBn6FQiCJhSEGIAtFIAEgC3JBIUhyDQAgDkEoaykAACAIhSIDQiCIIgQgACkAKCAFhSIFQiCIIgd+IANC/////w+DIgMgBUL/////D4MiBX6FIAMgB34gBCAFfoVCIImFIQUgDkEwaykAACAIhSIDQiCIIgQgACkAICAGhSIGQiCIIgh+IANC/////w+DIgMgBkL/////D4MiBn6FIAMgCH4gBCAGfoVCIImFIQYLIAUgBoUMAQsgACABQcTtwAAQigMACwwCCyACKQMYIQYCQCABQXBxIgxFDQAgACABQQ9xaiELA0AgACALIAxqIgFPDQEgAUEIaykAACAGhSIFQiCIIgggAEEIaikAACAEhSIEQiCIIgd+IAVC/////w+DIgUgBEL/////D4MiBH6FIAUgB34gBCAIfoVCIImFIQQgAUEQaykAACAGhSIFQiCIIgggACkAACADhSIDQiCIIgd+IAVC/////w+DIgUgA0L/////D4MiA36FIAUgB34gAyAIfoVCIImFIQMgAEEQaiEAIAxBEGsiDA0ACwsgAyAEhQwBCyACKQMgIQQCQAJAIAFBB00EQCABQQNLDQEgAUUNAiAAIAFBAXZqMQAAIAAgAWpBAWsxAABCCIaEIASFIQQgAyAAMQAAhSEDDAILIAApAAAgA4UhAyAAIAFqQQhrKQAAIASFIQQMAQsgAyAANQAAhSEDIAQgACABakEEazUAAIUhBAsgA0IgiCIGIARCIIgiBX4gA0L/////D4MiAyAEQv////8PgyIEfoUgBCAGfiADIAV+hUIgiYULIgM3AxACfyACLQA4IgBB+ABNBEBCACEDQv8BIQQCQCAAQcAAcUUEQCAARQ0BQgAgAEE/ca0iBIZC/wFBACAAa0E/ca2IhCEDQv8BIASGIQQMAQtC/wEgAEE/ca2GIQNCACEECyANIAQ3AwAgDSADNwMIIAIpAwggDSkDCIQhAyACKQMAIA0pAwCEIQQgAEEIagwBCyACIAIpAxggAikDCIUiBEIgiCIGIAMgAikDAIUiA0IgiCIFfiAEQv////8PgyIEIANC/////w+DIgN+hSAEIAV+IAMgBn6FQiCJhTcDEEIAIQNC/wEhBEEICyEAIAIgBDcDACACIAA6ADggAiADNwMIIA1BEGokAAvzAwEGfyMAQRBrIgckAAJAAkACQAJAAkACQANAIAEoAgghBSABEFggASgCCCIDIAEoAgQiBEYNAyADIARPDQQgASgCACIIIANqLQAAIgRB3ABHBEAgBEEiRg0DIAEgA0EBajYCCCAHQRA2AgQgACABIAdBBGoQkQIMBwsgAyAFSQ0BIAMgBWsiBCACKAIAIAIoAggiBmtLBEAgAiAGIAQQtAEgAigCCCEGCyAEBEAgAigCBCAGaiAFIAhqIAT8CgAACyABIANBAWo2AgggAiAEIAZqNgIIIAFBASACEGMiA0UNAAsgAEECNgIAIAAgAzYCBAwFCyAFIANB4M/DABCMAwALIAIoAggiBEUNAiADIAVJBEAgBSADQdDPwwAQjAMACyADIAVrIgYgAigCACAEa0sEQCACIAQgBhC0ASACKAIIIQQLIAYEQCACKAIEIARqIAUgCGogBvwKAAALIAEgA0EBajYCCCACIAQgBmoiATYCCCAAIAE2AgggAEEBNgIAIAAgAigCBDYCBAwDCyAHQQQ2AgQgACABIAdBBGoQkQIMAgsgAyAEQbDPwwAQ9gEACyADIAVJBEAgBSADQcDPwwAQjAMACyAAQQA2AgAgACADIAVrNgIIIAAgBSAIajYCBCABIANBAWo2AggLIAdBEGokAAvHAwINfgN/IAAgACgCKCABKAADQQJ2Qf///x9xaq0iAyAAKAIUIhCtIgt+IAAoAiQgASgAAEH///8fcWqtIgUgACgCGCIRrSINfnwgACgCLCABKAAGQQR2Qf///x9xaq0iBiAANQIQIgd+fCAAKAIwIAEoAAlBBnZqrSIIIAAoAiAiEkEFbK0iBH58IAAoAjRBAEGAgIAIIAIbaiABKAAMQQh2aq0iCSAAKAIcIgFBBWytIgp+fCADIAd+IAUgC358IAQgBn58IAggCn58IAkgEUEFbK0iDH58IAMgBH4gBSAHfnwgBiAKfnwgCCAMfnwgCSAQQQVsrX58IgpCGohC/////w+DfCIMQhqIQv////8Pg3wiDqdB////H3E2AiwgACADIA1+IAUgAa0iD358IAYgC358IAcgCH58IAQgCX58IA5CGohC/////w+DfCIEp0H///8fcTYCMCAAIAMgD34gBSASrX58IAYgDX58IAggC358IAcgCX58IARCGohC/////w+DfCIDp0H///8fcTYCNCAAIANCGoinQQVsIAqnQf///x9xaiIBQf///x9xNgIkIAAgDKdB////H3EgAUEadmo2AigL4AMCGH4BfyABMQAFIQggATEABCEJIAExABUhCiABMQAUIQsgATEACCEMIAExAAchDSABMQAGIQIgATEACyEOIAExAAohDyABMQAJIQMgATEADyEQIAExAA4hESABMQANIRIgATEADCEEIAExABghEyABMQAXIRQgATEAFiEFIAExABshFSABMQAaIRYgATEAGSEGIAExAB8hFyABMQAeIRggATEAHSEZIAExABwhByABKAAAIRogACABKAAQIgFB////D3E2AhQgACAaQf///x9xNgIAIAAgF0IShkKAgPAPgyAZQgKGIAdCBoiEIBhCCoaEhD4CJCAAIAdCFIZCgIDAH4MgFkIEhiAGQgSIhCAVQgyGhIQ+AiAgACAGQhWGQoCAgA+DIBRCBYYgBUIDiIQgE0INhoSEPgIcIAAgEkIChiAEQgaIhCARQgqGhCAQQhKGhD4CECAAIARCE4ZCgIDgD4MgD0IDhiAD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OgAAIANBAWohAwwFCyAJQX9GDQQgCUF/cyIFRQ0EIApBAWpBMCAF/AsADAQLIABBADYCAA8LIABBADYCAA8LIAMgAkHg2sQAEIsDAAsgAyACQcDaxAAQiwMACyACIANPDQAgAyACQdDaxAAQiwMACyAAIAQ7AQggACADNgIEIAAgATYCAA8LIABBADYCAAunAwECfwJAAkACQAJAIAAtAGgiAwRAIANBwQBPDQMgAkHAACADayIEIAIgBEkbIgQEQCAAIANqIAEgBPwKAAALIAAgAC0AaCAEaiIDOgBoIAEgBGohASACIARrIgJFBEBBACECDAILIABBQGsgAEHAACAAKQNgIAAtAGogAC0AaUVyECIgAEIANwMAIABBADoAaCAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgACAALQBpQQFqOgBpC0EAIQMgAkHBAEkNASAAQUBrIQQgAC0AaSEDA0AgBCABQcAAIAApA2AgAC0AaiADQf8BcUVyECIgACAALQBpQQFqIgM6AGkgAUFAayEBIAJBQGoiAkHAAEsNAAsgAC0AaCEDCyADQf8BcSIDQcEATw0CCyACQcAAIANrIgQgAiAESRsiAgRAIAAgA2ogASAC/AoAAAsgACAALQBoIAJqOgBoIAAPCyADQcAAQYzowAAQigMACyADQcAAQYzowAAQigMAC98CAQd/IwBB0AFrIgIkACACQYABaiIDIAFB0ABqEDEgAkHQAGogAkGgAWopAgA3AwAgAkHIAGogAkGYAWopAgA3AwAgAkFAayIHIAJBkAFqKQIANwMAIAJBOGoiCCACQYgBaikCADcDACACIAIpAoABNwMwIAJB+ABqIAJByAFqKQIANwMAIAJB8ABqIAJBwAFqKQIANwMAIAJB6ABqIAJBuAFqKQIANwMAIAJB4ABqIAJBsAFqKQIANwMAIAIgAikCqAE3A1ggAyACQTBqIgRBBRBPIAJBCGoiBSADIAJB2ABqIgYQNCAGIAEgBRA0IAMgAUEoaiAFEDQgBCADEEkgAEEXaiACQccAaikAADcAACAAQRBqIAcpAAA3AAAgAEEIaiAIKQAANwAAIAAgAikAMDcAACACLQBPIQEgBCAGEEkgACABIAItADBB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IABBADoADSAAQQA6AA4gAEEAOgAPIABBADoAECAAQQA6ABEgAEEAOgASIABBADoAEyAAQQA6ABQgAEEAOgAVIABBADoAFiAAQQA6ABcgAEEAOgAYIABBADoAGSAAQQA6ABogAEEAOgAbIABBADoAHCAAQQA6AB0gAEEAOgAeIABBADoAHyAAQQA6ACAgAEEAOgAhIABBADoAIiAAQQA6ACMgAEEAOgAkIABBADoAJSAAQQA6ACYgAEEAOgAnIABBADoAKCAAQQA6ACkgAEEAOgAqIABBADoAKyAAQQA6ACwgAEEAOgAtIABBADoALiAAQQA6AC8gAEEAOgAwIABBADoAMSAAQQA6ADIgAEEAOgAzIABBADoANCAAQQA6ADUgAEEAOgA2IABBADoANyAAQQA6ADggAEEAOgA5IABBADoAOiAAQQA6ADsgAEEAOgA8IABBADoAPSAAQQA6AD4gAEEAOgA/C6UjAht/CH4jAEGAAmsiBSQAIAVBhAFqIQgjAEGgAmsiAyQAIANBCGoiAiABEG8gA0HQAGoiGUHoscEAKQIANwMAIANByABqIhpB4LHBACkCADcDACADQUBrIhtB2LHBACkCADcDACADQThqIhxB0LHBACkCADcDACADQcixwQApAgA3AzAgA0HQAWoiCyACEFIgAyADKQOAAiADKQP4ASADKQPwASIdQhqIfCIhQhmIfCIep0H///8fcTYCcCADIAMpA+ABIAMpA9gBIAMpA9ABIiJCGoh8IiBCGYh8Ih+nQf///x9xNgJgIAMgAykDiAIgHkIaiHwiHqdB////D3E2AnQgAyADKQPoASAfQhqIfCIfp0H///8PcTYCZCADIAMpA5ACIB5CGYh8Ih6nQf///x9xNgJ4IAMgIUL///8PgyAdQv///x+DIB9CGYh8Ih1CGoh8PgJsIAMgHadB////H3E2AmggAyADKQOYAiAeQhqIfCIdp0H///8PcTYCfCADICBC////D4MgHUIZiEITfiAiQv///x+DfCIdQhqIfD4CXCADIB2nQf///x9xNgJYIANBgAFqIgcgA0HYAGoiAiADQTBqEHggCyACQZCywQAQNCAcKAIAIQIgGygCACEEIBooAgAhBiAZKAIAIQkgAygCMCEKIAMoAtABIQwgAygCNCENIAMoAtQBIQ4gAygC2AEhDyADKAI8IRAgAygC3AEhESADKALgASESIAMoAkQhFSADKALkASETIAMoAugBIRQgAygCTCEWIAMoAuwBIRcgAygC8AEhGCADIAMoAlQgAygC9AFqNgLMASADIAkgGGo2AsgBIAMgFiAXajYCxAEgAyAGIBRqNgLAASADIBMgFWo2ArwBIAMgBCASajYCuAEgAyAQIBFqNgK0ASADIAIgD2o2ArABIAMgDSAOajYCrAEgAyAKIAxqNgKoASMAQfACayICJAAgAkGgAmoiBCADQagBaiIKEFIgAiACKQPQAiACKQPIAiACKQPAAiIdQhqIfCIhQhmIfCIep0H///8fcTYCkAIgAiACKQOwAiACKQOoAiACKQOgAiIiQhqIfCIgQhmIfCIfp0H///8fcTYCgAIgAiACKQPYAiAeQhqIfCIep0H///8PcTYClAIgAiACKQO4AiAfQhqIfCIfp0H///8PcTYChAIgAiACKQPgAiAeQhmIfCIep0H///8fcTYCmAIgAiAhQv///w+DIB1C////H4MgH0IZiHwiHUIaiHw+AowCIAIgHadB////H3E2AogCIAIgAikD6AIgHkIaiHwiHadB////D3E2ApwCIAIgIEL///8PgyAdQhmIQhN+ICJC////H4N8Ih1CGoh8PgL8ASACIB2nQf///x9xNgL4ASACQQhqIgkgAkH4AWoiBiAKEDQgBCAJEFIgAiACKQPQAiACKQPIAiACKQPAAiIdQhqIfCIhQhmIfCIep0H///8fcTYCkAIgAiACKQOwAiACKQOoAiACKQOgAiIiQhqIfCIgQhmIfCIfp0H///8fcTYCgAIgAiACKQPYAiAeQhqIfCIep0H///8PcTYClAIgAiACKQO4AiAfQhqIfCIfp0H///8PcTYChAIgAiACKQPgAiAeQhmIfCIep0H///8fcTYCmAIgAiAhQv///w+DIB1C////H4MgH0IZiHwiHUIaiHw+AowCIAIgHadB////H3E2AogCIAIgAikD6AIgHkIaiHwiHadB////D3E2ApwCIAIgIEL///8PgyAdQhmIQhN+ICJC////H4N8Ih1CGoh8PgL8ASACIB2nQf///x9xNgL4ASACQTBqIgwgBiAKEDQgAkGAAWoiDSAHIAkQNCACQdABaiIJIAcgDBA0IAQgCRAxIAJBmAJqIAJBwAJqKQIANwMAIAJBkAJqIAJBuAJqKQIANwMAIAJBiAJqIAJBsAJqKQIANwMAIAJBgAJqIAJBqAJqKQIANwMAIAIgAikCoAI3A/gBIAQgBkECEE8gAkGoAWoiDCAJIAQQNCACQdgAaiIOIA0gDBA0IAQgDhBSIAIgAikD0AIgAikDyAIgAikDwAIiHUIaiHwiIUIZiHwiHqdB////H3E2ApACIAIgAikDsAIgAikDqAIgAikDoAIiIkIaiHwiIEIZiHwiH6dB////H3E2AoACIAIgAikD2AIgHkIaiHwiHqdB////D3E2ApQCIAIgAikDuAIgH0IaiHwiH6dB////D3E2AoQCIAIgAikD4AIgHkIZiHwiHqdB////H3E2ApgCIAIgIUL///8PgyAdQv///x+DIB9CGYh8Ih1CGoh8PgKMAiACIB2nQf///x9xNgKIAiACIAIpA+gCIB5CGoh8Ih2nQf///w9xNgKcAiACICBC////D4MgHUIZiEITfiAiQv///x+DfCIdQhqIfD4C/AEgAiAdp0H///8fcTYC+AEgCSAKIAYQNCAGIAkQSSAEIAcQSUEAIQRBASEGA0AgAkH4AWoiCSAEai0AACACQaACaiIKIARqLQAARhD0AiAGcSEGIARBAWoiBEEgRw0ACyAGEPQCIRcgAkHw////AyAHKAIYa61B8P///wEgBygCFGutQfD///8DIAcoAhBrrSIdQhqIfCIhQhmIfCIep0H///8fcSIMNgK4AiACQfD///8DIAcoAghrrUHw////ASAHKAIEa61B0P3//wMgBygCAGutIiJCGoh8IiBCGYh8Ih+nQf///x9xIg02AqgCIAJB8P///wEgBygCHGutIB5CGoh8Ih6nQf///w9xIg42ArwCIAJB8P///wEgBygCDGutIB9CGoh8Ih+nQf///w9xIg82AqwCIAJB8P///wMgBygCIGutIB5CGYh8Ih6nQf///x9xIhA2AsACIAIgHUL///8fgyAfQhmIfCIdp0H///8fcSIRNgKwAiACICFC////D4MgHUIaiHynIhI2ArQCIAJB8P///wEgBygCJGutIB5CGoh8Ih2nQf///w9xIhU2AsQCIAIgHUIZiEITfiAiQv///x+DfCIdp0H///8fcSITNgKgAiACICBC////D4MgHUIaiHynIhQ2AqQCIAJBqAFqIAJB0AFqEEkgCSAKEElBACEEQQEhBgNAIAJBqAFqIgkgBGotAAAgAkH4AWoiByAEai0AAEYQ9AIgBnEhBiAEQQFqIgRBIEcNAAsgBhD0AiEWIAIgFTYCxAIgAiAQNgLAAiACIA42ArwCIAIgDDYCuAIgAiASNgK0AiACIBE2ArACIAIgDzYCrAIgAiANNgKoAiACIBQ2AqQCIAIgEzYCoAIgByACQaACakHA9MAAEDQgAkGAAWogAkHQAWoQSSAJIAcQSUEAIQRBASEGA0AgAkGAAWogBGotAAAgAkGoAWogBGotAABGEPQCIAZxIQYgBEEBaiIEQSBHDQALIAYQ9AIhBCACQaACakHA9MAAIAJB2ABqIhgQNCACQeAAaiIHQQAgBCAWchD0AkH/AXFrIgQgBygCACIGIAIoAqgCc3EgBnMiBjYCACACQegAaiIJIAkoAgAiCiACKAKwAnMgBHEgCnMiCjYCACACQfAAaiIMIAwoAgAiDSACKAK4AnMgBHEgDXMiDTYCACACIAIoAmQiDiACKAKsAnMgBHEgDnMiDjYCZCACIAIoAlwiDyACKAKkAnMgBHEgD3MiDzYCXCACIAIoAlgiECACKAKgAnMgBHEgEHMiEDYCWCACIAIoAmwiESACKAK0AnMgBHEgEXMiETYCbCACIAIoAnQiEiACKAK8AnMgBHEgEnMiEjYCdCACQfgAaiIVIBUoAgAiEyACKALAAnMgBHEgE3MiEzYCACACIAQgAigCfCIUIAIoAsQCc3EgFHMiFDYCfCACQfgBaiAYEEkgFUEAIAItAPgBQQFxEPQCQf8BcWsiBEHw////AyATa61B8P///wEgEmutQfD///8DIA1rrUHw////ASARa61B8P///wMgCmutIh1CGoh8IiFCGYh8Ih5CGoh8IiJCGYh8IiCnQf///x9xIBNzcSATczYCACAMIB6nQf///x9xIA1zIARxIA1zNgIAIAkgHUL///8fg0Hw////ASAOa61B8P///wMgBmutQfD///8BIA9rrUHQ/f//AyAQa60iHUIaiHwiHkIZiHwiH0IaiHwiI0IZiHwiJKdB////H3EgCnMgBHEgCnM2AgAgByAfp0H///8fcSAGcyAEcSAGczYCACACQfD///8BIBRrrSAgQhqIfCIgp0H///8PcSAUcyAEcSAUczYCfCACICKnQf///w9xIBJzIARxIBJzNgJ0IAIgESAhQv///w+DICRCGoh8p3MgBHEgEXM2AmwgAiAjp0H///8PcSAOcyAEcSAOczYCZCACICBCGYhCE34gHUL///8fg3wiHadB////H3EgEHMgBHEgEHM2AlggAiAPIB5C////D4MgHUIaiHyncyAEcSAPczYCXCALIBYgF3IQ9AI6AAAgCyACKQJYNwIEIAtBDGogBykCADcCACALQRRqIAkpAgA3AgAgC0EcaiAMKQIANwIAIAtBJGogFSkCADcCACACQfACaiQAIAggAykC1AE3AgAgCEEIaiADQdwBaikCADcCACAIQRBqIANB5AFqKQIANwIAIAhBGGogA0HsAWopAgA3AgAgCEEgaiADQfQBaikCADcCACAIIAMtANABOgBQIAggAykCCDcCKCAIQTBqIANBEGopAgA3AgAgCEE4aiADQRhqKQIANwIAIAhBQGsgA0EgaikCADcCACAIQcgAaiADQShqKQIANwIAIAggAykDMDcCVCAIQdwAaiAcKQMANwIAIAhB5ABqIBspAwA3AgAgCEHsAGogGikDADcCACAIQfQAaiAZKQMANwIAIANBoAJqJAAgBUEQaiAFQYwBaikCADcDACAFQRhqIAVBlAFqKQIANwMAIAVBIGogBUGcAWopAgA3AwAgBUEoaiAFQaQBaikCADcDACAFQThqIAVBtAFqKQIANwMAIAVBQGsgBUG8AWopAgA3AwAgBUHIAGogBUHEAWopAgA3AwAgBUHQAGogBUHMAWopAgA3AwAgBSAFKQKEATcDCCAFIAUpAqwBNwMwIAUtANQBIQIgBUH4AGogBUH4AWopAgA3AwAgBUHwAGogBUHwAWopAgA3AwAgBUHoAGogBUHoAWopAgA3AwAgBUHgAGogBUHgAWopAgA3AwAgBSAFKQLYATcDWCAAIAIEfyMAQTBrIgIkACABLQAfQQd2EPQCIQMgAkEIaiAFQQhqIgEQkgEgAUEAIANB/wFxayIDIAEoAgAiCCACKAIIc3EgCHM2AgAgASABKAIEIgggAigCDHMgA3EgCHM2AgQgAUEIaiIIIAgoAgAiBCACKAIQcyADcSAEczYCACABIAEoAgwiBCACKAIUcyADcSAEczYCDCABQRBqIgQgBCgCACIHIAIoAhhzIANxIAdzNgIAIAEgASgCFCIHIAIoAhxzIANxIAdzNgIUIAFBGGoiByAHKAIAIgYgAigCIHMgA3EgBnM2AgAgASABKAIcIgYgAigCJHMgA3EgBnM2AhwgAUEgaiIGIAYoAgAiCyACKAIocyADcSALczYCACABIAMgASgCJCILIAIoAixzcSALczYCJCAAQQRqIgBBIGogBikCADcCACAAQRhqIAcpAgA3AgAgAEEQaiAEKQIANwIAIABBCGogCCkCADcCACAAIAEpAgA3AgAgAEH4AGogASAFQTBqIgEQNCAAQcgAaiABQSBqKQIANwIAIABBQGsgAUEYaikCADcCACAAQThqIAFBEGopAgA3AgAgAEEwaiABQQhqKQIANwIAIAAgASkCADcCKCAAIAVB2ABqIgEpAgA3AlAgAEHYAGogAUEIaikCADcCACAAQeAAaiABQRBqKQIANwIAIABB6ABqIAFBGGopAgA3AgAgAEHwAGogAUEgaikCADcCACACQTBqJABBAQVBAAs2AgAgBUGAAmokAAugAwECfyMAQSBrIgckAAJAIAAoAgAiCCABIAIgACgCBCgCDCIBEQEABEBBASECDAELAkAgAC0ACkGAAXFFBEBBASECIAhB2d/EAEEBIAERAQANAiADIAAgBCgCDBEAAEUNAQwCCyAIQdrfxABBAiABEQEABEBBASECDAILQQEhAiAHQQE6AA8gB0Gw38QANgIUIAcgACkCADcCACAHIAApAgg3AhggByAHQQ9qNgIIIAcgBzYCECADIAdBEGogBCgCDBEAAA0BIAcoAhBB1N/EAEECIAcoAhQoAgwRAQANAQsCQCAALQAKQYABcUUEQCAAKAIAQc/fxABBAiAAKAIEKAIMEQEABEAMAwsgBSAAIAYoAgwRAABFDQEMAgsgB0EBOgAPIAdBsN/EADYCFCAHIAApAgA3AgAgByAAKQIINwIYIAcgB0EPajYCCCAHIAc2AhAgBSAHQRBqIAYoAgwRAAANASAHKAIQQdTfxABBAiAHKAIUKAIMEQEADQELIAAoAgBBuNzEAEEBIAAoAgQoAgwRAQAhAgsgB0EgaiQAIAIL+wICAX4IfyMAQYACayIDJAAgACgCBCECIAAoAgAhBCAAQeCowAApAgA3AgAgACgCDCEHIABBCGpB6KjAACkCADcCACAHBEAgBEEIaiEFIAQpAwBCf4VCgIGChIiQoMCAf4MhASAEIQgDQCABUARAA0AgCEFAaiEIIAUpAwAgBUEIaiEFQoCBgoSIkKDAgH+DIgFCgIGChIiQoMCAf1ENAAsgAUKAgYKEiJCgwIB/hSEBCyADQQxqIAggAXqnQfgAcWtBBGsoAgAiCUH0AfwKAAAgCUH0AUEEEIcDIAMoAuwBIgkEQCADKALwASAJQQEQhwMLIAFCAX0gAYMhASADQQxqEM0BIAdBAWsiBw0ACwsgAgRAIAJBCWoiBQRAIARB/wEgBfwLAAsgAiACQQFqQQN2QQdsIAJBCEkbIQYLIABBADYCDCAAIAY2AgggACACNgIEIAAgBDYCACAAKAIcQfQBQQQQhwMgACgCIEH0AUEEEIcDIANBgAJqJAALggMBBH8gACgCDCECAkACQAJAIAFBgAJPBEAgACgCGCEDAkACQCAAIAJGBEAgAEEUQRAgACgCFCICG2ooAgAiAQ0BQQAhAgwCCyAAKAIIIgEgAjYCDCACIAE2AggMAQsgAEEUaiAAQRBqIAIbIQQDQCAEIQUgASICQRRqIAJBEGogAigCFCIBGyEEIAJBFEEQIAEbaigCACIBDQALIAVBADYCAAsgA0UNAgJAIAAoAhxBAnRB/PfEAGoiASgCACAARwRAIAMoAhAgAEYNASADIAI2AhQgAg0DDAQLIAEgAjYCACACRQ0EDAILIAMgAjYCECACDQEMAgsgACgCCCIAIAJHBEAgACACNgIMIAIgADYCCA8LQZT7xABBlPvEACgCAEF+IAFBA3Z3cTYCAA8LIAIgAzYCGCAAKAIQIgEEQCACIAE2AhAgASACNgIYCyAAKAIUIgBFDQAgAiAANgIUIAAgAjYCGA8LDwtBmPvEAEGY+8QAKAIAQX4gACgCHHdxNgIAC70CAgZ/BH4jAEGwAmsiAyQAIANBCGpBAEGAAvwLACADQZACaiABQQhqKQAANwMAIANBmAJqIAFBEGopAAA3AwAgA0GgAmogAUEYaikAADcDACADQgA3A6gCIAMgASkAADcDiAJBwAAgAmshBkIBIAJBP3GthiIJQgGIIQsgCUIBfSEMIAmnIQcDQEEAIARrIQEDQCADQYgCaiAEQQN2Qfj///8BcWoiBSkDACAEQT9xIgitiCEJAkAgBiAITQR+IAUpAwggAUE/ca2GIAmEBSAJCyAMgyAKfCIJpyIFQQFxBEAgA0EIaiAEaiAFIAdBACAJIAtaIgQbazoAACAErSEKIAIgAWsiBEGAAkkNAwwBCyABQQFrIQEgBEEBaiIEQYACRw0BCwsLIAAgA0EIakGAAvwKAAAgA0GwAmokAAvgAgIDfwN+IwBBkAJrIgAkACAAQcABakIANwMAIABBuAFqQgA3AwAgAEGwAWpCADcDACAAQagBakIANwMAIABBoAFqQgA3AwAgAEGYAWpCADcDACAAQZABakIANwMAIABB0AFqQZiwwAApAgAiAzcDACAAQdgBakGgsMAAKQIAIgQ3AwAgAEHgAWpBqLDAACkCACIFNwMAIABBIGogBTcDACAAQRhqIAQ3AwAgAEEQaiADNwMAIABCADcDiAEgAEGQsMAAKQIAIgM3A8gBIAAgAzcDCCAAQShqIABBiAFqIgJB4AD8CgAAIABBjAFqIABBCGpBgAH8CgAAQZAPQQgQ+gIiAQRAIAFBADYCCCABQoGAgIAQNwMAIAFBDGogAkGEAfwKAAAgAUGXAWpBADYAACABQgA3A5ABIAFBADYCqAEgAUIANwOgASAAQZACaiQAIAFBCGoPC0EIQZAPEKwDAAv2AgICfwN+IwBB4A9rIgMkACADQQhqQazawAApAgAiBTcDACADQRBqQbTawAApAgAiBjcDACADQRhqQbzawAApAgAiBzcDACADQbgPakIANwMAIANBsA9qQgA3AwAgA0GoD2pCADcDACADQaAPakIANwMAIANBmA9qQgA3AwAgA0GQD2pCADcDACADQYgPakIANwMAIANByA9qIAU3AwAgA0HQD2ogBjcDACADQdgPaiAHNwMAIANBpNrAACkCACIFNwMAIANCADcDgA8gAyAFNwPADyADQSBqIANBgA9qIgRB4AD8CgAAIANBhwFqQQA2AAAgA0IANwOAASADQQA2ApgBIANCADcDkAEgAyABIAIQKSAEIAMQyQFBGEEBEPoCIgFFBEBBAUEYQfjUwAAQ4gIACyABIAMpAIAPNwAAIAFBEGogA0GQD2opAAA3AAAgAUEIaiADQYgPaikAADcAACAAQRg2AgQgACABNgIAIANB4A9qJAAL7wIBA38gACgCACIBKAKoAQRAIAFBADYCqAELIAEoApwQIgIEQCABKAKYECEAA0AgACgCACIDBEAgAEEEaigCACADQQEQhwMLIABBDGohACACQQFrIgINAAsLIAEoApQQIgAEQCABKAKYECAAQQxsQQQQhwMLIAEoAogQIgBBgICAgHhGIABFckUEQCABKAKMECAAQQEQhwMLIAEoAvAPIgAEQCABKAL0DyAAQQEQhwMLIAEoAvwPIgAEQCABKAKAECAAQQEQhwMLIAFBmA9qIgIQkwECQCABKAKcDyIARQ0AIAAgAEEDdEEPakF4cSIDakEJaiIARQ0AIAIoAgAgA2sgAEEIEIcDCyABQcgPaiICEIQBAkAgASgCzA8iAEUNACAAIABBA3RBD2pBeHEiA2pBCWoiAEUNACACKAIAIANrIABBCBCHAwsCQCABQX9GDQAgASABKAIEQQFrIgA2AgQgAA0AIAFB6BFBCBCHAwsL+AICBH8BfiMAQcACayIDJAACQAJAIAJBIEYEQCADQeIBaiABQQJqLQAAIgI6AAAgA0H/AWogAUEfaiIELQAAOgAAIANBAmogAjoAACADIAEvAAAiAjsB4AEgAyABKQAXNwD3ASADIAI7AQAgAyABKAADIgI2AAMgAyABKAAHIgU2AAcgAyABKAALIgY2AAsgAyABKQAPIgc3AA8gA0EfaiAELQAAOgAAIAMgASkAFzcAFyADQYACaiIBIAMQOSADQSBqIgQgARCpAiABEMoBIAMgBzcA7wEgAyAGNgDrASADIAU2AOcBIAMgAjYA4wFBIEEBEPoCIgFFDQEgASADKQIgNwAAIABBIDYCCCAAIAE2AgQgAEEKNgIAIAFBGGogA0E4aikCADcAACABQRBqIANBMGopAgA3AAAgAUEIaiADQShqKQIANwAAIAQQzQEMAgsgACACNgIIIABCgICAgIAENwIADAELQQFBIBCsAwALIANBwAJqJAAL8gIBAX8CQCACBEAgAS0AAEEwTQ0BIAVBAjsBAAJAAkACQAJAAkAgA8EiBkEASgRAIAUgATYCBCACIANB//8DcSIDSw0BIAVBADsBDCAFIAI2AgggBSADIAJrNgIQIAQNAkECIQEMBQsgBSACNgIgIAUgATYCHCAFQQI7ARggBUEAOwEMIAVBAjYCCCAFQfXbxAA2AgQgBUEAIAZrIgM2AhBBAyEBIAIgBE8NBCAEIAJrIgIgA00NBCACIAZqIQQMAwsgBUECOwEYIAVBATYCFCAFQfTbxAA2AhAgBUECOwEMIAUgAzYCCCAFIAIgA2siAjYCICAFIAEgA2o2AhwgAiAESQ0BQQMhAQwDCyAFQQE2AiAgBUH028QANgIcIAVBAjsBGAwBCyAEIAJrIQQLIAUgBDYCKCAFQQA7ASRBBCEBCyAAIAE2AgQgACAFNgIADwtB8NjEAEEhQYDbxAAQoAIAC0GQ28QAQR9BsNvEABCgAgAL0C4CLX8QfiMAQeAAayIGJAACQCACQSBGBEAgBEEgRgRAIAEpAAMhMiABKAALIQIgASkADyE0IAZBImogA0ECai0AADoAACAGQT9qIANBH2otAAA6AAAgBiADLwAAOwEgIAYgAykAFzcANyADKQADITMgAygACyEEIAMpAA8hNSAGQQJqIAFBAmotAAA6AAAgBkEfaiABQR9qLQAAOgAAIAYgNDcADyAGIAI2AAsgBiAyNwADIAYgAS8AADsBACAGIAEpABc3ABcgBiA1NwAvIAYgBDYAKyAGIDM3ACMjAEEgayIsJAAgLEEYaiAGQSBqIgFBGGopAAA3AwAgLEEQaiABQRBqKQAANwMAICxBCGogAUEIaikAADcDACAsIAEpAAA3AwAjAEEgayIqJAAgKkEJaiAGQQlqKQAANwAAICpBEWogBkERaikAADcAACAqQRdqIAZBF2opAAA3AAAgKiAGKQABNwABICogBi0AAEH4AXE6AAAgKiAGLQAfQT9xQcAAcjoAHyAGQUBrIS9BACECIwBBoANrIgMkACADQQhqICwQbyADQdAAakGQo8MAKQIAIjI3AwAgA0HIAGpBiKPDACkCACI0NwMAIANBQGtBgKPDACkCACIzNwMAIANBOGpB+KLDACkCACI1NwMAIANB4ABqQgA3AwAgA0HoAGpCADcDACADQfAAakIANwMAIANB+ABqQgA3AwAgA0HwosMAKQIAIjc3AzAgA0IANwNYIANBoAFqIANBKGopAgA3AwAgA0GYAWogA0EgaikCADcDACADQZABaiADQRhqKQIANwMAIANBiAFqIANBEGopAgA3AwAgA0GwAWogNTcDACADQbgBaiAzNwMAIANBwAFqIDQ3AwAgA0HIAWogMjcDACADIAMpAgg3A4ABIAMgNzcDqAEgA0EAOgDXASADQQE2AtwCIANCgICAgIAgNwLUAiADICo2AtACIANB2ABqITBBASEHAkACQANAAkACQCAHRQRAIAMoAtgCIgEgAygC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NgK4ASACIAIpA5AFIAIpA4gFIAIpA4AFIjVCGoh8IjdCGYh8IjanQf///x9xNgKoASACIAIpA7gFIDNCGoh8IjOnQf///w9xNgK8ASACIAIpA5gFIDZCGoh8IjanQf///w9xNgKsASACIAIpA8AFIDNCGYh8IjOnQf///x9xNgLAASACIDRC////D4MgMkL///8fgyA2QhmIfCIyQhqIfD4CtAEgAiAyp0H///8fcTYCsAEgAiACKQPIBSAzQhqIfCIyp0H///8PcTYCxAEgAiA3Qv///w+DIDJCGYhCE34gNUL///8fg3wiMkIaiHw+AqQBIAIgMqdB////H3E2AqABIAcgCBBSIAIgAikDsAUgAikDqAUgAikDoAUiMkIaiHwiNEIZiHwiM6dB////H3E2AuABIAIgAikDkAUgAikDiAUgAikDgAUiNUIaiHwiN0IZiHwiNqdB////H3E2AtABIAIgAikDuAUgM0IaiHwiM6dB////D3E2AuQBIAIgAikDmAUgNkIaiHwiNqdB////D3E2AtQBIAIgAikDwAUgM0IZiHwiM6dB////H3E2AugBIAIgNEL///8PgyAyQv///x+DIDZCGYh8IjJCGoh8PgLcASACIDKnQf///x9xNgLYASACIAIpA8gFIDNCGoh8IjKnQf///w9xNgLsASACIDdC////D4MgMkIZiEITfiA1Qv///x+DfCIyQhqIfD4CzAEgAiAyp0H///8fcTYCyAEgAkHwAWoiCSACQaABaiILIAJByAFqIgwQeCACQZgCaiINIAIgChA0IAJBwAJqIgogCCACQdAAahA0IAIoApgCIQggAigCwAIhDiACKAKcAiEPIAIoAsQCIRAgAigCoAIhESACKALIAiESIAIoAqQCIRMgAigCzAIhFCACKAKoAiEVIAIoAtACIRYgAigCrAIhFyACKALUAiEYIAIoArACIRkgAigC2AIhICACKAK0AiEnIAIoAtwCISggAigCuAIhKSACKALgAiErIAIgAigC5AIgAigCvAJqNgKMAyACICkgK2o2AogDIAIgJyAoajYChAMgAiAZICBqNgKAAyACIBcgGGo2AvwCIAIgFSAWajYC+AIgAiATIBRqNgL0AiACIBEgEmo2AvACIAIgDyAQajYC7AIgAiAIIA5qNgLoAiACQZADaiIIIA0gChB4IAcgAkHoAmoQUiACKQOYBSEzIAIpA5AFITUgAikDiAUhNyACKQOABSEyIAIpA8gFITYgAikDwAUhOiACKQO4BSE7IAIpA7AFITwgAikDqAUhPSACKQOgBSE0IAcgCBBSIAIgAikDsAUgAikDqAUgAikDoAUiOEIaiHwiP0IZiHwiOadB////H3E2AtADIAIgAikDkAUgAikDiAUgAikDgAUiQEIaiHwiQUIZiHwiPqdB////H3E2AsADIAIgAikDuAUgOUIaiHwiOadB////D3E2AtQDIAIgAikDmAUgPkIaiHwiPqdB////D3E2AsQDIAIgAikDwAUgOUIZiHwiOadB////H3E2AtgDIAIgP0L///8PgyA4Qv///x+DID5CGYh8IjhCGoh8PgLMAyACIDinQf///x9xNgLIAyACIAIpA8gFIDlCGoh8IjinQf///w9xNgLcAyACIEFC////D4MgOEIZiEITfiBAQv///x+DfCI4QhqIfD4CvAMgAiA4p0H///8fcTYCuAMgAkHgA2pBmKPDACAJEDQgAkGIBGogCyAMEDQgAigC4AMhCCACKALIASEKIAIoAuQDIQsgAigCzAEhDCACKALoAyENIAIoAtABIQ4gAigC7AMhDyACKALUASEQIAIoAvADIREgAigC2AEhEiACKAL0AyETIAIoAtwBIRQgAigC+AMhFSACKALgASEWIAIoAvwDIRcgAigC5AEhGCACKAKABCEZIAIoAugBISAgAiACKALsASACKAKEBGo2AqQFIAIgGSAgajYCoAUgAiAXIBhqNgKcBSACIBUgFmo2ApgFIAIgEyAUajYClAUgAiARIBJqNgKQBSACIA8gEGo2AowFIAIgDSAOajYCiAUgAiALIAxqNgKEBSACIAggCmo2AoAFIAJBsARqIAkgBxA0IAJB2ARqIANBCGogAkG4A2oQNCAmIAJBqARqKQIANwIAICQgAkGgBGopAgA3AgAgIiACQZgEaikCADcCACAbIAJBkARqKQIANwIAIAUgAikCiAQ3AgAgBSACKQKwBDcCKCAaIAJBuARqKQIANwIAICEgAkHABGopAgA3AgAgIyACQcgEaikCADcCACAlIAJB0ARqKQIANwIAIAQgNiA6IDsgPCA9IDRCGoh8Ij1CGYh8IjxCGoh8IjtCGYh8IjpCGoh8IjanQf///w9xNgIkIAQgOqdB////H3E2AiAgBCA7p0H///8PcTYCHCAEIDynQf///x9xNgIYIAQgPUL///8PgyA0Qv///x+DIDMgNSA3IDJCGoh8IjRCGYh8IjVCGoh8IjNCGYh8IjdCGoh8PgIUIAQgN6dB////H3E2AhAgBCAzp0H///8PcTYCDCAEIDWnQf///x9xNgIIIAQgNEL///8PgyA2QhmIQhN+IDJC////H4N8IjJCGoh8PgIEIAQgMqdB////H3E2AgAgBCACKQLYBDcCKCAcIAJB4ARqKQIANwIAIB0gAkHoBGopAgA3AgAgHiACQfAEaikCADcCACAfIAJB+ARqKQIANwIAIAJB0AVqJAAgAyABOgDXASADKALcAiEHIAEhAgwBCwsgAhD0AiEBIAMoAoABIQIgAygCMCEEIAMoAoQBIQUgAygCNCEHIAMoAogBIQggAygCOCEJIAMoAowBIRogAygCPCEbIAMoApABISEgAygCQCEiIAMoApQBISMgAygCRCEcIAMoApgBISQgAygCSCEdIAMoApwBISUgAygCTCEeIAMoAqABISYgAygCUCEKIAMoAqQBIR8gAygCVCELIAMoAqgBIQwgAygCWCENIAMoAqwBIQ4gAygCXCEPIAMoArABIRAgAygCYCERIAMoArQBIRIgAygCZCETIAMoArgBIRQgAygCaCEVIAMoArwBIRYgAygCbCEXIAMoAsABIRggAygCcCEZIAMoAsQBISAgAygCdCEnIAMoAsgBISggAygCeCEpIANBACABQf8BcWsiASADKALMASIrIAMoAnwiLXNxIi4gLXM2AnwgAyApICggKXMgAXEiLXM2AnggAyAnICAgJ3MgAXEiKXM2AnQgAyAZIBggGXMgAXEiJ3M2AnAgAyAXIBYgF3MgAXEiGXM2AmwgAyAVIBQgFXMgAXEiF3M2AmggAyATIBIgE3MgAXEiFXM2AmQgAyARIBAgEXMgAXEiE3M2AmAgAyAPIA4gD3MgAXEiEXM2AlwgAyANIAwgDXMgAXEiD3M2AlggAyALIAsgH3MgAXEiDXM2AlQgAyAKIAogJnMgAXEiC3M2AlAgAyAeIB4gJXMgAXEiCnM2AkwgAyAdIB0gJHMgAXEiHnM2AkggAyAcIBwgI3MgAXEiHXM2AkQgAyAiICEgInMgAXEiHHM2AkAgAyAbIBogG3MgAXEiInM2AjwgAyAJIAggCXMgAXEiG3M2AjggAyAHIAUgB3MgAXEiCXM2AjQgAyAEIAIgBHMgAXEiAXM2AjAgAyArIC5zNgLMASADICggLXM2AsgBIAMgICApczYCxAEgAyAYICdzNgLAASADIBYgGXM2ArwBIAMgFCAXczYCuAEgAyASIBVzNgK0ASADIBAgE3M2ArABIAMgDiARczYCrAEgAyAMIA9zNgKoASADIA0gH3M2AqQBIAMgCyAmczYCoAEgAyAKICVzNgKcASADIB4gJHM2ApgBIAMgHSAjczYClAEgAyAcICFzNgKQASADIBogInM2AowBIAMgCCAbczYCiAEgAyAFIAlzNgKEASADIAEgAnM2AoABIANBADoA1wEgA0HQAmoiASAwEDEgA0GgAmogA0HwAmopAgA3AwAgA0GYAmogA0HoAmopAgA3AwAgA0GQAmogA0HgAmopAgA3AwAgA0GIAmogA0HYAmopAgA3AwAgAyADKQLQAjcDgAIgA0HIAmogA0GYA2opAgA3AwAgA0HAAmogA0GQA2opAgA3AwAgA0G4AmogA0GIA2opAgA3AwAgA0GwAmogA0GAA2opAgA3AwAgAyADKQL4AjcDqAIgASADQYACakEFEE8gA0HYAWoiAiABIANBqAJqEDQgASADQTBqIAIQNCAvIAEQSSADQaADaiQADAELIAVBIEHgosMAEPYBAAsgKkEgaiQAICxBIGokACAAQQA6AAAgAEEZaiAGQdgAaikAADcAACAAQRFqIAZB0ABqKQAANwAAIABBCWogBkHIAGopAAA3AAAgACAGKQBANwABIAYQzAEgLxDMAQwCCyAAIAQ2AgwgAEKAgICAgAQ3AgQgAEEBOgAADAELIAAgAjYCDCAAQoCAgICABDcCBCAAQQE6AAALIAZB4ABqJAALkwMCBX8BbyMAQSBrIgEkACABQRhqQcCrwwAQvQEgASgCHCEDAkAgASgCGCIEQQFxBEAgAyECIAQhAAwBCyABQRBqQcSrwwAQvQEgASgCFCECIAEoAhAhACAERSADQYQBSXINACADENMBCwJAIABBAXEEQCACIQMgACEEDAELIAFBCGpBvKvDABC9ASABKAIMIQMgASgCCCEEIABFIAJBhAFJcg0AIAIQ0wELAkAgBEEBcQRAIAMhACAEIQIMAQsgAUHIq8MA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azYCBCAAIAIgA2o2AgAL6wIBBn4gAEHw////AyABKAIYa61B8P///wEgASgCFGutQfD///8DIAEoAhBrrSICQhqIfCIFQhmIfCIDp0H///8fcTYCGCAAQfD///8DIAEoAghrrUHw////ASABKAIEa61B0P3//wMgASgCAGutIgZCGoh8IgdCGYh8IgSnQf///x9xNgIIIABB8P///wEgASgCHGutIANCGoh8IgOnQf///w9xNgIcIABB8P///wEgASgCDGutIARCGoh8IgSnQf///w9xNgIMIABB8P///wMgASgCIGutIANCGYh8IgOnQf///x9xNgIgIAAgBUL///8PgyACQv///x+DIARCGYh8IgJCGoh8PgIUIAAgAqdB////H3E2AhAgAEHw////ASABKAIka60gA0IaiHwiAqdB////D3E2AiQgACAHQv///w+DIAJCGYhCE34gBkL///8fg3wiAkIaiHw+AgQgACACp0H///8fcTYCAAvUAgIBfgl/IAAoAgQhAiAAKAIAIQMgAEHgqMAAKQIANwIAIAAoAgwhBiAAQQhqQeiowAApAgA3AgAgBgRAIANBCGohBCADKQMAQn+FQoCBgoSIkKDAgH+DIQEgAyEHA0AgAVAEQANAIAdBQGohByAEKQMAIARBCGohBEKAgYKEiJCgwIB/gyIBQoCBgoSIkKDAgH9RDQALIAFCgIGChIiQoMCAf4UhAQsgByABeqdB+ABxa0EEaygCACIIKAIkIQogCCgCICEJIAhBNEEEEIcDIAkEQCAKIAlBARCHAwsgAUIBfSABgyEBIAZBAWsiBg0ACwsgAgRAIAJBCWoiBARAIANB/wEgBPwLAAsgAiACQQFqQQN2QQdsIAJBCEkbIQULIABBADYCDCAAIAU2AgggACACNgIEIAAgAzYCACAAKAIcQTRBBBCHAyAAKAIgQTRBBBCHAwugAgEDfyMAQZABayIDJAACfwJAIAEoAggiAkGAgIAQcUUEQCACQYCAgCBxDQEgA0EIaiAAKAIAIANBEGoQkQEgAUEBQQFBACADKAIIIAMoAgwQTQwCCyAAKAIAIQBBACECA0AgAiADakGPAWogAEEPcSIEQTByIARB1wBqIARBCkkbOgAAIAJBAWshAiAAQQ9LIABBBHYhAA0ACyABQQFB39/EAEECIAIgA2pBkAFqQQAg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aCABKQNYhSIpQiCIIiogASkDYCABKQNQhSIrQiCIIix+IClC/////w+DIikgK0L/////D4MiK36FICkgLH4gKiArfoVCIIiFCyIpp3EhBSApQhmIQv8Ag0KBgoSIkKDAgAF+IStBACETAkADQAJAIAIgBWopAAAiKiArhSIpQn+FIClCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiKVBFBEAgEigCACEUA0AgHSApeqdBA3YgBWogCnEiHkEDdCImaygCACInQQhqKAIAIBRGBEAgFygCACAnQQRqKAIAIBQQigJFDQMLIClCAX0gKYMiKVBFDQALCyAqICpCAYaDQoCBgoSIkKDAgH+DUEUNAiATQQhqIhMgBWogCnEhBQwBCwtBgAEhBSACICZBA3UiE2oiFCkAACIpIClCAYaDQoCBgoSIkKDAgH+DeqdBA3YgAiATQQhrIApxaiIKKQAAIikgKUIBhoNCgIGChIiQoMCAf4N5p0EDdmpBB00EQCABIAEoAhBBAWo2AhBB/wEhBQsgFCAFOgAAIApBCGogBToAACACQQAgHmtBA3RqQQRrKAIAIgIgETYCACACIAY2AhwgAiAJNgIYIAIgCzYCFCACIAc2AhAgAiAQNgIMIAIgFjYCCCACIA82AgQgAigCICELIAIoAiQhBSACIAEpAjQ3AiAgAkEoaiABQTxqKAIANgIAIAIoAiwgAigCMCIGNgIwIAYgAigCLDYCLCABIBpBAWs2AhQMAgtByKjAABCNAwALIAIgBjYCHCACIAk2AhggAiALNgIUIAIgBzYCECACIBA2AgwgAiAWNgIIIAIgDzYCBCACIBE2AgAgAiABKQI0NwIgIAJCADcCLCACQShqIAFBPGooAgA2AgBBgICAgHghCyABKQMYISgLIAIgASgCJCIGKAIwNgIwIAIgBjYCLCAGIAI2AjAgAigCMCACNgIsIAJBKGoiESgCACEGIAJBJGoiGigCACABQgA3A1ggAUIANwNQIAEgKDcDYCABQQA6AIgBIAFB0PfEACkDADcDgAEgAUHI98QAKQMANwN4IAFBwPfEACkDADcDcCABQbj3xAApAwA3A2ggBiABQdAAahBsAn4gAS0AiAFFBEAgASkDYAwBCyABKQNoIAEpA1iFIihCIIgiKSABKQNgIAEpA1CFIipCIIgiK34gKEL/////D4MiKCAqQv////8PgyIqfoUgKCArfiApICp+hUIgiIULISggASgCEEUEQCABIAFBCGogHBAtCyACQSBqIRMgASgCCCIJQQhrIRQgASgCDCIQICincSEGIChCGYgiKkL/AINCgYKEiJCgwIABfiErQQAhFkEAIQoDQAJ/AkAgCQJ/IAYgCWopAAAiKSArhSIoQn+FIChCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiKFBFBEAgESgCACEPA0ACQCAPIBQgKHqnQQN2IAZqIBBxIhJBA3RrKAIAIhdBCGooAgBHDQAgGigCACAXQQRqKAIAIA8QigINAEEAIBJrDAMLIChCAX0gKIMiKFBFDQALCyApQoCBgoSIkKDAgH+DISggCkEBRwRAIChQDQIgKHqnQQN2IAZqIBBxIQcLQQEgKCApQgGGg1ANAhogByAJaiwAACIGQQBOBEAgCSAJKQMAQoCBgoSIkKDAgH+DeqdBA3YiB2otAAAhBgsgByAJaiAqp0H/AHEiCjoAACAJIAdBCGsgEHFqQQhqIAo6AAAgCSAHQQN0a0EIayATNgIAIAEgASgCFEEBajYCFCABIAEoAhAgBkEBcWs2AhBBACAHawtBA3RqQQRrIAI2AgAgC0GAgICAeEcNBAwFC0EACyEKIAYgFkEIaiIWaiAQcSEGDAALAAsgE0EAIB1rQQN0akEEaygCACICIAY2ABwgAiAJNgAYIAIgCzYAFCACIAc2ABAgAiAQNgAMIAIgFjYACCACIA82AAQgAiARNgAAIAIoAiwgAigCMCIHNgIwIAcgAigCLDYCLCACIAEoAiQiBygCMDYCMCACIAc2AiwgByACNgIwIAIoAjAgAjYCLCABKAI0IgtBgICAgHhGDQELIAtFDQAgBSALQQEQhwMLIBlBAWsiGQ0ACwsgDCABKQMINwMAIAxBIGogAUEoaikDADcDACAMQRhqIAFBIGopAwA3AwAgDEEQaiABQRhqKQMANwMAIAxBCGogGykDADcDACABQZABaiQADAMLCwtBBEE0EKwDAAsgCCAIKAKAD0EBazYCgA8gBEEANgKoBCAIKAKwDyICQf////8HTw0CIAggAkEBajYCsA8gBEEQaiEKQgAhKUEAIQcjAEHwB2siASQAIAhBuA9qIgUpAxAhKCABQZAEaiAFKAIMIhAgBSgCGCIGIAZBf0YbEI8BAkBB9AFBBBD6AiICBEACQCACQQA2AuwBQfQBQQQQ+gIiAwRAIANBADYC8AEgAiADNgLwASADIAI2AuwBIAFBGGoiGiABQZgEaikDADcDACABIAEpA5AENwMQIAEgAzYCMCABIAI2AiwgASAGNgIoIAEgKDcDICAQBEAgAUHEAGohGSABQeAHaiEWIAFBjAZqIRMgBSgCICgC7AEhAiABQSBqIRQDQCACIgMoAuwBIQIgAUGkAmogA0HgAWoQ9AEgAUGwAmogA0HgAfwKAAACQAJAAkACQCABKAIcIglFDQAgASgCrAIhAyABKAKoAiEHIAEpAyAhKCABQgA3A4gGIAFCADcDgAYgASAoNwOQBiABQQA6ALgGIAFB0PfEACkDADcDsAYgAUHI98QAKQMANwOoBiABQcD3xAApAwA3A6AGIAFBuPfEACkDADcDmAYgByADIAFBgAZqEGwgASgCECIGQQhrIQ8gASgCFCILAn4gAS0AuAZFBEAgASkDkAYMAQsgASkDmAYgASkDiAaFIihCIIgiKiABKQOQBiABKQOABoUiK0IgiCIpfiAoQv////8PgyIoICtC/////w+DIit+hSAoICl+ICogK36FQiCIhQsiKKdxIQUgKEIZiEL/AINCgYKEiJCgwIABfiErQQAhDANAIAUgBmopAAAiKiArhSIoQn+FIChCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiKFBFBEADQCAPICh6p0EDdiAFaiALcSIRQQN0aygCACISQQhqKAIAIANGBEAgByASQQRqKAIAIAMQigJFDQULIChCAX0gKIMiKFBFDQALCyAqICpCAYaDQoCBgoSIkKDAgH+DUEUNASAMQQhqIgwgBWogC3EhBQwACwALAkACQAJAIAEoAiggCUcEQCAWIAEpAqQCNwIAIBZBCGogAUGsAmooAgA2AgAgAUGABmogAUGwAmpB4AH8CgAAQfQBQQQQ+gIiAw0BDAoLIAEoAjAoAuwBIgNB6AFqIgsoAgAhBSADQeQBaiIPKAIAIAEpAyAhKCABQgA3A4gGIAFCADcDgAYgASAoNwOQBiABQQA6ALgGIAFB0PfEACkDADcDsAYgAUHI98QAKQMANwOoBiABQcD3xAApAwA3A6AGIAFBuPfEACkDADcDmAYgBSABQYAGahBsIAEoAhAiA0EIayERIAEoAhQiBgJ+IAEtALgGRQRAIAEpA5AGDAELIAEpA5gGIAEpA4gGhSIpQiCIIiogASkDkAYgASkDgAaFIitCIIgiLH4gKUL/////D4MiKSArQv////8PgyIrfoUgKSAsfiAqICt+hUIgiIULIimncSEFIClCGYhC/wCDQoGChIiQoMCAAX4hK0EAIQcDQAJAIAMgBWopAAAiKiArhSIpQn+FIClCgYKEiJCgwIABfYNCgIGChIiQoMCAf4MiKVBFBEAgCygCACEMA0AgESApeqdBA3YgBWogBnEiEkEDdCIbaygCACIcQQhqKAIAIAxGBEAgDygCACAcQQRqKAIAIAwQigJFDQMLIClCAX0gKYMiKVBFDQALCyAqICpCAYaDQoCBgoSIkKDAgH+DUEUNBCAHQQhqIgcgBWogBnEhBQwBCwsgA0EAIBJrQQN0aiEHQYABIQUgAyAbQQN1IgxqIgspAAAiKSApQgGGg0KAgYKEiJCgwIB/g3qnQQN2IAMgDEEIayAGcWoiAykAACIpIClCAYaDQoCBgoSIkKDAgH+DeadBA3ZqQQdNBEAgASABKAIYQQFqNgIYQf8BIQULIAsgBToAACADQQhqIAU6AAAgB0EEaygCACIDKQLkASEpIANB6AFqIAFBrAJqKAIANgIAIAMoAuABIQUgAyABKQKkAjcC4AEgASAJQQFrNgIcIAFBoARqIANB4AH8CgAAIAMgAUGwAmpB4AH8CgAAIAMoAuwBIAMoAvABIgY2AvABIAYgAygC7AE2AuwBDAELIAMgAUGABmpB7AH8CgAAIANCADcC7AFBgICAgHghBSABKQMgISgLIAMgASgCLCIGKALwATYC8AEgAyAGNgLsASAGIAM2AvABIAMoAvABIAM2AuwBIANB6AFqIhIoAgAhBiADQeQBaiIbKAIAIAFCADcDiAYgAUIANwOABiABICg3A5AGIAFBADoAuAYgAUHQ98QAKQMANwOwBiABQcj3xAApAwA3A6gGIAFBwPfEACkDADcDoAYgAUG498QAKQMANwOYBiAGIAFBgAZqEGwCfiABLQC4BkUEQCABKQOQBgwBCyABKQOYBiABKQOIBoUiKEIgiCIqIAEpA5AGIAEpA4AGhSIrQiCIIix+IChC/////w+DIiggK0L/////D4MiK36FICggLH4gKiArfoVCIIiF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QS5GDQQgBCADQQFqIgNHDQALIAQgAkEIayIISw0CDAELIAJBCGshCEEAIQQLQa7cuPECIQMDQEGAgoQIIAEgBGoiCSgCAEGu3LjxAnMiBWsgBXJBgIKECCAJQQRqKAIAQa7cuPECcyIFayAFcnFBgIGChHhxQYCBgoR4Rw0BIARBCGoiBCAITQ0ACwsgAiAERwRAQS4hA0EBIQUDQCABIARqLQAAQS5GBEAgBCEDDAMLIAIgBEEBaiIERw0ACwtBACEFCyAHIAM2AgQgByAFNgIAIAYoAghBAUYhAwwBCyABLQAAQS5GIgMgAkEBRnINACABLQABQS5GIgMgAkECRnINACABLQACQS5GIgMgAkEDRnINACABLQADQS5GIgMgAkEERnINACABLQAEQS5GIgMgAkEFRnINACABLQAFQS5GIgMgAkEGRnINACABLQAGQS5GIQMLIAAgAyAALQAEcjoABCAAKAIAIAEgAhD2AiAGQRBqJAAL5g8CC38DfiMAQdAjayIGJAAgBiABNgIIIAYgADYCBCAGIAE2AgAgBiADNgIUIAYgAjYCECAGIAM2AgwCQCAERQRAQYCAgIB4IQUMAQsgBK0gBa1CIIaEIRELIAYgETcC+BEgBiAFNgL0ESAGQRhqIQEgBkEMaiEDIwBB4ARrIgAkACAAQZgDakIANwMAIABBkANqQgA3AwAgAEGIA2pCADcDACAAQYADakIANwMAIABB+AJqQgA3AwAgAEHwAmpCADcDACAAQegCakIANwMAIABBqANqQfS0wAApAgAiETcDACAAQbADakH8tMAAKQIAIhI3AwAgAEG4A2pBhLXAACkCACITNwMAIABBKGogEzcDACAAQSBqIBI3AwAgAEEYaiARNwMAIABCADcD4AIgAEHstMAAKQIAIhE3A6ADIAAgETcDECAAQTBqIABB4AJqIgRB4AD8CgAAAkAgBkH0EWoiDCICKAIAIgVBgICAgHhGDQAgAEGIBGoiCCACKAIEIgogAigCCBBIIAAoAogEQYmAgIB4RgRAAkACfyAAKAKUBEEgRgRAIAAoAowEIQcgAEGgBGogACgCkAQiAkEYaikAADcDACAAQZgEaiACQRBqIgkpAAA3AwAgAEGQBGogAkEIaikAADcDACAAIAIpAAA3A4gEIAQgCBCCASAAKALgAg0CIABBADYC4AIg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ADoABSAAQQA6AAYgAEEAOgAHIABBADoACCAAQQA6AAkgAEEAOgAKIABBADoACyAAQQA6AAwgAEEAOgANIABBADoADiAAQQA6AA8gAEEAOgAQIABBADoAESAAQQA6ABIgAEEAOgATIABBADoAFCAAQQA6ABUgAEEAOgAWIABBADoAFyAAQQA6ABggAEEAOgAZIABBADoAGiAAQQA6ABsgAEEAOgAcIABBADoAHSAAQQA6AB4gAEEAOgAfC4ICACAAQQA6AMABIABBADoAwQEgAEEAOgDCASAAQQA6AMMBIABBADoAxAEgAEEAOgDFASAAQQA6AMYBIABBADoAxwEgAEEAOgDIASAAQQA6AMkBIABBADoAygEgAEEAOgDLASAAQQA6AMwBIABBADoAzQEgAEEAOgDOASAAQQA6AM8BIABBADoA0AEgAEEAOgDRASAAQQA6ANIBIABBADoA0wEgAEEAOgDUASAAQQA6ANUBIABBADoA1gEgAEEAOgDXASAAQQA6ANgBIABBADoA2QEgAEEAOgDaASAAQQA6ANsBIABBADoA3AEgAEEAOgDdASAAQQA6AN4BIABBADoA3wELwQECA38BfiMAQTBrIgIkACABKAIAQYCAgIB4RgRAIAEoAgwhAyACQRRqIgRBADYCACACQoCAgIAQNwIMIAJBIGogAygCACIDQQhqKQIANwMAIAJBKGogA0EQaikCADcDACACIAMpAgA3AxggAkEMakGUtMQAIAJBGGoQXxogAkEIaiAEKAIAIgM2AgAgAiACKQIMIgU3AwAgAUEIaiADNgIAIAEgBTcCAAsgAEGcvMQANgIEIAAgATYCACACQTBqJAALlwIBAn8jAEEgayIFJABB+PfEAEH498QAKAIAIgZBAWo2AgACQAJ/QQAgBkEASA0AGkEBQcT7xAAtAAANABpBxPvEAEEBOgAAQcD7xABBwPvEACgCAEEBajYCAEECC0H/AXEiBkECRwRAIAZBAXFFDQEgBUEIaiAAIAEoAhgRAgAMAQtB7PfEACgCACIGQQBIDQBB7PfEACAGQQFqNgIAQez3xABB8PfEACgCAAR/IAUgACABKAIUEQIAIAUgBDoAHSAFIAM6ABwgBSACNgIYIAUgBSkDADcCEEHw98QAKAIAIAVBEGpB9PfEACgCACgCFBECAEHs98QAKAIAQQFrBSAG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N2ogA0EKSRs6AAAgAkEBayECIABBD0sgAEEEdiEADQALIAFBAUHf38QAQQIgAiAEakGAAWpBACACaxBNIARBgAFqJAALeQAgACABKQAANwAAIABBIGogASkAIDcAACAAQQhqIAFBCGopAAA3AAAgAEEQaiABQRBqKQAANwAAIABBGGogAUEYaikAADcAACAAQShqIAFBKGopAAA3AAAgAEEwaiABQTBqKQAANwAAIABBOGogAUE4aikAADcAAAuLAQEEfwJAAkACQCAAKAIAIgAoAgAOAgABAgsgACgCCCIBRQ0BIAAoAgQgAUEBEIcDDAELIAAtAARBA0cNACAAKAIIIgEoAgAhAyABQQRqKAIAIgQoAgAiAgRAIAMgAhEEAAsgBCgCBCICBEAgAyACIAQoAggQhwMLIAFBDEEEEIcDCyAAQRRBBBCHAwt2AQN/IwBBEGsiAiQAAkAgAUEASA0AAkAgAUUEQEEBIQMMAQtBASEEIAFBARD6AiIDRQ0BCyABBEAgAyAAIAH8CgAACyACIAE2AgwgAiADNgIIIAIgATYCBCACQQRqECwgAkEQaiQADwsgBCABQZTawAAQ4gIAC3oBAX8jAEEgayICJAACfyAAKAIAQYCAgIB4RwRAIAEgACgCBCAAKAIIEPYCDAELIAJBEGogACgCDCgCACIAQQhqKQIANwMAIAJBGGogAEEQaikCADcDACACIAApAgA3AwggASgCACABKAIEIAJBCGoQXwsgAkEgaiQAC3kBAX8jAEFAaiIDJAAgAyACNgIUIAMgATYCECADIAA2AgwgA0ECNgIcIANBxNXAADYCGCADQgI3AiQgAyADQRBqrUKAgICAsAiENwM4IAMgA0EMaq1CgICAgMAIhDcDMCADIANBMGo2AiAgA0EYahDGASADQUBrJAALYgEEfiAAIAJC/////w+DIgMgAUL/////D4MiBH4iBSAEIAJCIIgiAn4iBCADIAFCIIgiBn58IgFCIIZ8IgM3AwAgACADIAVUrSACIAZ+IAEgBFStQiCGIAFCIIiEfHw3AwgLhgEBBH8CQAJAAkAgACgCAA4CAAECCyAAKAIIIgFFDQEgACgCBCABQQEQhwMMAQsgAC0ABEEDRw0AIAAoAggiASgCACEDIAFBBGooAgAiBCgCACICBEAgAyACEQQACyAEKAIEIgIEQCADIAIgBCgCCBCHAwsgAUEMQQQQhwMLIABBFEEEEIcDC4wBACAAQgA3AiQgAEE0akEANgIAIABBLGpCADcCACAAIAEpABg3AgggACABKQAQNwIAIAAgASgAAEH///8fcTYCECAAIAEoAAxBCHZB//8/cTYCICAAIAEoAAlBBnZB///AH3E2AhwgACABKAAGQQR2Qf+B/x9xNgIYIAAgASgAA0ECdkGD/v8fcTYCFAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUGg38QANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICQFoQ3AzggBSAFQQhqrUKAgICAoBaENwMwIAUgBUEwajYCICAFQRhqIAQQxwIAC3YBBH8CQAJAIAEoAhQiBSABKAIQIgZPDQAgASgCDCEHA0AgBSAHai0AACIIQTBrQf8BcUEJTQRAIAEgBUEBaiIFNgIUIAUgBkcNAQwCCwsgCEEgckHlAEYNAQsgACABIAIgAyAEEKcBDwsgACABIAIgAyAEEHcLdgAgACABKQAANwAAIAAgASkAIDcAICAAQRhqIAFBGGopAAA3AAAgAEEQaiABQRBqKQAANwAAIABBCGogAUEIaikAADcAACAAQShqIAFBKGopAAA3AAAgAEEwaiABQTBqKQAANwAAIABBOGogAUE4aikAADcAAAuPAQIBfwF+IwBBIGsiAyQAIAMgASACEFkgAEH0yoHZBjYCPCAAQbLaiMsHNgIoIABCADcCICAAQe7IgZkDNgIUIABB5fDBiwY2AgAgACADKQIYNwI0IAAgAykCEDcCLCAAIAIpABAiBD4CGCAAIAMpAgg3AgwgACADKQIANwIEIAAgBEIgiD4CHCADQSBqJAALcAEBfyMAQSBrIgIkAAJ/IAAoAgBBAUYEQCABQYOxxABBFRD2AgwBCyACQQI2AgQgAkGwscQANgIAIAJCATcCDCACIACtQoCAgIDACIQ3AxggAiACQRhqNgIIIAEoAgAgASgCBCACEF8LIAJBIGokAAu9AwEHfyMAQRBrIgMkACAAKAIIIQUgACgCBCEAIAEoAgBBjN3EAEEBIAEoAgQoAgwRAQAhBCADQQRqIgJBADoABSACIAQ6AAQgAiABNgIAIAUEQANAIAMgADYCDCADQQxqIQcjAEEgayIBJABBASEGAkAgA0EEaiIELQAEDQAgBC0ABSEIAkAgBCgCACICLQAKQYABcUUEQCAIQQFxRQ0BIAIoAgBBz9/EAEECIAIoAgQoAgwRAQBFDQEMAgsgCEEBcUUEQCACKAIAQd3fxABBASACKAIEKAIMEQEADQILIAFBAToADyABQbDfxAA2AhQgASACKQIANwIAIAEgAikCCDcCGCABIAFBD2o2AgggASABNgIQIAcgAUEQakGow8AAKAIAEQAADQEgASgCEEHU38QAQQIgASgCFCgCDBEBACEGDAELIAcgAkGow8AAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUEgaiQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIAQd7fxABBASAAKAIEKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtrAQN/AkAgASgCCCICQQBIDQAgASgCBCEDAkAgAkUEQEEBIQEMAQtBASEEIAJBARD6AiIBRQ0BCyACBEAgASADIAL8CgAACyAAIAI2AgggACABNgIEIAAgAjYCAA8LIAQgAkGswcQAEOICAAsSACMAQTBrIgAkACAAQTBqJAALagIBfwF+IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0ECNgIMIANB7N3EADYCCCADQgI3AhQgA0KAgICAwAgiBCADrYQ3AyggAyAEIANBBGqthDcDICADIANBIGo2AhAgA0EIaiACEMcCAAtyACAAQQA2AgAgAEEANgIEIABBADYCCCAAQQA2AgwgAEEANgIQIABBADYCFCAAQQA2AhggAEEANgIcIABBADYCICAAQQA2AiQgAEEANgIoIABBADYCLCAAQQA2AjAgAEEANgI0IABBADYCOCAAQQA2AjwLXwEBfyMAQTBrIgIkACACIAE2AgwgAiAANgIIIAJBAjYCFCACQZjVwAA2AhAgAkIBNwIcIAIgAkEIaq1CgICAgKAIhDcDKCACIAJBKGo2AhggAkEQahDGASACQTBqJAALXwEBfyMAQTBrIgIkACACIAE2AgwgAiAANgIIIAJBAjYCFCACQejVwAA2AhAgAkIBNwIcIAIgAkEIaq1CgICAgKAIhDcDKCACIAJBKGo2AhggAkEQahDGASACQTBqJAALagECfkGw98QAIwBBCGutIgBB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JAALSQEBfyMAQRBrIgMkACADQQhqIAEoAgAgASgCBCABKAIIEF4gAiADKAIIIAMoAgwQmgIhASAAQQI2AgAgACABNgIEIANBEGokAAtJAQF/IwBBEGsiAyQAIANBCGogASgCACABKAIEIAEoAggQXiACIAMoAgggAygCDBCaAiEBIABBAToAACAAIAE2AgQgA0EQaiQAC0kBAX8jAEEQayIDJAAgA0EIaiABKAIAIAEoAgQgASgCCBBeIAIgAygCCCADKAIMEJoCIQEgAEEBOwEAIAAgATYCBCADQRBqJAALNwEBfyMAQSBrIgIkACABQQFBAUEAIAApAwAgAkEMaiIBEJcBIgAgAWpBFCAAaxBNIAJBIGokAAv4DwIGfwJ+IwBBEGsiDSQAIwBB4ABrIgwkAAJAAkACQAJAIAAEQCAAQQhrIg8gDygCAEEBaiIONgIAIA5FDQEgACgCAA0CIABBfzYCACAMIA82AgwgDCAANgIIIAwgBDYCGCAMIAM2AhQgDCAENgIQIAwgBjYCJCAMIAU2AiAgDCAGNgIcIAwgCDYCMCAMIAc2AiwgDCAINgIoIAwgAEEIaiIENgIEAkAgCkUEQEGAgICAeCELDAELIAqtIAutQiCGhCESCyAMIBI3AkwgDCALNgJIIAxBNGohBSMAQdABayIDJAAgA0EIaiAMQShqIgZBCGooAgA2AgAgA0EUaiAMQRxqIgdBCGooAgA2AgAgAyAGKQIANwMAIAMgBykCADcCDCADQcgBaiAMQRBqIgZBCGooAgA2AgAgAyAGKQIANwPAASADQfAAaiAEIAEgAiADIANBwAFqIAn8ByAMQcgAahAkAkAgAykDgAEiEkIEUQRAIANByABqIANBkAFqKQMAIhI3AwAgA0HQAGogA0GYAWooAgAiBDYCACADIAMpA4gBIhM3A0AgBUEQaiAENgIAIAVBCGogEjcCACAFIBM3AgAgAygCwAEiBEUNASADKALEASAEQQEQhwMMAQsgA0HgAGoiBCADQZABaikDADcDACADQegAaiIHIANBmAFqKAIANgIAIAMgAykDiAE3A1ggAygCeCEIIAMoAnQhCiADKAJwIQYgA0E8aiADQbwBaigCADYCACADQTRqIANBtAFqKQIANwIAIANBLGogA0GsAWopAgA3AgAgA0EkaiADQaQBaikCADcCACADIAMpApwBNwIcIANB0ABqIgsgBygCADYCACADQcgAaiIHIAQpAwA3AwAgAyADKQNYNwNAIANBGGogCygCADYCACADQRBqIAcpAwA3AwAgAyADKQNANwMIIAMgEjcDACADKALAASIEBEAgAygCxAEgBEEBEIcDCwJAIBJCA1IEQCADQYQBaiADQRhqKAIANgIAIAMgCDYCeCADIAo2AnQgAyAGNgJwIAMgAykDEDcCfCADIAMpAzgiEjcCjAEgAyADKAI0Igg2AogBIAMoAiwhByADKAIoIQQgAygCHCILBEAgAygCICALQQEQhwMLIAQEQCAHIARBARCHAwtBgAFBARD6AiIERQ0BIBKnIREgAyAENgJcIANBgAE2AlggAyADQdgAajYCwAEgBEH7ADoAACADQQE2AmAgA0GAAjsBQCADIANBwAFqNgJEAkACQCADQUBrIgdB/6rAAEEJIANB8ABqEMMBIgQNAAJAIAMtAEANACAHQYirwABBESADQfwAahDDASIEDQEgCEGAgICAeEcEQCADLQBADQECfyAHLQAAQQFHBEAgA0GIAWohECAHKAIEIQsgBy0AAUEBRwRAIAsoAgAiBCgCACAEKAIIIg5GBEAgBCAOQQEQqQEgBCgCCCEOCyAEIA5BAWo2AgggBCgCBCAOakEsOgAACyAHQQI6AAEgCygCAEGZq8AAQQQQZSALKAIAIgcoAgAgBygCCCIERgRAIAcgBEEBEKkBIAcoAgghBAsgByAEQQFqNgIIIAcoAgQgBGpBOjoAACALKAIAIQcgECgCAEGAgICAeEYEQCAHKAIAIAcoAggiBGtBA00EQCAHIARBBBCpASAHKAIIIQQLIAcgBEEEajYCCCAHKAIEIARqQe7qseMGNgAAQQAMAgsgByAQKAIEIBAoAggQZUEADAELQbCuwABBKEHYrsAAEKACAAsiBA0CCyADKAJAIgRBgP4DcUUgBEEBcXJFBEAgAygCRCgCACIHKAIIIgQgBygCAEYEQCAHIARBARCpASAHKAIIIQQLIAcoAgQgBGpB1KnAAC0AADoAACAHIARBAWo2AggLIAMoAlwhBCADKAJYIgdBgICAgHhGDQIgBSADKAJgNgIMIAUgBDYCCCAFIAc2AgQgBUGMgICAeDYCACAGBEAgCiAGQQEQhwMLIAMoAnwiBARAIAMoAoABIARBARCHAwsgCEGAgICAeHJBgICAgHhGDQUgESAIQQEQhwMMBQsQxAIhBAsgAygCWCIHRQ0AIAMoAlwgB0EBEIcDCyAFIAQ2AgQgBUGJgICAeDYCACAGBEAgCiAGQQEQhwMLIAMoAnwiBARAIAMoAoABIARBARCHAwsgCEGAgICAeHJBgICAgHhGDQIgESAIQQEQhwMMAgsgBUGdq8AAQRwQ7gI2AgQgBUGLgICAeDYCACADENIBIAZFDQEgCiAGQQEQhwMMAQtBAUGAAUHEqcAAEOICAAsgA0HQAWokACACBEAgASACQQEQhwMLIABBADYCACAPIA8oAgBBAWsiADYCACAARQRAIAxBDGoQiQELIA0CfyAMKAI0QYyAgIB4RwRAIAxB2ABqIAxBxABqKAIANgIAIAxB0ABqIAxBPGopAgA3AwAgDCAMKQI0NwNIQQAhACAMQcgAahCrASELQQAhAkEBDAELIAwoAjwhAQJAIAwoAjgiAyAMKAJAIgJNBEAgASEADAELIAJFBEBBASEAIAEgA0EBEIcDDAELIAEgA0EBIAIQ8QIiAEUNBQtBACELQQALNgIMIA0gCzYCCCANIAI2AgQgDSAANgIAIAxB4ABqJAAMBAsQowMLAAsQpAMAC0EBIAJBvKvAABDiAgALIA0oAgAgDSgCBCANKAIIIA0oAgwgDUEQaiQAC0kBAX8jAEEQayICJAAgAiAAQQRqNgIMIAFBvK3AAEEJQcWtwABBCyAAQZytwABB0K3AAEEJIAJBDGpBrK3AABDRASACQRBqJAALSQEBfyMAQRBrIgIkACACIABBBGo2AgwgAUGIr8AAQQlBka/AAEELIABB6K7AAEGcr8AAQQkgAkEMakH4rsAAENEBIAJBEGokAAtJAQF/IwBBEGsiAiQAIAIgAEEMajYCDCABQfzDwABBDUGJxMAAQQUgAEHcw8AAQY7EwABBBSACQQxqQezDwAAQ0QEgAkEQaiQAC0kBAX8jAEEQayICJAAgAiAAQQxqNgIMIAFB+NbAAEENQYXXwABBBSAAQdjWwABBitfAAEEFIAJBDGpB6NbAABDRASACQRBqJAALQwEBf0EUQQQQ+gIiA0UEQEEEQRQQrAMACyADIAI2AhAgAyABNgIMIAMgACkCADcCACADQQhqIABBCGooAgA2AgAgAws6AQF/IwBBIGsiAiQAIAJBCGogACgCACACQRZqEJEBIAFBAUEBQQAgAigCCCACKAIMEE0gAkEgaiQAC/5uAyV/FH4BfCABKAIIIgNBgICAAXEhAiAAKwMAITsCQCADQYCAgIABcUUEQCABIAJBAEchEEEAIQNBACECIwBBgAFrIggkACA7vSEwAn9BAyA7mUQAAAAAAADwf2ENABpBAiAwQoCAgICAgID4/wCDIidCgICAgICAgPj/AFENABogMEL/////////B4MiKkKAgICAgICACIQgMEIBhkL+////////D4MgMEI0iKdB/w9xIgMbIihCAYMhKSAnUARAQQQgKlANARogA0GzCGshA0IBIScgKVAMAQtCgICAgICAgCAgKEIBhiAoQoCAgICAgIAIUSIAGyEoQgJCASAAGyEnQct3Qcx3IAAbIANqIQMgKVALIQEgCCADOwF4IAggJzcDcCAIQgE3A2ggCCAoNwNgIAggAToAegJ/AkACQAJAAkACQCABQf8BcSIAQQFNBEAgCEEgaiEJIAhBD2ohDCMAQeAAayIBJAACQAJAAn8CQAJAAkACQAJAAkACQCAIQeAAaiIAKQMAIidQRQRAIAApAwgiKVANASAAKQMQIihQDQIgJyAofCIoICdUDQMgJyApVA0EIChCgICAgICAgIAgWg0FIAEgAC8BGCIAOwE4IAEgJyApfSIqNwMwIAEgKiAoeSIphiIsICmIIis3A0AgKiArUg0JIAEgADsBOCABICc3AzAgASAnIClCP4MiKoYiKyAqiCIqNwNAICcgKlINCUGgfyAAICmnayIDa8FB0ABsQbCnBWpBzhBtIgBB0QBPDQYgAUEgaiAAQQR0IgBBgM3EAGopAwAiJyAoICmGEOsBIAFBEGogJyAsEOsBIAEgJyArEOsBQgFBACADIABBiM3EAGovAQBqa0E/ca0iLoYiK0IBfSEvIAEpAxBCP4chNCABKQMAQj+IITUgASkDCCE2IABBis3EAGovAQAhACABKQMYITcgASkDKCI5IAEpAyBCP4giOnwiMkIBfCItIC6IpyIDQZDOAE8EQCADQcCEPUkNCCADQYDC1y9PBEBBCEEJIANBgJTr3ANJIgYbIQ1BgMLXL0GAlOvcAyAGGwwKC0EGQQcgA0GAreIESSIGGyENQcCEPUGAreIEIAYbDAkLIANB5ABPBEBBAkEDIANB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QbTJxABBHEHQycQAEKACAAtBhMnEAEEdQaTJxAAQoAIAC0HYyMQAQRxB9MjEABCgAgALIAANAQsgCSAPaiEDQQAhBUF/IQACQAJAAkADQCAAIA1GDQEgAEEBaiEAIAUgEmogBUEBayICIQUtAABBOUYNAAsgAiANaiIAIA9qQQFqIgMgAy0AAEEBajoAACAAQQJqIgAgCU0NASAAIAlB8NrEABCKAwALIA9BMToAACANBEAgD0EBakEwIA38CwALIAlBEU8NASADQTA6AAAgDkEBaiEOIA1BAmohCQwCCyACQX9GDQEgAkF/cyIARQ0BIAIgEmpBAmpBMCAA/AsADAELIAlBEUGwysQAEPYBAAsgCUERTQRAIBcgDjsBCCAXIAk2AgQgFyAPNgIAIAFBoApqJAAMBQsgCUERQcDKxAAQiwMACyADQShBpPLEABCLAwALQbTyxABBGkGk8sQAEKACAAsgAEEoQaTyxAAQiwMAC0EoQShBpPLEABD2AQALCyAfIB4gEBshACAQICByIQIgCCAIKAJQIAgoAlQgCC8BWEEAIAhBIGoQiwEgCCgCBCEDIAgoAgAMAwsgCEECOwEgDAELIAhBAzYCKCAIQfnbxAA2AiQgCEECOwEgQQEhAEEBIQMgCEEgagwBCyAIQQE2AiggCEH/28QANgIkIAhBIGoLIQEgCCADNgJcIAggATYCWCAIIAI2AlQgCCAANgJQIAhB0ABqEF0gCEGAAWokAA8LAn8gASEMIAJBAEchFyABLwEOIQ1BACEBIwBB8AhrIgckACA7vSEoAn9BAyA7mUQAAAAAAADwf2ENABpBAiAoQoCAgICAgID4/wCDIilCgICAgICAgPj/AFENABogKEL/////////B4MiLEKAgICAgICACIQgKEIBhkL+////////D4MgKEI0iKdB/w9xIgEbIidCAYMhKiApUARAQQQgLFANARogAUGzCGshAUIBISkgKlAMAQtCgICAgICAgCAgJ0IBhiAnQoCAgICAgIAIUSIAGyEnQgJCASAAGyEpQct3Qcx3IAAbIAFqIQEgKlALIQAgByABOwHoCCAHICk3A+AIIAdCATcD2AggByAnNwPQCCAHIAA6AOoIAkACfwJAAkAgAEH/AXEiAkEBTQRAQXRBBSABwSIAQQBIGyAAbCIAQcD9AEkNAUGA3MQAQSVB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AiABKAIAIQNBCEEEEPoCIgFFBEBBBEEIEKwDAAsgASACNgIEIAEgAzYCACAAQay8xAA2AgQgACABNgIAC0IBAX8jAEEgayIDJAAgA0EANgIQIANBATYCBCADQgQ3AgggAyABNgIcIAMgADYCGCADIANBGGo2AgAgAyACEMcCAAtBAQF/IAAoAgAiACgCqAEEQCAAQQA2AqgBCwJAIABBf0YNACAAIAAoAgRBAWsiATYCBCABDQAgAEGQD0EIEIcDCws9AQJ/AkAgACgCACICRQ0AIAAoAgQiACgCACIBBEAgAiABEQQACyAAKAIEIgFFDQAgAiABIAAoAggQhwMLCzkBAX8jAEEQayICJAAgAkEIaiAAKAIAIAAoAgQgACgCCBBeIAEgAigCCCACKAIMEJoCIAJBEGokAAvqBwIEfwJ+IwBBEGsiCSQAIwBB0ABrIggkAAJAAkACQAJAIAAEQCAAQQhrIgsgCygCAEEBaiIKNgIAIApFDQEgACgCAA0CIABBfzYCACAIIAs2AhQgCCAANgIQIAggBDYCICAIIAM2AhwgCCAENgIYIAggAEEIaiIKNgIMAkAgBkUEQEGAgICAeCEHDAELIAatIAetQiCGhCEMCyAIIAw3AjwgCCAHNgI4IAhBJGohBCMAQYACayIDJAAgA0GAgICAeDYC2AEgA0H4AWogCEEYaiIGQQhqKAIANgIAIAMgBikCADcD8AEgA0GIAWogCiABIAIgA0HYAWogA0HwAWogBfwHIAhBOGoQJAJAIAMpA5gBIgxCBFEEQCADQeAAaiADQagBaikDACIMNwMAIANB6ABqIANBsAFqKAIAIgY2AgAgAyADKQOgASINNwNYIARBEGogBjYCACAEQQhqIAw3AgAgBCANNwIAIAMoAvABIgRFDQEgAygC9AEgBEEBEIcDDAELIANBEGoiBiADQZABaikDADcDACADQfgAaiIHIANBqAFqKQMANwMAIANBgAFqIgogA0GwAWooAgA2AgAgA0E8aiADQbwBaikCADcCACADQcQAaiADQcQBaikCADcCACADQcwAaiADQcwBaikCADcCACADQdQAaiADQdQBaigCADYCACADIAMpA4gBNwMIIAMgAykDoAE3A3AgAyADKQK0ATcCNCADQeAAaiAHKQMAIg03AwAgA0HoAGogCigCACIHNgIAIANB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aiAAQR9qKQAANwAAIAJBJ2ogAEEnaikAADcAACACQS9qIABBL2opAAA3AAAgAkE3aiAAQTdqKQAANwAAIAJBP2ogAEE/ai0AADoAACAAQcAAQQEQhwNBwAALIQAgAyAFNgIMIAMgBDYCCCADIAA2AgQgAyACNgIAIAMoAgAgAygCBCADKAIIIAMoAgwgA0EQaiQACycBAn8jAEEQayIAJAAgAEEKNgIEIABBBGpBAEEAEJoCIABBEGokAAukCQISfwJ+IwBBMGsiDyQAIA9BDGohECMAQbABayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJCADcDAEEBIQcDQCACIAVqIgMgAygCACABIAVqIgMtAAByIANBAWotAABBCHRyIANBAmotAABBEHRyIANBA2otAABBGHRyNgIAIAVBBGohBSAHQRBJIAdBAWohBw0ACyACQcgAaiIBIAIoAggiCkEGdCACKAIEIgZBGnZyQf////8BcTYCACACQdAAaiIFIAIoAhAiC0EMdCACKAIMIgxBFHZyQf////8BcTYCACACQdgAaiIHIAIoAhgiBEESdCACKAIUIg1BDnZyQf////8BcTYCACACQeAAaiIDIAIoAiAiDkEYdCACKAIcIghBCHZyQf////8BcTYCACACIAIoAgAiCUH/////AXE2AkAgAiAGQQN0IAlBHXZyQf////8BcTYCRCACIAxBCXQgCkEXdnJB/////wFxNgJMIAIgDUEPdCALQRF2ckH/////AXE2AlQgAiAIQRV0IARBC3ZyQf////8BcTYCXCACQYgBaiIKIAIoAjwiBEENdjYCACACQfAAaiINIAIoAigiCEEBdCACKAIkIgZBH3ZyQf////8BcTYCACACQfgAaiILIAIoAjAiCUEHdCACKAIsIhFBGXZyQf////8BcTYCACACQYABaiIMIAIoAjgiEkENdCACKAI0IhNBE3ZyQf////8BcTYCACACIAZBAnZB/////wFxNgJsIAIgBkEbdCAOQQV2ckH/////AXE2AmggAiARQQR0IAhBHHZyQf////8BcTYCdCACIBNBCnQgCUEWdnJB/////wFxNgJ8IAIgBEEQdCASQRB2ckH/////AXE2AoQBIAJBjAFqIgYgAkFAa0GI88AAEDAgAyACQawBaiIEKAIANgIAIAcgAkGkAWoiDikCADcDACAFIAJBnAFqIggpAgA3AwAgASACQZQBaiIJKQIANwMAIAIgAikCjAE3A0AgBiACQegAakHk8sAAEDAgCiAEKAIANgIAIAwgDikCADcDACALIAgpAgA3AwAgDSAJKQIAIhQ3AwAgAiACKQKMASIVNwNoIAIgAigCQCAVp2oiBEH/////AXE2AowBIAIgAigCRCACKAJsIARBHXZqaiIEQf////8BcTYCkAEgAiABKAIAIBSnIARBHXZqaiIBQf////8BcTYClAEgAiACKAJMIAIoAnQgAUEddmpqIgFB/////wFxNgKYASACIAUoAgAgCygCACABQR12amoiAUH/////AXE2ApwBIAIgAigCVCACKAJ8IAFBHXZqaiIBQf////8BcTYCoAEgAiAHKAIAIAwoAgAgAUEddmpqIgFB/////wFxNgKkASACIAIoAlwgAigChAEgAUEddmpqIgFB/////wFxNgKoASACIAMoAgAgCigCACABQR12ampB/////wFxNgKsASAQIAZBwPLAABBmIAJBsAFqJAAgACAQEH0gD0EwaiQACycAIAAgASAAKAIEQQFxckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAv8AQICfwF+IwBBEGsiAiQAIAJBATsBDCACIAE2AgggAiAANgIEIwBBEGsiASQAIAJBBGoiACkCACEEIAEgADYCDCABIAQ3AgQjAEEQayIAJAAgAUEEaiIBKAIAIgIoAgwhAwJAAkACQAJAIAIoAgQOAgABAgsgAw0BQQEhAkEAIQMMAgsgAw0AIAIoAgAiAigCBCEDIAIoAgAhAgwBCyAAQYCAgIB4NgIAIAAgATYCDCAAQdi8xAAgASgCBCABKAIIIgAtAAggAC0ACRDPAQALIAAgAzYCBCAAIAI2AgAgAEG8vMQAIAEoAgQgASgCCCIALQAIIAAtAAkQzwEAC/8DAgV/A34jAEEQayIGJAAjAEEQayIHJAAgB0EIaiEIIwBBgBBrIgQkACAEQThqQgA3AwAgBEEwakIANwMAIARBKGpCADcDACAEQSBqQgA3AwAgBEEYakIANwMAIARBEGpCADcDACAEQQhqQgA3AwAgBEHIAGpBrNrAACkCACIJNwMAIARB0ABqQbTawAApAgAiCjcDACAEQdgAakG82sAAKQIAIgs3AwAgBEGID2ogCTcDACAEQZAPaiAKNwMAIARBmA9qIAs3AwAgBEIANwMAIARBpNrAACkCACIJNwNAIAQgCTcDgA8gBEGgD2ogBEHgAPwKAAAgBCAEQYAPaiIFQYAB/AoAACAEQYcBakEANgAAIARCADcDgAEgBEEANgKYASAEQgA3A5ABIAQgAiADECkgBCAAIAEQKSAFIAQQyQFBIEEBEPoCIgVFBEBBAUEgQZTawAAQ4gIACyAFIAQpAIAPNwAAIAVBGGogBEGYD2opAAA3AAAgBUEQaiAEQZAPaikAADcAACAFQQhqIARBiA9qKQAANwAAIAhBIDYCBCAIIAU2AgAgBEGAEGokACAHKAIMIQQgBygCCCEFIAMEQCACIANBARCHAwsgAQRAIAAgAUEBEIcDCyAGIAU2AgAgBiAENgIEIAdBEGokACAGKAIAIAYoAgQgBkEQaiQAC8sDAQN/IwBBEGsiAyQAQQghBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQEEVIAAoAgAiBUGAgICAeHMgBUEAThtBAWsOFQECAwQFBgcICQoLDA0ODxQUEBESEwALIAMgAC0ABDoAASADQQA6AAAMFgsgAyAAMQAENwMIDBMLIAMgADMBBDcDCAwSCyADIAA1AgQ3AwgMEQsgAyAAKQMINwMIDBALIAMgADAABDcDCAwQCyADIAAyAQQ3AwgMDwsgAyAANAIENwMIDA4LIAMgACkDCDcDCAwNCyADIAAqAgS7OQMIIANBAzoAAAwNCyADIAArAwg5AwggA0EDOgAADAwLIAMgACgCBDYCBCADQQQ6AAAMCwsgAyAAKQMINwIEIANBBToAAAwKCyADIAApAgQ3AgQgA0EFOgAADAkLIAMgACkDCDcCBCADQQY6AAAMCAsgAyAAKQIENwIEIANBBjoAAAwHCyADQQc6AAAMBgsgA0EJOgAADAULIANBCjoAAAwEC0ELIQQLIAMgBDoAAAwCCyADQQE6AAAMAQsgA0ECOgAACyADIAEgAhDhASADQRBqJAALNwEBfkIDIQIgACABvUL///////////8Ag0L/////////9/8AWAR+IAAgATkDCEICBSACCzcDAAshAAJAIAEgAxDoAgRAIAAgASADIAIQ8QIiAA0BCwALIAALZAEEfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIAAgARCIASADKAIMIQQgAygCCCEFIAEEQCAAIAFBARCHAwsgAiAFNgIAIAIgBDYCBCADQRBqJAAgAigCACACKAIEIAJBEGokAAvpAwIFfwN+IwBBEGsiBCQAIwBBEGsiBSQAIAVBCGohBiMAQYAQayICJAAgAkE4akIANwMAIAJBMGpCADcDACACQShqQgA3AwAgAkEgakIANwMAIAJBGGpCADcDACACQRBqQgA3AwAgAkEIakIANwMAIAJByABqQazawAApAgAiBzcDACACQdAAakG02sAAKQIAIgg3AwAgAkHYAGpBvNrAACkCACIJNwMAIAJBiA9qIAc3AwAgAkGQD2ogCDcDACACQZgPaiAJNwMAIAJCADcDACACQaTawAApAgAiBzcDQCACIAc3A4APIAJBoA9qIAJB4AD8CgAAIAIgAkGAD2oiA0GAAfwKAAAgAkGHAWpBADYAACACQgA3A4ABIAJBADYCmAEgAkIANwOQASACIAAgARApIAMgAhDJAUEgQQEQ+gIiA0UEQEEBQSBBlNrAABDiAgALIAMgAikAgA83AAAgA0EYaiACQZgPaikAADcAACADQRBqIAJBkA9qKQAANwAAIANBCGogAkGID2opAAA3AAAgBkEgNgIEIAYgAzYCACACQYAQaiQAIAUoAgwhAiAFKAIIIQMgAQRAIAAgAUEBEIcDCyAEIAM2AgAgBCACNgIEIAVBEGokACAEKAIAIAQoAgQgBEEQaiQACyMAIAIgAigCBEF+cTYCBCAAIAFBAXI2AgQgACABaiABNgIAC6cCAQR/IwBBEGsiAyQAIwBBMGsiAiQAAkACQAJAAkAgAARAIABBCGsiBCAEKAIAQQFqIgE2AgAgAUUNASAAKAIAIgFBf0YNAiAAIAFBAWo2AgAgAiAENgIMIAIgADYCCCACIABBCGoiATYCBCACQRBqIAEQyQFBIEEBEPoCIgFFDQMgASACKQAQNwAAIAFBGGogAkEoaikAADcAACABQRBqIAJBIGopAAA3AAAgAUEIaiACQRhqKQAANwAAIAAgACgCAEEBazYCACAEIAQoAgBBAWsiADYCACAARQRAIAJBDGoQoQILIANBIDYCBCADIAE2AgAgAkEwaiQADAQLEKMDCwALEKQDAAtBAUEgQcCvwAAQ4gIACyADKAIAIAMoAgQgA0EQaiQAC/YEARN/IwBBoAFrIgMkACMAQSBrIgQkACAEQQlqIAFBCWopAAA3AAAgBEERaiABQRFqKQAANwAAIARBF2ogAUEXaikAADcAACAEIAEpAAE3AAEgBCABLQAAQfgBcToAACAEIAEtAB9BP3FBwAByOgAfIAMgBBAzIARBIGokACMAQaACayICJAAgAygCKCEFIAMoAlAhBiADKAIsIQcgAygCVCEIIAMoAjAhCSADKAJYIQogAygCNCELIAMoAlwhDCADKAI4IQ0gAygCYCEOIAMoAjwhDyADKAJkIRAgAygCQCERIAMoAmghEiADKAJEIRMgAygCbCEUIAMoAkghBCADKAJwIQEgAiADKAJMIAMoAnRqNgIsIAIgASAEajYCKCACIBMgFGo2AiQgAiARIBJqNgIgIAIgDyAQajYCHCACIA0gDmo2AhggAiALIAxqNgIUIAIgCSAKajYCECACIAcgCGo2AgwgAiAFIAZqNgIIIAJBMGoiASADQdAAaiADQShqEHggAkHQAWoiBCABEDEgAkGgAWogAkHwAWopAgA3AwAgAkGYAWogAkHoAWopAgA3AwAgAkGQAWogAkHgAWopAgA3AwAgAkGIAWogAkHYAWopAgA3AwAgAiACKQLQATcDgAEgAkHIAWogAkGYAmopAgA3AwAgAkHAAWogAkGQAmopAgA3AwAgAkG4AWogAkGIAmopAgA3AwAgAkGwAWogAkGAAmopAgA3AwAgAiACKQL4ATcDqAEgBCACQYABakEFEE8gAkHYAGoiASAEIAJBqAFqEDQgBCACQQhqIAEQNCAAIAQQSSACQaACaiQAIANBoAFqJAALJQAgAEUEQEHoq8MAQTIQogMACyAAIAIgAyAEIAUgASgCEBEQAAulAgEIfyMAQRBrIgIkACMAQRBrIgMkACADQQhqIQQjAEEgayIBJAAjAEEwayIAJAAgAEEgaiIFQgA3AwAgAEEYaiIGQgA3AwAgAEEQaiIHQgA3AwAgAEIANwMIIABBCGoQ3QEgAUEYaiAFKQMANwAAIAFBEGogBikDADcAACABQQhqIAcpAwA3AAAgASAAKQMINwAAIABBMGokAEEgQQEQ+gIiAEUEQEEBQSAQrAMACyAAIAEpAAA3AAAgAEEYaiABQRhqKQAANwAAIABBEGogAUEQaikAADcAACAAQQhqIAFBCGopAAA3AAAgARDMASAEQSA2AgQgBCAANgIAIAFBIGokACACIAMpAwg3AgAgA0EQaiQAIAIoAgAgAigCBCACQRBqJAALxwIBCX8jAEEQayIDJAAjAEEQayIEJAAgBEEIaiEFIwBB0AJrIgAkACAAQYACaiICQgA3AwAgAEH4AWoiBkIANwMAIABB8AFqIgdCADcDACAAQgA3A+gBIABB6AFqIggQ3QEgAEGPAmoiASAIEDkgAEEIaiABEKkCIAEQygEgAEHQAWogBykDADcCACAAQdgBaiAGKQMANwIAIABB4AFqIAIpAwA3AgAgACAAKQPoATcCyAFBIEEBEPoCIgFFBEBBAUEgEKwDAAsgASAAQcgBaiICKQAANwAAIAFBGGogAkEYaikAADcAACABQRBqIAJBEGopAAA3AAAgAUEIaiACQQhqKQAANwAAIABBCGoQzQEgBUEgNgIEIAUgATYCACAAQdACaiQAIAMgBCkDCDcCACAEQRBqJAAgAygCACADKAIEIANBEGokAAsjACAARQRAQeirwwBBMhCiAwALIAAgAiADIAQgASgCEBERAAsjACAARQRAQeirwwBBMhCiAwALIAAgAiADIAQgASgCEBE5AAsjACAARQRAQeirwwBBMhCiAwALIAAgAiADIAQgASgCEBEJAAsjACAARQRAQeirwwBBMhCiAwALIAAgAiADIAQgASgCEBE7AAsjACAARQRAQeirwwBBMhCiAwALIAAgAiADIAQgASgCEBE9AAsoAQF/IAAoAgAiAUGAgICAeHJBgICAgHhHBEAgACgCBCABQQEQhwMLCx4AIAAgAUEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAshACAARQRAQeirwwBBMhCiAwALIAAgAiADIAEoAhARAwALIgAgAC0AAEUEQCABQfzhxABBBRBVDwsgAUGB4sQAQQQQVQsbACAAKAIAIgBBBGooAgAgAEEIaigCACABEEELHwAgAEUEQEHoq8MAQTIQogMACyAAIAIgASgCEBEAAAscACAAIAAtAAQgAUEuRnI6AAQgACgCACABEPcCCxoBAX8gACgCACIBBEAgACgCBCABQQEQhwMLCxwAIAAoAgAi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AgwgA0Hc88QANgIIIANCAjcCFCADIANBBGqtQoCAgIDACIQ3AyggAyADrUKAgICAwAiENwMgIAMgA0EgajYCECADQQhqIAIQxwIAC2sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0H888QANgIIIANCAjcCFCADIANBBGqtQoCAgIDACIQ3AyggAyADrUKAgICAwAiENwMgIAMgA0EgajYCECADQQhqIAIQxwIAC2sBAX8jAEEwayIDJAAgAyABNgIEIAMgADYCACADQQI2AgwgA0Gw9MQANgIIIANCAjcCFCADIANBBGqtQoCAgIDACIQ3AyggAyADrUKAgICAwAiENwMgIAMgA0EgajYCECADQQhqIAIQxwIACw8AQY3dxABBKyAAEKACAAuVAgIBfgJ/IAAoAgApAwAhAiMAQYABayIEJAACfwJAIAEoAggiAEGAgIAQcUUEQCAAQYCAgCBxDQEgAUEBQQFBACAEIAIgBBCXASIAakEUIABrEE0MAgtBACEAA0AgACAEakH/AGogAqdBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkIPViACQgSIIQINAAsgAUEBQd/fxABBAiAAIARqQYABakEAIABrEE0MAQtBACEAA0AgACAEakH/AGogAqdBD3EiA0EwciADQTdqIANBCkkbOgAAIABBAWshACACQg9WIAJCBIghAg0ACyABQQFB39/EAEECIAAgBGpBgAFqQQAgAGsQTQsgBEGAAWokAAupAQEBfyAAKAIAIwBBQGoiACQAKAIAIQIgAEIANwM4IABBOGogAiUBEB0gACAAKAI8IgI2AjQgACAAKAI4NgIwIAAgAjYCLCAAIABBLGqtQoCAgIDwD4Q3AyAgAEECNgIMIABB6K3DADYCCCAAQgE3AhQgACAAQSBqNgIQIAEoAgAgASgCBCAAQQhqEF8gACgCLCICBEAgACgCMCACQQEQhwMLIABBQGskAAsNACAAQaSswAAgARBfCw4AIAFBlK3AAEEFEPYCCw4AIAFB9LLAAEEFEPYCCw4AIAFBuLTAAEEREPYCCw4AIAFB4LvAAEEQEPYCCw4AIAFBqrzAAEEZEPYCCw4AIAFB3bzAAEEaEPYCCw0AIABBhMPAACABEF8LDgAgAUHEyMAAQQUQ9gILDgAgAUGozMAA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IABCATcCFCAAIABBL2qtQoCAgICAFoQ3AyAgACAAQSBqNgIQIABBCGpBmKrAABDHAgALCAAgACUBEAQLFQIBbwF/EB8hABCAASIBIAAmASABCwIACwvg8gRAAEGAgMAAC+MoL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9tYXAvZW50cnkucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZV9zdWZmaXgucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jdXJ2ZTI1NTE5LWRhbGVrLTQuMS4zL3NyYy93aW5kb3cucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9ncmlzdS5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL2JveGVkL2NvbnZlcnQucnMAbGlicmFyeS9hbGxvYy9zcmMvZm10LnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvdmVjL2luX3BsYWNlX2NvbGxlY3QucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZGl5X2Zsb2F0LnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vL1dvcmtzcGFjZS9naXRodWIvamF6ei9jcmF0ZXMvY29qc29uLWNvcmUvc3JjL2NvcmUva2V5cy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3JhbmRfY29yZS0wLjYuNC9zcmMvb3MucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi93YXNtLWJpbmRnZW4tMC4yLjEwMC9zcmMvY29udmVydC9pbXBscy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvc3RkL3NyYy9pby9pbXBscy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3dhc20tYmluZGdlbi0wLjIuMTAwL3NyYy9jb252ZXJ0L3NsaWNlcy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL2Vkd2FyZHMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2Vycm9yLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9zZXIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zaWduYXR1cmUtMi4yLjAvc3JjL3NpZ25lci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2N1cnZlMjU1MTktZGFsZWstNC4xLjMvc3JjL3NjYWxhci5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vZmx0MmRlYy9zdHJhdGVneS9kcmFnb24ucnMAbGlicmFyeS9jb3JlL3NyYy9udW0vYmlnbnVtLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvY2lwaGVyLTAuNC40L3NyYy9zdHJlYW0ucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vV29ya3NwYWNlL2dpdGh1Yi9qYXp6L2NyYXRlcy9jb2pzb24tY29yZS9zcmMvY29yZS9zZXNzaW9uX2xvZy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vV29ya3NwYWNlL2dpdGh1Yi9qYXp6L2NyYXRlcy9jb2pzb24tY29yZS9zcmMvY29yZS9jYWNoZS5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25vZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iczU4LTAuNS4xL3NyYy9lbmNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmNvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9iYXNlNjQtMC4yMi4xL3NyYy9lbmdpbmUvZ2VuZXJhbF9wdXJwb3NlL2RlY29kZS5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2JzNTgtMC41LjEvc3JjL2RlY29kZS5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3NlcmRlLTEuMC4yMjgvc3JjL3ByaXZhdGUvZGUucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9zZXJkZV9qc29uLTEuMC4xNDIvc3JjL2RlLnJzAGNvanNvbi1jb3JlL3NyYy9jb3JlL25vbmNlLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAL3J1c3RjLzExNTllNzhjNDc0N2IwMmVmOTk2ZTU1MDgyYjcwNGMwOWI5NzA1ODgvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9oYXNoYnJvd24tMC4xNS41L3NyYy9yYXcvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvZm10L21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL2Jhc2U2NC0wLjIyLjEvc3JjL2VuZ2luZS9nZW5lcmFsX3B1cnBvc2UvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmFzZTY0LTAuMjIuMS9zcmMvZW5naW5lL21vZC5ycwAvVXNlcnMvYW50b25pby5tdXNvbGluby8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzAC9ydXN0Yy8xMTU5ZTc4YzQ3NDdiMDJlZjk5NmU1NTA4MmI3MDRjMDliOTcwNTg4L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzAGxpYnJhcnkvY29yZS9zcmMvbnVtL2ZsdDJkZWMvbW9kLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvc2VyZGVfanNvbi0xLjAuMTQyL3NyYy9yZWFkLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjEwL3NyYy9kbG1hbGxvYy5ycwBsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hcnJheXZlYy0wLjcuNi9zcmMvYXJyYXl2ZWMucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9mb2xkaGFzaC0wLjEuNS9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAC9Vc2Vycy9hbnRvbmlvLm11c29saW5vLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYmxha2UzLTEuOC4yL3NyYy9saWIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9hZWFkLTAuNS4yL3NyYy9saWIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9scnUtMC4xNi4xL3NyYy9saWIucnMAL1VzZXJzL2FudG9uaW8ubXVzb2xpbm8vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9jcnlwdG9fc2VjcmV0Ym94LTAuMS4xL3NyYy9saWIucnMAY29qc29uLWNvcmUvc3JjL2NyeXB0by94c2Fsc2EyMC5ycwBTExAAYgAAAJQBAAA2AAAA//////////9YFBAAQfCowAALyQP1AhAAUQAAAFoAAAARAAAA9QIQAFEAAAAVAAAAEQAAAEhhc2ggdGFibGUgY2FwYWNpdHkgb3ZlcmZsb3eQFBAAHAAAADoOEABsAAAAJQAAACgAAAD1BRAAagAAAKkIAAAWAAAAfQAAACUEEAB3AAAA+AEAAA4AAAD1AhAAUQAAAC0AAAARAAAA9QIQAFEAAABpAAAAEQAAAHAIEABYAAAADQAAABEAAADzCRAAUgAAAAgAAAARAAAASnNWYWx1ZSBFcnJvcjogACgVEAAPAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2Vkc2lnbmF0dXJlZW5jcnlwdGVkX2NoYW5nZXNtZXRhRXhwZWN0ZWQgcHJpdmF0ZSB0cmFuc2FjdGlvbgAAAJ0EEAB3AAAAJAEAAA4AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2Rl8AwQAGkAAACgBAAAIgAAAPAMEABpAAAAlgQAACYAAABPERAAawAAAHsEAAAPAAAAAgAAAAwAAAAEAAAAAwAAAAQAAAAFAEHErMAAC9UFAQAAAAYAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AMkIEAB3AAAADwsAAA4AAABFcnJvcgAAAAAAAAAEAAAABAAAAAgAAAAAAAAABAAAAAQAAAAJAAAAVXRmOEVycm9ydmFsaWRfdXBfdG9lcnJvcl9sZW4AAACfEBAAawAAAOcCAAAdAAAAeA0QAHYAAAC9AQAAHQAAAJ0EEAB3AAAAJAEAAA4AAABJbnZhbGlkIFVURi04IGluIHNlY3JldDogAAAADBcQABkAAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2Rl9QUQAGoAAACBAgAAKgAAAAAAAAAEAAAABAAAAAsAAAAAAAAABAAAAAQAAAAJAAAAVXRmOEVycm9ydmFsaWRfdXBfdG9lcnJvcl9sZW5Ob25lAAAAAAAAAAQAAAAEAAAADAAAAFNvbWV4DRAAdgAAAL0BAAAdAAAAYXR0ZW1wdGVkIHRvIHRha2Ugb3duZXJzaGlwIG9mIFJ1c3QgdmFsdWUgd2hpbGUgaXQgd2FzIGJvcnJvd2VkAGfmCWqFrme7cvNuPDr1T6V/Ug5RjGgFm6vZgx8ZzeBbSW52YWxpZCBVVEYtOCBpbiBzZWNyZXQ6IAAAADAYEAAZAAAAnQQQAHcAAAAkAQAADgAAAEludmFsaWQgVVRGLTggaW4gc2lnbmF0dXJlOiBkGBAAHAAAAEludmFsaWQgVVRGLTggaW4gaWQ6IAAAAIgYEAAVAAAARmFpbGVkIHRvIHBhcnNlIHRyYW5zYWN0aW9uIHN0cmluZzogqBgQACQAAABNAhAAhQAAAPsAAAABAAAAeA0QAHYAAACnAQAAHwAAAHgNEAB2AAAArgEAACYAAAAOAAAADAAAAAQAAAAPAAAAEAAAAAUAQaSywAALnwgBAAAAEQAAAGEgRGlzcGxheSBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB1bmV4cGVjdGVkbHkAyQgQAHcAAAAPCwAADgAAAEVycm9ySW52YWxpZCBzaWduaW5nIGtleSBsZW5ndGhJbnZhbGlkIHZlcmlmeWluZyBrZXkgbGVuZ3RoSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoAK0PEAB8AAAALgIAABEAAABWZXJpZnlpbmdLZXn1BRAAagAAAKkIAAAWAAAAfQAAACUEEAB3AAAA+AEAAA4AAAA9BxAAewAAAOUFAAAUAAAAPQcQAHsAAADlBQAAIQAAAD0HEAB7AAAA2QUAACEAAABTdHJlYW1DaXBoZXJFcnJvcgAAAD0HEAB7AAAAaQQAACQAAAB4DRAAdgAAAL0BAAAdAAAAZ+YJaoWuZ7ty8248OvVPpX9SDlGMaAWbq9mDHxnN4FsTAAAACAAAAAQAAAAUAAAASW52YWxpZCBwdWJsaWMga2V5AAClCBAAIwAAAF8AAAASAAAAFQAAABQAAAAEAAAAFgAAAKUIEAAjAAAAXAAAABoAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcI/////////wkKCwwNDg8Q/xESExQV/xYXGBkaGxwdHh8g////////ISIjJCUmJygpKiv/LC0uLzAxMjM0NTY3ODn//////zEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXoiaGFzaF96IgAAmhsQAAcAAAChGxAAAQAAACoDEAAcAAAALQAAABEAAAClCBAAIwAAAK0AAAAkAAAAAQABQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX////////////////////////////////////////////////////////////z7//zQ1Njc4OTo7PD3/////////AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBn/////P/8aGxwdHh8gISIjJCUmJygpKissLS4vMDEyM/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9lbmNyeXB0ZWRfVQAAFx0QAAsAAAAqAxAAHAAAAFUAAAARAAAAcHJpdmF0ZQBBzLrAAAv9BQEAAAAXAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQAICBAAZwAAAHgAAAAnAAAApQgQACMAAAD6AAAAIAAAABgAAAAEAAAABAAAABkAAAClCBAAIwAAAPgAAAA2AAAApQgQACMAAAAnAQAANAAAAKUIEAAjAAAAUgEAADgAAABmaWVsZCBpZGVudGlmaWVyUHJpdmF0ZVRyYW5zYWN0aW9uZW5jcnlwdGVkQ2hhbmdlc2tleVVzZWRtYWRlQXRtZXRhcHJpdmFjeXN0cnVjdCBQcml2YXRlVHJhbnNhY3Rpb25UcnVzdGluZ1RyYW5zYWN0aW9uY2hhbmdlc3N0cnVjdCBUcnVzdGluZ1RyYW5zYWN0aW9uAAIeEAAQAAAAEh4QAAcAAAAZHhAABgAAAB8eEAAEAAAAIx4QAAcAAABWHhAABwAAABkeEAAGAAAAHx4QAAQAAAAjHhAABwAAAGRhdGEgZGlkIG5vdCBtYXRjaCBhbnkgdmFyaWFudCBvZiB1bnRhZ2dlZCBlbnVtIFRyYW5zYWN0aW9uAAAAAAAEAAAABAAAABoAAABUcmFuc2FjdGlvbk5vdEZvdW5kSW52YWxpZEVuY3J5cHRlZFByZWZpeAAAAAAAAAAEAAAABAAAABsAAABCYXNlNjREZWNvZGUAAAAABAAAAAQAAAAcAAAAVXRmOAAAAAAEAAAABAAAAB0AAABKc29uAAAAAAQAAAAEAAAAHgAAAFNpZ25hdHVyZVZlcmlmaWNhdGlvbkludmFsaWREZWNvZGluZ1ByZWZpeAAAAAAAAAQAAAAEAAAAHwAAAAAAAAAEAAAABAAAACAAAABJbnZhbGlkS2V5TGVuZ3RoAAAAAAQAAAAEAAAAIQAAAEludmFsaWRCYXNlNTgAAABTExAAYgAAAJQBAAA2AAAASGFzaCB0YWJsZSBjYXBhY2l0eSBvdmVyZmxvdxggEAAcAAAAOg4QAGwAAAAlAAAAKABB1MDAAAsFAQAAACIAQeTAwAALBQEAAAAjAEH0wMAACwUBAAAAJABBhMHAAAsFAQAAACUAQZTBwAAL1QYBAAAAJQAAAAAAAAAEAAAABAAAACYAAAB4DRAAdgAAAL0BAAAdAAAAgwwQAGwAAADzAQAAFQAAAIMMEABsAAAA4wEAABUAAABzdHJ1Y3QgUHJpdmF0ZVRyYW5zYWN0aW9uIHdpdGggNSBlbGVtZW50cwAAANwgEAApAAAAAAAAAAgAAAAEAAAAJwAAAGVuY3J5cHRlZENoYW5nZXNrZXlVc2VkbWFkZUF0bWV0YXByaXZhY3lzdHJ1Y3QgVHJ1c3RpbmdUcmFuc2FjdGlvbiB3aXRoIDQgZWxlbWVudHMAAEghEAAqAAAAY2hhbmdlcwApAAAADAAAAAQAAAAqAAAAKwAAACwAAAAAAAAABAAAAAQAAAAtAAAAPQcQAHsAAADlBQAAFAAAAD0HEAB7AAAA5QUAACEAAAA9BxAAewAAANkFAAAhAAAAKQAAAAwAAAAEAAAALgAAAAAAAAAEAAAABAAAAC8AAABGcm9tVXRmOEVycm9yYnl0ZXNlcnJvcgAwAAAAFAAAAAQAAAAxAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQDOChAAZQAAAJMAAAArAAAAPQcQAHsAAABpBAAAJAAAADIAAAAIAAAABAAAABQAAABzaWduYXR1cmUgb3BlcmF0aW9uIGZhaWxlZAAAYAYQAGoAAAAQAAAAHAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNpZ25hdHVyZV96AAAAZiMQAAsAAABfegAAKgMQABwAAAB0AAAAGAAAAE8REABrAAAAewQAAA8AAABIYXNoIHRhYmxlIGNhcGFjaXR5IG92ZXJmbG93oCMQABwAAAA6DhAAbAAAACUAAAAoAAAANAAAAAwAAAAEAAAANQAAADYAAAAsAEH0x8AAC7kDAQAAADcAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AMkIEAB3AAAADwsAAA4AAABFcnJvcnNlYWxlclNlY3JldF96c2VhbGVyIHNlY3JldP////////////////////////////////////////////////////////////////8AAQIDBAUGBwj/////////CQoLDA0ODxD/ERITFBX/FhcYGRobHB0eHyD///////8hIiMkJSYnKCkqK/8sLS4vMDEyMzQ1Njc4Of//////MTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5enNlYWxlcl96AAAeJRAACAAAAGtleVNlY3JldF96a2V5IHNlY3JldHNpZ25lclNlY3JldF96c2lnbmVyIHNlY3JldHNpZ25hdHVyZV96AGAlEAALAAAAc2lnbmF0dXJlc2lnbmVyX3pzaWduZXIgSUQAAH0lEAAIAAAAOAAAAAwAAAAEAAAAOQAAADoAAAAsAEG4y8AAC4EIAQAAADsAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5AMkIEAB3AAAADwsAAA4AAABkZXN0IGlzIG91dCBvZiBib3VuZHMAAAAIJhAAFQAAAEVycm9yc2VhbGVyU2VjcmV0X3pzZWFsZXIgc2VjcmV0////////////////////////////////////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AM4KEABlAAAAuQEAACAAQYzbwAALpQQBAAAATgAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAzgoQAGUAAAA9AQAAIAAAAEJ1ZmZlclRvb1NtYWxsTm9uZQAAAAAAAAQAAAAEAAAALQAAAFNvbWVJbnZhbGlkIGtleSBsZW5ndGggKGV4cGVjdGVkICwgZ290ICn4LRAAHQAAABUuEAAGAAAAGy4QAAEAAABJbnZhbGlkIG5vbmNlIGxlbmd0aEludmFsaWQgc2VhbGVyIHNlY3JldCBmb3JtYXQ6IG11c3Qgc3RhcnQgd2l0aCAnc2VhbGVyU2VjcmV0X3onSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoSW52YWxpZCB2ZXJpZnlpbmcga2V5OiAAAACeLhAAFwAAAEludmFsaWQgcHVibGljIGtleTogwC4QABQAAABXcm9uZyB0YWdGYWlsZWQgdG8gY3JlYXRlIGNpcGhlckludmFsaWQgIGZvcm1hdDogbXVzdCBzdGFydCB3aXRoICcnAPwuEAAIAAAABC8QABoAAAAeLxAAAQAAAEludmFsaWQgYmFzZTU4OiA4LxAAEAAAAFN0cmVhbUNpcGhlckVycm9yAAAAeA0QAHYAAAC9AQAAHQAAACoDEAAcAAAAWgAAABEAAAAoChAAHQAAABgAAAAxAAAAKgMQABwAAAAVAAAAEQAAACgKEAAdAAAAJQAAADgAQbzfwAALYQEAAABPAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQAICBAAZwAAAHgAAAAnAAAAJRQQACIAAABOAAAAEAAAACUUEAAiAAAAZwAAABAAQajgwAAL1QcBAAAAUAAAAGZhbHNlbm90IGEgSlNPTiBudW1iZXIwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkx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cnVjdGlvbiBub3Qgc3VwcG9ydGVkV2ViIENyeXB0byBBUEkgaXMgdW5hdmFpbGFibGVDYWxsaW5nIFdlYiBBUEkgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBmYWlsZWRyYW5kU2VjdXJlOiBWeFdvcmtzIFJORyBtb2R1bGUgaXMgbm90IGluaXRpYWxpemVkTm9kZS5qcyBjcnlwdG8gQ29tbW9uSlMgbW9kdWxlIGlzIHVuYXZhaWxhYmxlQ2FsbGluZyBOb2RlLmpzIEFQSSBjcnlwdG8ucmFuZG9tRmlsbFN5bmMgZmFpbGVkTm9kZS5qcyBFUyBtb2R1bGVzIGFyZSBub3QgZGlyZWN0bHkgc3VwcG9ydGVkLCBzZWUgaHR0cHM6Ly9kb2NzLnJzL2dldHJhbmRvbSNub2RlanMtZXMtbW9kdWxlLXN1cHBvcnQAAAAAAAAEAAAABAAAAGsAAABpbnRlcm5hbF9jb2RlAAAAAAAAAAgAAAAEAAAAbAAAAGRlc2NyaXB0aW9udW5rbm93bl9jb2RlAAAAAAAEAAAABAAAAG0AAABvc19lcnJvclVua25vd24gRXJyb3I6IAAQ1RAADwAAAE9TIEVycm9yOiAAACjVEAAKAAAAY3J5cHRvAABh0hAAiNIQAK7SEADC0hAA9NIQACHTEABQ0xAAcdMQAI7TEABB8KrDAAsxu9MQAOzTEAAZ1BAASdQQACcAAAAmAAAAFAAAADIAAAAtAAAALwAAACEAAAAdAAAALQBBrKvDAAuhBzEAAAAtAAAAMAAAAGUAAABkOxEAcDsRAHw7EQCIOxEAcmV0dXJuIHRoaXMAnQQQAHcAAAAkAQAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkGtYQACoAAAAiEhAAaAAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAAFzWEAAOAAAAIhIQAGgAAAB6AgAADQAAAK4DEAB2AAAAYQIAABYAAACuAxAAdgAAAHECAAAMAAAArgMQAHYAAABtAgAAEAAAAGFycmF5IGNvbnRhaW5zIGEgdmFsdWUgb2YgdGhlIHdyb25nIHR5cGVKc1ZhbHVl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AwAAGQAAAJ8QEABrAAAAeQMAABkAAACfEBAAawAAANQDAAARAAAA////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAABAAIAAwAEAAUABgAHAAgACQD//////////////////woACwAMAA0ADgAPAP////////////////////////////////////////////////////////////////////8KAAsADAANAA4ADwD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AABAAIAAwAEAAUABgAHAAgACQAP//////////////////oACwAMAA0ADgAPAA/////////////////////////////////////////////////////////////////////6AAsADAANAA4ADwAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////60PEAB8AAAALgIAABEAAAAwMTIzNDU2Nzg5YWJjZGVmdXV1dXV1dXVidG51ZnJ1dXV1dXV1dXV1dXV1dXV1dXUAACIAQZzawwALAVwAQcDbwwALgQJhIEpTT04gbnVtYmVyAAAAjAAAAAwAAAAEAAAAjQAAAI4AAACKAAAAaW5mLWluZk5hTjAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAAAAAAQBBz93DAAvRKiCamZmZmZmZmZmZmZmZmZkZFa5H4XoUrkfhehSuR+F6FN4kBoGVQ4ts5/up8dJNYhCW1AloImx4eqUsQxzr4jYaq0Nuhhvw+WGE8GjjiLX4FCI2WDhJ88e0No3ttaD3xhBqI43ADlKmh1dIr7ya8tcaiE/XZqVBuJ/fOYww4o55FQemEh9RAS3mspTWJugLLhGkCVHLgWiu1re6vdfZ33wb6jqnojTt8d5flWR54X/9FbvIhej28Cd/GRHqLYGZlxH4DdZAvrQMZcKBdklowiUck3HeM5iQcOoBmyuhhpuEFkPBfingpvMhmxVW556vAxI3NTEPzdeFaSu8idiXstIc+ZBaP9ffNyGJltRGRvUOF/pzSMxF5l/noKtD0tFdchJdhg16PD1mpTSs0rZPyYMdsZ7XlGOXHlFdI0KSDKGcF8FLed2C337afU+bDgq04xJorFti0ZhkKpblXhcQIDkeU/Digafgtu5EUbISQLMtGKkmT85STZJYaqeOqJnCVxNB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aW9uIGRlbmllZGNvbm5lY3Rpb24gcmVmdXNlZGNvbm5lY3Rpb24gcmVzZXRob3N0IHVucmVhY2hhYmxlbmV0d29yayB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gYWJvcnRlZG5vdCBjb25uZWN0ZWRhZGRyZXNzIGluIHVzZWFkZHJlc3Mgbm90IGF2YWlsYWJsZW5ldHdvcmsgZG93bmJyb2tlbiBwaXBlZW50aXR5IGFscmVhZHkgZXhpc3Rzb3BlcmF0aW9uIHdvdWxkIGJsb2Nrbm90IGEgZGlyZWN0b3J5aXMgYSBkaXJlY3RvcnlkaXJlY3Rvcnkgbm90IGVtcHR5cmVhZC1vbmx5IGZpbGVzeXN0ZW0gb3Igc3RvcmFnZSBtZWRpdW1maWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVpbnZhbGlkIGlucHV0IHBhcmFtZXRlcmludmFsaWQgZGF0YXRpbWVkIG91dHdyaXRlIHplcm9ubyBzdG9yYWdlIHNwYWNlc2VlayBvbiB1bnNlZWthYmxlIGZpbGVxdW90YSBleGNlZWRlZGZpbGUgdG9vIGxhcmdlcmVzb3VyY2UgYnVzeWV4ZWN1dGFibGUgZmlsZSBidXN5ZGVhZGxvY2tjcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWV0b28gbWFueSBsaW5rc2ludmFsaWQgZmlsZW5hbWVhcmd1bWVudCBsaXN0IHRvbyBsb25nb3BlcmF0aW9uIGludGVycnVwdGVkdW5zdXBwb3J0ZWR1bmV4cGVjdGVkIGVuZCBvZiBmaWxlb3V0IG9mIG1lbW9yeWluIHByb2dyZXNzb3RoZXIgZXJyb3J1bmNhdGVnb3JpemVkIGVycm9yIChvcyBlcnJvciApAAAAAQAAAAAAAACxHREACwAAALwdEQABAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAA2B0RABUAAADtHREADQAAADYREAAYAAAAZAEAAAkAAACbAAAADAAAAAQAAACfAAAAAAAAAAgAAAAEAAAAoAAAAAAAAAAIAAAABAAAAKEAAACiAAAAowAAAKQAAAClAAAAEAAA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"; async function pm() { const A = await (await fetch(ym)).arrayBuffer(); return await iu({ module_or_path: A }) } let BC = pm; class Tr extends pE { constructor() { super() } static setInit(A) { BC = A } static async create() { try { await BC() } catch (A) { return x.warn("Failed to initialize WasmCrypto, falling back to PureJSCrypto", { err: A }), new HI } return new Tr } blake3HashOnce(A) { return Em(A) } blake3HashOnceWithContext(A, { context: g }) { return cm(A, g) } newEd25519SigningKey() { return wm() } getSignerID(A) { return lm(gA.encode(A)) } sign(A, g) { return um(gA.encode($(g)), gA.encode(A)) } verify(A, g, I) { return hm(gA.encode(A), gA.encode($(g)), gA.encode(I)) } newX25519StaticSecret() { return om() } getSealerID(A) { return Cm(gA.encode(A)) } encrypt(A, g, I) { return `encrypted_U${ug(Bm(gA.encode($(A)), g, gA.encode($(I))))}` } decryptRaw(A, g, I) { return Xg.decode(Qm(cg(A.substring(11)), g, gA.encode($(I)))) } seal({ message: A, from: g, to: I, nOnceMaterial: t }) { return `sealed_U${ug(sm(gA.encode($(A)), g, I, gA.encode($(t))))}` } unseal(A, g, I, t) { const i = Xg.decode(am(cg(A.substring(8)), g, I, gA.encode($(t)))); try { return JSON.parse(i) } catch (n) { x.error("Failed to decrypt/parse sealed message", { err: n }); return } } createSessionLog(A, g, I) { return new Zr(new BI(A, g, I)) } } class Zr { constructor(A) { this.sessionLog = A } tryAdd(A, g, I) { this.sessionLog.tryAdd(A.map(t => $(t)), g, I) } addNewPrivateTransaction(A, g, I, t, i, n) { const r = this.sessionLog.addNewPrivateTransaction($(g), A.currentSignerSecret(), t, I, i, n ? $(n) : void 0), o = JSON.parse(r), C = { privacy: "private", madeAt: i, encryptedChanges: o.encrypted_changes, keyUsed: I, meta: o.meta }; return { signature: o.signature, transaction: C } } addNewTrustingTransaction(A, g, I, t) { const i = $(g), n = t ? $(t) : void 0; return { signature: this.sessionLog.addNewTrustingTransaction(i, A.currentSignerSecret(), I, n), transaction: { privacy: "trusting", madeAt: I, changes: i, meta: n } } } decryptNextTransactionChangesJson(A, g) { return this.sessionLog.decryptNextTransactionChangesJson(A, g) } decryptNextTransactionMetaJson(A, g) { return this.sessionLog.decryptNextTransactionMetaJson(A, g) } free() { this.sessionLog.free() } clone() { return new Zr(this.sessionLog.clone()) } } async function mm() { const A = await new $c().get(); if (!A) { console.error("No account data found in localStorage"); return } const g = btoa(A.accountSecret); window.open(new URL(`#/import/${A?.accountID}/${g}`, "https://inspector.jazz.tools").toString(), "_blank") } function Nm() { if (typeof window > "u") return; const e = A => { A.metaKey && A.key === "j" && confirm("Are you sure you want to inspect your account using inspector.jazz.tools? This lets anyone with the secret inspector URL read your data and impersonate you.") && mm() }; return window.addEventListener("keydown", e), () => { window.removeEventListener("keydown", e) } } function nu() { if (typeof window > "u") return; if (new URL(window.location.href).hash.includes("allowJazzInspector")) return Nm() } function km(e) { return { useIndexedDB: !e || Array.isArray(e) && e.includes("indexedDB") || e === "indexedDB" } } nu(); var Gm = class extends $p { onNetworkChange(e) { const A = () => e(navigator.onLine); return window.addEventListener("online", A), window.addEventListener("offline", A), () => { window.removeEventListener("online", A), window.removeEventListener("offline", A) } } }; async function ru(e) { const A = e.crypto || await Tr.create(); let g; const { useIndexedDB: I } = km(e.storage), t = [], i = I ? await im() : void 0; if (e.sync.when === "never") return { addConnectionListener: () => () => { }, connected: () => !1, toggleNetwork: () => { }, peers: t, storage: i, setNode: () => { }, crypto: A }; const n = new Gm({ peer: e.sync.peer, reconnectionTimeout: e.reconnectionTimeout, addPeer: C => { g ? g.syncManager.addPeer(C) : t.push(C) }, removePeer: C => { t.splice(t.indexOf(C), 1) } }); function r(C) { C ? n.enable() : n.disable() } function o(C) { g = C } return (e.sync.when === "always" || !e.sync.when) && r(!0), { toggleNetwork: r, addConnectionListener(C) { return n.subscribe(C), () => { n.unsubscribe(C) } }, connected() { return n.connected }, peers: t, storage: i, setNode: o, crypto: A } } async function Sm(e) { const { toggleNetwork: A, peers: g, setNode: I, crypto: t, storage: i, addConnectionListener: n, connected: r } = await ru(e), o = await Mc({ crypto: t, peers: g, storage: i }); return I(o.agent.node), e.authSecretStorage.emitUpdate(null), { guest: o.agent, node: o.agent.node, done: () => { A(!1), o.done() }, logOut: () => o.logOut(), addConnectionListener: n, connected: r } } async function Mm(e) { const { toggleNetwork: A, peers: g, setNode: I, crypto: t, storage: i, addConnectionListener: n, connected: r } = await ru(e); let o = () => { }; if (e.sync.when === "signedUp") { let B = function (E) { A(!!E) }; const Q = e.authSecretStorage, s = e.credentials ?? await Q.get(); o = Q.onUpdate(B), B(Q.getIsAuthenticated(s)) } const C = await np({ credentials: e.credentials, newAccountProps: e.newAccountProps, peers: g, storage: i, crypto: t, defaultProfileName: e.defaultProfileName, AccountSchema: e.AccountSchema, sessionProvider: Fm, authSecretStorage: e.authSecretStorage }); return I(C.node), { me: C.account, node: C.node, authSecretStorage: C.authSecretStorage, done: () => { A(!1), o(), C.done() }, logOut: () => (o(), C.logOut()), addConnectionListener: n, connected: r } } function Fm(e, A) { if (typeof navigator > "u" || !navigator.locks?.request) return Promise.resolve({ sessionID: A.newRandomSessionID(e), sessionDone: () => { } }); let g; const I = new Promise(n => { g = n }); let t; const i = new Promise(n => { t = n }); return (async function () { for (let n = 0; n < 100; n++)for (let r = 0; r < 2; r++)if (await navigator.locks.request(e + "_" + n, { ifAvailable: !0 }, async C => { if (!C) return "noLock"; const B = localStorage.getItem(e + "_" + n) || A.newRandomSessionID(e); return localStorage.setItem(e + "_" + n, B), t(B), await I, console.log("Done with lock", e + "_" + n, B), "sessionFinished" }) === "sessionFinished") return; throw new Error("Couldn't get lock on session after 100x2 tries") })(), i.then(n => ({ sessionID: n, sessionDone: g })) } var Um = class { constructor() { } async get(e) { return localStorage.getItem(e) } async set(e, A) { localStorage.setItem(e, A) } async delete(e) { localStorage.removeItem(e) } async clearAll() { localStorage.clear() } }, Rm = class extends Yp { getKvStore() { return typeof window > "u" ? new Au : new Um } async getNewContext(e, A) { return e.guestMode ? Sm({ sync: e.sync, storage: e.storage, authSecretStorage: this.authSecretStorage }) : Mm({ sync: e.sync, storage: e.storage, AccountSchema: e.AccountSchema, credentials: A?.credentials, newAccountProps: A?.newAccountProps, defaultProfileName: e.defaultProfileName, authSecretStorage: this.authSecretStorage }) } propsChanged(e) { return this.props ? this.props.sync.when !== e.sync.when || this.props.sync.peer !== e.sync.peer || this.props.guestMode !== e.guestMode : !0 } }; nu(); const bm = xr.map({ title: mi.string(), completed: mi.boolean() }), ou = xr.list(bm); await navigator.locks.request("jazz-context", async () => { await new Rm().createContext({ sync: { peer: "wss://cloud.jazz.tools?key=minimal-vanilla-example" } }) }); const Pr = new URLSearchParams(window.location.search).get("id"); if (!Pr) { const e = ou.create([{ title: "Learn Jazz", completed: !1 }]); throw await e.$jazz.waitForSync(), window.parent.postMessage({ type: "id-generated", id: e.$jazz.id }, "*"), window.location.search = `?id=${e.$jazz.id}`, new Error("Redirecting...") } const Ym = document.querySelector("#app"), Km = Object.assign(document.createElement("small"), { innerText: `List ID: ${Pr}` }), Cu = document.createElement("div"); Ym.append(Cu, Km); function vm(e) { const A = document.createElement("label"), g = Object.assign(document.createElement("input"), { type: "checkbox", checked: e.completed, onclick: () => e.$jazz.set("completed", g.checked) }); return A.append(g, e.title), A } function Jm(e) { const A = document.createElement("form"), g = Object.assign(document.createElement("input"), { placeholder: "New task" }), I = Object.assign(document.createElement("button"), { innerText: "Add" }); return A.onsubmit = () => e.$jazz.push({ title: g.value, completed: !1 }), A.append(g, I), A } ou.subscribe(Pr, { resolve: { $each: !0 } }, e => { const A = Jm(e); Cu.replaceChildren(...e.map(g => vm(g)), A) });

  </script>
</body>

</html>