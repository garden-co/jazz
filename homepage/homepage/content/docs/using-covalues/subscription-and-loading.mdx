import { Alert, CodeGroup, ContentByFramework, ReactLogo, SvelteLogo, TabbedCodeGroup, TabbedCodeGroupItem } from "@/components/forMdx";

export const metadata = {
  description: "Learn how to subscribe to CoValues, specify loading depths, and handle loading states and inaccessible data."
};

# Subscriptions & Deep Loading

Jazz's Collaborative Values (such as [CoMaps](/docs/using-covalues/comaps) or [CoLists](/docs/using-covalues/colists)) are reactive. You can subscribe to them to automatically receive updates whenever they change, either locally or remotely.

You can also use subscriptions to load CoValues *deeply* by resolving nested values. You can specify exactly how much data you want to resolve and handle loading states and errors.

You can load and subscribe to CoValues in one of two ways:

- **shallowly**&hairsp;—&hairsp;all of the primitive fields are available (such as strings, numbers, dates), but the references to other CoValues are not loaded
- **deeply**&hairsp;—&hairsp;some or all of the referenced CoValues have been loaded

## Subscription Hooks

On your front-end, using a subscription hook is the easiest way to manage your subscriptions. The subscription and related clean-up is handled automatically, and you can use your data like any other piece of state in your app.

### Subscribe to CoValues
<ContentByFramework framework="react">
The `useCoState` hook allows you to reactively subscribe to CoValues in your React components. It will subscribe to updates when the component mounts and unsubscribe when it unmounts, ensuring your UI stays in sync and avoiding memory leaks.
</ContentByFramework>
<ContentByFramework framework="svelte">
The `CoState` class allows you to reactively subscribe to CoValues in your Svelte components. It will subscribe to updates when the component mounts and unsubscribe when it unmounts, ensuring your UI stays in sync and avoiding memory leaks.
</ContentByFramework>

<TabbedCodeGroup id="usecostate" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
import { useCoState } from "jazz-tools/react";

function ProjectView({ projectId }: { projectId: string }) {
  // Subscribe to a project and resolve its tasks
  const project = useCoState(Project, projectId, {
    resolve: { tasks: { $each: true } } // Tell Jazz to load each task in the list
  });
  
  if (!project.$isLoaded) {
    switch (project.$jazz.loadingState) {
      case "unauthorized":
        return "Project not accessible";
      case "unavailable":
        return "Project not found";
      case "unloaded":
        return "Loading project...";
    }
  }

  return (
    <div>
      <h1>{project.name}</h1>
      <ul>
        {project.tasks.map((task) => (
          <li key={task.$jazz.id}>{task.title}</li>
        ))}
      </ul>
    </div>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { CoState } from "jazz-tools/svelte";

  const { projectId } : { projectId: string } = $props();

  // Subscribe to a project and resolve its tasks
  const project = new CoState(Project, projectId, {
    resolve: { tasks: { $each: true } } // Tell Jazz to load each task in the list
  });
</script>

{#if !project.current.$isLoaded}
  switch (project.current.$jazz.loadingState) {
    case "unauthorized":
      return "Project not accessible";
    case "unavailable":
      return "Project not found";
    case "unloaded":
      return "Loading project...";
  }
{:else}
  <div>
    <h1>{project.current.name}</h1>
    <ul>
      {#each project.current.tasks as task (task.$jazz.id)}
        <li>{task.title}</li>
      {/each}
    </ul>
  </div>
{/if}
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>
**Note:** If you don't need to load a CoValue's references, you can choose to load it *shallowly* by omitting the resolve query.

### Subscribe to the current user's account

<ContentByFramework framework="react">
`useAccount` is similar to `useCoState`, but it returns the current user's account. You can use this at the top level of your app to subscribe to the current user's [account profile and root](/docs/schemas/accounts-and-migrations#covalues-as-a-graph-of-data-rooted-in-accounts).
</ContentByFramework>
<ContentByFramework framework="svelte">
`AccountCoState` is similar to `CoState`, but it returns the current user's account. You can use this at the top level of your app to subscribe to the current user's [account profile and root](/docs/schemas/accounts-and-migrations#covalues-as-a-graph-of-data-rooted-in-accounts).
</ContentByFramework>

<TabbedCodeGroup id="usecostate" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
import { useAccount } from "jazz-tools/react";

function ProjectList() {
  const me = useAccount(MyAppAccount, {
    resolve: { profile: true }
  })

  if (!me.$isLoaded) {
    return "Loading...";
  }

  return (
    <div>
      <h1>{me.profile.name}'s projects</h1>
    </div>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { AccountCoState } from "jazz-tools/svelte";

  const account = new AccountCoState(MyAppAccount, {
    resolve: { profile: true }
  });
</script>

{#if !account.current.$isLoaded}
  Loading...
{:else}
  <div>
    <h1>{account.current.profile.name}'s projects</h1>
  </div>
{/if}
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

### Loading States

When you load or subscribe to a CoValue through a hook (or directly), it can be either:

- **Loaded** → The CoValue has been successfully loaded and all its data is available
- **Not Loaded** → The CoValue is not yet available

You can use the `$isLoaded` field to check whether a CoValue is loaded. For more detailed information about why a CoValue is not loaded, you can check `$jazz.loadingState`:

- `"unloaded"` → The CoValue is still being fetched
- `"unauthorized"` → The current user doesn't have permission to access this CoValue
- `"unavailable"` → The CoValue couldn't be found or an error (e.g. a network timeout) occurred while loading

See the examples above for practical demonstrations of how to handle these three states in your application.

## Deep Loading

When you're working with related CoValues (like tasks in a project), you often need to load nested references as well as the top-level CoValue. 

This is particularly the case when working with [CoMaps](https://jazz.tools/docs/react/using-covalues/comaps) that refer to other CoValues or [CoLists](https://jazz.tools/docs/react/using-covalues/colists) of CoValues. You can use `resolve` queries to tell Jazz what data you need to use.

### Using Resolve Queries

A `resolve` query tells Jazz how deeply to load data for your app to use. We can use `true` to tell Jazz to shallowly load the tasks list here. Note that this does *not* cause the tasks themselves to load, just the CoList that holds the tasks.

<CodeGroup>
```ts
const Task = co.map({
  title: z.string(),
  description: co.plainText().optional(),
  get subtasks() { return co.list(Task).optional() }
});

const Project = co.map({
  name: z.string(),
  tasks: co.list(Task)
});

const project = await Project.load(projectId);
if (!project.$isLoaded) throw new Error("Project not found or not accessible");

// This will be loaded
project.name; // string

// This *may not be loaded*, and *may not be accessible*
project.tasks; // ListOfTasks | NotLoaded<ListOfTasks>

const projectWithTasksShallow = await Project.load(projectId, {
  resolve: {
    tasks: true
  }
});
if (!projectWithTasksShallow.$isLoaded) throw new Error("Project not found or not accessible");

// This list of tasks will be shallowly loaded
projectWithTasksShallow.tasks; // ListOfTasks
// We can access the properties of the shallowly loaded list
projectWithTasksShallow.tasks.length; // number
// This *may not be loaded*, and *may not be accessible*
projectWithTasksShallow.tasks[0]; // Task | NotLoaded<Task>
```
</CodeGroup>

We can use an `$each` expression to tell Jazz to load the items in a list.

<CodeGroup>
```ts
const projectWithTasks = await Project.load(projectId, {
  resolve: {
    tasks: {
      $each: true
    }
  }
});
if (!projectWithTasks.$isLoaded) throw new Error("Project not found or not accessible");

// The task will be loaded
projectWithTasks.tasks[0]; // Task
// Primitive fields are always loaded
projectWithTasks.tasks[0].title; // string
// References on the Task may not be loaded
projectWithTasks.tasks[0].subtasks; // ListOfTasks | NotLoaded<ListOfTasks>
// CoTexts are CoValues too
projectWithTasks.tasks[0].description; // CoPlainText | NotLoaded<CoPlainText>
```
</CodeGroup>
We can also build a query that *deeply resolves* to multiple levels:

<CodeGroup>
```ts
const projectDeep = await Project.load(projectId, {
  resolve: {
    tasks: {
      $each: {
        subtasks: {
          $each: true
        },
        description: true
      }
    }
  }
});
if (!projectDeep.$isLoaded) throw new Error("Project not found or not accessible");

// Primitive fields are always loaded
projectDeep.tasks[0].subtasks[0].title; // string
// The description will be loaded as well
projectDeep.tasks[0].description; // CoPlainText
```
</CodeGroup>

<Alert title="Always load data explicitly" variant="warning" className="my-4">
If you access a reference that wasn't included in your `resolve` query, you may find that it is already loaded, potentially because some other part of your app has already loaded it. **You should not rely on this**.

Expecting data to be there which is not explicitly included in your `resolve` query can lead to subtle, hard-to-diagnose bugs. Always include every nested CoValue you need to access in your `resolve` query.
</Alert>

### Where To Use Resolve Queries

The syntax for resolve queries is shared throughout Jazz. As well as using them in `load` and `subscribe` method calls, you can pass a resolve query to a front-end hook.

<TabbedCodeGroup id="resolve" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
const projectWithTasksShallow = useCoState(Project, projectId, {
  resolve: {
    tasks: true
  }
});
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { CoState } from "jazz-tools/svelte";

  export let projectId: string;

  const projectWithTasksShallow = new CoState(Project, projectId, {
    resolve: {
      tasks: true
    }
  });
</script>
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

## Loading Errors

A load operation will be successful **only** if all references requested (both optional and required) could be successfully loaded. If any reference cannot be loaded, the entire load operation will return a not-loaded CoValue to avoid potential inconsistencies.

<CodeGroup preferWrap>
```ts
// If permissions on description are restricted:
const task = await Task.load(taskId, { 
  resolve: { description: true } 
});
task.$isLoaded // false
task.$jazz.loadingState // "unauthorized"
```
</CodeGroup>

This is also true if **any** element of a list is inaccessible, even if all the others can be loaded.

<CodeGroup preferWrap>
```ts
// One task in the list has restricted permissions
const project = await Project.load(projectId, {
  resolve: { tasks: { $each: true } }
});

project.$isLoaded // false
project.$jazz.loadingState // "unauthorized"
```
</CodeGroup>

Loading will be successful if all requested references are loaded. Non-requested references may or may not be available.

<CodeGroup preferWrap>
```ts
// One task in the list has restricted permissions
const project = await Project.load(projectId, {
  resolve: true
});
if (!project.$isLoaded) throw new Error("Project not found or not accessible");

// Assuming the user has permissions on the project, this load will succeed, even if the user cannot load one of the tasks in the list
project.$isLoaded // true
// Tasks may not be loaded since we didn't request them
project.tasks.$isLoaded // may be false
```
</CodeGroup>

### Catching loading errors

We can use `$onError` to handle cases where some data you have requested is inaccessible, similar to a `try...catch` block in your query.

For example, in case of a `project` (which the user can access) with three `task` items:

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>User can access <code>task</code>?</th>
      <th>User can access <code>task.description</code>?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>1</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>2</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

#### Scenario 1: Skip Inaccessible List Items

If some of your list items may not be accessible, you can skip loading them by specifying `$onError: 'catch'`. Inaccessible items will be not-loaded CoValues, while accessible items load properly.
<CodeGroup preferWrap>
```ts
// Inaccessible tasks will not be loaded, but the project will
const project = await Project.load(projectId, {
	resolve: { tasks: { $each: { $onError: 'catch' } } }
});
if (!project.$isLoaded) throw new Error("Project not found or not accessible");

project.tasks[0].$isLoaded; // true
project.tasks[1].$isLoaded; // true
project.tasks[2].$isLoaded; // false (caught by $onError)
```
</CodeGroup>
#### Scenario 2: Handling Inaccessible Nested References

An `$onError` applies only in the block where it's defined. If you need to handle multiple potential levels of error, you can nest `$onError` handlers.

This load will fail, because the `$onError` is defined only for the `task.description`, not for failures in loading the `task` itself.

<CodeGroup preferWrap>
```ts
const project = await Project.load(projectId, {
	resolve: {
		tasks: {
			$each: { description: { $onError: 'catch' } },
		}
	}
});

// The load fails because task[2] is inaccessible and no $onError caught it.
project.$isLoaded // false
```
</CodeGroup>
We can fix this by adding handlers at both levels

<CodeGroup preferWrap>
```ts
const project = await Project.load(projectId, {
	resolve: {
		tasks: {
			$each: { 
				description: { $onError: 'catch' }, // catch errors loading task descriptions
				$onError: 'catch' // catch errors loading tasks too
			},
		}
	}
});

project.$isLoaded // true
project.tasks[0].$isLoaded;                // true
project.tasks[0].description.$isLoaded;    // true
project.tasks[1].$isLoaded;                // true
project.tasks[1].description.$isLoaded;    // false (caught by the inner handler)
project.tasks[2].$isLoaded;                // false (caught by the outer handler)
```
</CodeGroup>

## Type safety with co.loaded

You can tell your application how deeply your data is loaded by using the `co.loaded` type.

The `co.loaded` type is especially useful when passing data between components, because it allows TypeScript to check at compile time whether data your application depends is properly loaded. The second argument lets you pass a `resolve` query to specify how deeply your data is loaded.

<TabbedCodeGroup id="coloaded" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
type ProjectWithTasks = co.loaded<typeof Project, 
  {
    tasks: { 
      $each: true
    };
  }
>;

// In case the project prop isn't loaded as required, TypeScript will warn
function TaskList({ project }: { project: ProjectWithTasks }) {
  // TypeScript knows tasks are loaded, so this is type-safe
  return (
    <ul>
      {project.tasks.map((task) => (
        <li key={task.$jazz.id}>{task.title}</li>
      ))}
    </ul>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { co } from "jazz-tools";

  type ProjectWithTasks = co.loaded<typeof Project, 
    {
      tasks: { 
        $each: true
      };
    }
  >;

  const { project } : { project: ProjectWithTasks } = $props();
</script>

<!-- In case the project prop isn't loaded as required, TypeScript will warn -->
<!-- TypeScript knows tasks are loaded, so this is type-safe -->
<ul>
  {#each project.tasks as task (task.$jazz.id)}
    <li>{task.title}</li>
  {/each}
</ul>
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

You can pass a `resolve` query of any complexity to `co.loaded`.

## Manual subscriptions

If you have a CoValue's ID, you can subscribe to it anywhere in your code using `CoValue.subscribe()`.

**Note:** Manual subscriptions are best suited for vanilla JavaScript&hairsp;—&hairsp;for example in server-side code or tests. Inside front-end components, we recommend using a subscription hook.

<CodeGroup preferWrap>
```ts
// Subscribe by ID
const unsubscribe = Task.subscribe(taskId, {}, (updatedTask) => {
  console.log("Updated task:", updatedTask);
});

// Always clean up when finished
unsubscribe();
```
</CodeGroup>

You can also subscribe to an existing CoValue instance using the `$jazz.subscribe` method.

<CodeGroup preferWrap>
```ts
const myTask = Task.create({
  title: 'My new task',
});

// Subscribe using $jazz.subscribe
const unsubscribe = myTask.$jazz.subscribe((updatedTask) => {
  console.log("Updated task:", updatedTask);
});

// Always clean up when finished
unsubscribe();
```
</CodeGroup>

<ContentByFramework framework={["react", "react-native", "react-native-expo"]}>

## Selectors [!framework=react,react-native,react-native-expo]
Sometimes, you only need to react to changes in specific parts of a CoValue. In those cases, you can provide a `select` function to specify what data you are interested in,
and an optional `equalityFn` option to control re-renders. 

- `select`: extract the fields you care about
- `equalityFn`: (optional) control when data should be considered equal

<CodeGroup>
```tsx
import { useCoState } from "jazz-tools/react";

function ProjectView({ projectId }: { projectId: string }) {
  // Subscribe to a project
  const project = useCoState(Project, projectId, {
    resolve: {
      tasks: true
    },
    select: (project) => {
      if (!project.$isLoaded) return project.$jazz.loadingState;
      return {
        name: project.name,
        taskCount: project.tasks.length,
      };
    },
    // Only re-render if the name or the number of tasks change
    equalityFn: (a, b) =>
      a?.name === b?.name && a?.taskCount === b?.taskCount
  });
  
  if (typeof project === 'string') {
    switch (project) {
      case "unauthorized":
        return "Project not accessible";
      case "unavailable":
        return "Project not found";
      case "unloaded":
        return "Loading...";
    }
  }

  return (
    <div>
      <h1>{project.name}</h1>
      <small>{project.taskCount} task(s)</small>
    </div>
  );
}
```
</CodeGroup>

By default, the return values of the select function will be compared using `Object.is`, but you can use the `equalityFn` to add your own logic.

You can also use `useAccount` in the same way, to subscribe to only the changes in a user's account you are interested in.

<CodeGroup>
```tsx
import { useAccount } from "jazz-tools/react";

function ProfileName() {
  // Only re-renders when the profile name changes
    const profileName = useAccount(MyAppAccount, {
    resolve: {
      profile: true,
    },
    select: (account) => account.$isLoaded ? account.profile.name : "Loading...",
  });

  return (
    <div>
      {profileName}
    </div>
  );
}
```
</CodeGroup>
</ContentByFramework>

## Ensuring data is loaded

In most cases, you'll have specified the depth of data you need in a `resolve` query when you first load or subscribe to a CoValue. However, sometimes you might have a CoValue instance which is not loaded deeply enough, or you're not sure how deeply loaded it is. In this case, you need to make sure data is loaded before proceeding with an operation. The `$jazz.ensureLoaded` method lets you guarantee that a CoValue and its referenced data are loaded to a specific depth (i.e. with nested references resolved):

<CodeGroup preferWrap>
```ts
async function completeAllTasks(projectId: string) {
  // Load the project
  const project = await Project.load(projectId, { resolve: true });
  if (!project.$isLoaded) return;

  // Ensure tasks are deeply loaded
  const loadedProject = await project.$jazz.ensureLoaded({
    resolve: {
      tasks: {
        $each: true,
      },
    },
  });

  // Now we can safely access and modify tasks
  loadedProject.tasks.forEach((task, i) => {
    task.$jazz.set("title", `Task ${i}`);
  });
}
```
</CodeGroup>

This can be useful if you have a shallowly loaded CoValue instance, and would like to load its references deeply.

## Best practices

- Load exactly what you need. Start shallow and add your nested references with care.
- Always check `$isLoaded` before accessing CoValue data. Use `$jazz.loadingState` for more detailed information.
- Use `$onError: 'catch'` at each level of your query that can fail to handle inaccessible data gracefully.
<ContentByFramework framework="react">
- Use selectors and an `equalityFn` to prevent unnecessary re-renders.
</ContentByFramework>
- Never rely on data being present unless it is requested in your `resolve` query.
