import { CodeGroup, ContentByFramework } from "@/components/forMdx";
import { Alert } from "@garden-co/design-system/src/components/atoms/Alert";

export const metadata = {
  description: "Learn how to use branching and merging in Jazz for collaborative editing with conflict resolution and private branches."
};

# Version Control

Jazz provides built-in version control through branching and merging, allowing multiple users to work on the same CoValue simultaneously without conflicts. This enables collaborative editing workflows where users can create private branches, make changes, and merge them back to the main version.

## Working with branches

### Creating Branches

To create a branch, use the `unstable_branch` option when loading a CoValue:

<CodeGroup>
```ts
const branch = await Project.load(projectId, {
  unstable_branch: { name: "feature-branch" }
});
```
</CodeGroup>

You can also create a branch via the `useCoState` hook:

<CodeGroup>
```ts
const branch = useCoState(Project, projectId, {
  unstable_branch: { name: "feature-branch" }
});
```
</CodeGroup>


### Making Changes

Once you have a branch, you can make changes using the same methods as the original CoValue:

<CodeGroup>
```tsx 
function EditProject({ projectId, currentBranchName }) {
  const project = useCoState(Project, projectId, {
    resolve: {
      tasks: { $each: true }
    },
    unstable_branch: {
      name: currentBranchName,
    },
  });

  const handleTitleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // Won't be visible on main until merged
    project.$jazz.set("title", e.target.value);
  };

  const handleTaskTitleChange = (index: number, e: React.ChangeEvent<HTMLInputElement>) => {
    const task = project.tasks[index];

    // The task is also part of the branch because we used the `resolve` option
    // with `tasks: { $each: true }`
    // so the changes won't be visible on main until merged
    task?.$jazz.set("title", e.target.value);
  };

  return (
    <form onSubmit={handleSave}>
      {/* Edit form fields */}
    </form>
  );
}
```
</CodeGroup>

### Merging

To merge a branch back to the main version, call `unstable_merge()`:

<CodeGroup>
```tsx 
function handleSave() {
  // Merge the branch changes back to main
  project.$jazz.unstable_merge();
  router.navigate("/");
}
```
</CodeGroup>

All the changes made to the branch will be merged into the main CoValue, preserving both author and timestamp.

Calling `unstable_merge()` will merge every change done in the project and the loaded tasks.

The merge is idempotent, so you can merge the same branch multiple times without changing the result.

The merge operation is scoped, so if you call `unstable_merge()` on a task, only the changes to the task will be merged

<CodeGroup>
```tsx 
function handleTaskSave(index: number) {
  const task = project.tasks[index];
  // Only the changes to the task will be merged
  task?.$jazz.unstable_merge();
}
```
</CodeGroup>


## Conflict Resolution

When conflicts occur (the same field is modified in both the branch and main), Jazz uses a "last writer wins" strategy:

<CodeGroup>
```tsx
// Branch modifies priority to "high"
branch.$jazz.applyDiff({ priority: "high" });

// Meanwhile, main modifies priority to "urgent"
originalProject.$jazz.applyDiff({ priority: "urgent" });

// Merge the branch
branch.$jazz.unstable_merge();

// Main's value wins ("urgent") because it was written later
console.log(originalProject.priority); // "urgent"
```
</CodeGroup>

## Private branches

When the owner is not specified, the branch has the same permissions as the main values.

You can also create a private branch by providing a group owner.

<CodeGroup>
```tsx 
// Create a private group for the branch
const privateGroup = Group.create();

const privateBranch = useCoState(Project, projectId, {
  unstable_branch: { 
    name: "private-edit", 
    owner: privateGroup 
  }
});

// Only members of privateGroup can see the branch content
// The sync server cannot read the branch content
```
</CodeGroup>

When a private branch is merged, the changes are merged into the main values, which keeps the privacy of the branch.

You can use private branches both to make the changes to the branches "private" until merged, or to give controlled write access to a group of users.

Only users with both write access to the main branch and read access to the private branch have the rights to merge the branch.

## Branch Identification

You can get the current branch information from the `$jazz` field.

<CodeGroup>
```ts 
const branch = await Project.load(projectId, {
  unstable_branch: { name: "feature-branch" }
});

// Branch ID is the same as source
console.log(branch.$jazz.branchName); // "feature-branch"
console.log(branch.$jazz.isBranch); // true
```
</CodeGroup>
