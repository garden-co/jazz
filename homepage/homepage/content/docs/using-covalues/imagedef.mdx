import { CodeGroup } from "@/components/forMdx";

export const metadata = {
  description: "ImageDefinition is a CoValue for storing images with built-in UX features."
};

# ImageDefinition

`ImageDefinition` is a specialized CoValue designed specifically for managing images in Jazz applications. It extends beyond basic file storage by supporting a blurry placeholder, built-in resizing, and progressive loading patterns.

Beyond ImageDefinition, Jazz offers higher-level functions and components that make it easier to use images:
- [`createImage()`](#creating-images) - function to create an `ImageDefinition` from a file
- [`loadImage`, `loadImageBySize`, `highestResAvailable`](#displaying-images) - functions to load and display images

The [Image Upload example](https://github.com/gardencmp/jazz/tree/main/examples/image-upload) demonstrates use of images in Jazz.

## Creating Images

The easiest way to create and use images in your Jazz application is with the `createImage()` function:

<CodeGroup>
```ts twoslash
import { Account, Group, ImageDefinition } from "jazz-tools";

declare const me: {
  $jazz: {
    owner: Account | Group;
  };
  profile: {
    image: ImageDefinition;
  };
};

// ---cut---
import { createImage } from "jazz-tools/media";

// Create an image from a file input
async function handleFileUpload(event: React.ChangeEvent<HTMLInputElement>) {
  const file = event.target.files?.[0];
  if (file) {
    // Creates ImageDefinition with a blurry placeholder, limited to 1024px on the longest side, and multiple resolutions automatically
    const image = await createImage(file, {
      owner: me.$jazz.owner,
      maxSize: 1024,
      placeholder: "blur",
      progressive: true,
      resolutions: {},
    });

    // Store the image in your application data
    me.profile.image = image;
  }
}
```
</CodeGroup>

**Note:** `createImage()` currently supports browser and react-native environments.

The `createImage()` function:
- Creates an `ImageDefinition` with the right properties
- Generates a small placeholder for immediate display
- Creates multiple resolution variants of your image
- Returns the created `ImageDefinition`

### Configuration Options

<CodeGroup>
```ts
import type { ImageDefinition, Group, Account } from "jazz-tools";
// ---cut---
declare function createImage(
  image: Blob | File | string,
  options: {
    owner?: Group | Account;
    placeholder?: "blur" | false;
    maxSize?: number;
    progressive?: boolean;
  }): Promise<ImageDefinition>
```
</CodeGroup>

#### `image`

The image to create an `ImageDefinition` from. On browser environments, this can be a `Blob` or a `File`. On React Native, this must be a `string` with the file path.

#### `owner`

The owner of the `ImageDefinition`. This is used to control access to the image. See [Groups as permission scopes](/docs/groups/intro) for more information on how to use groups to control access to images.

#### `placeholder`

Sometimes the wanted image is not loaded yet. The placeholder is a base64 encoded image that is displayed while the image is loading. Currently, only `"blur"` is a supported.

#### `maxSize`

The image generation process includes a maximum size setting that controls the longest side of the image. A built-in resizing feature is applied based on this setting.


#### `progressive`

The progressive loading pattern is a technique that allows images to load incrementally, starting with a small version and gradually replacing it with a larger version as it becomes available. This is useful for improving the user experience by showing a placeholder while the image is loading.

Passing `progressive: true` to `createImage()` will create internal smaller versions of the image for future uses.

### Create multiple resized copies

To create multiple resized copies of an original image for better layout control, you can utilize the `createImage` function multiple times with different parameters for each desired size. Hereâ€™s an example of how you might implement this:

<CodeGroup>
```ts twoslash
declare const myBlob: Blob;
// ---cut---
import { co } from "jazz-tools";
import { createImage } from "jazz-tools/media";

// Jazz Schema
const ProductImage = co.map({
  image: co.image(),
  thumbnail: co.image(),
});

const mainImage = await createImage(myBlob);
const thumbnail = await createImage(myBlob, {
  maxSize: 100,
});

// or, in case of migration, you can use the original stored image.
const newThumb = await createImage(mainImage!.original!.toBlob()!, {
  maxSize: 100,
});

const imageSet = ProductImage.create({
  image: mainImage,
  thumbnail,
});
```
</CodeGroup>

## Displaying Images

Like other CoValues, `ImageDefinition` can be used to load the object.

<CodeGroup>
```tsx twoslash
import { ImageDefinition } from "jazz-tools";

const image = await ImageDefinition.load("123", {
  resolve: {
    resolutions: true,
    original: true,
  },
});

if(image) {
  console.log({
    originalSize: image.originalSize,
    placeholderDataUrl: image.placeholderDataURL,
    original: image.original, // this FileStream may be not loaded yet
  });
}
```
</CodeGroup>

`image.original` is a `FileStream` and its content can be read as described in the [FileStream](/docs/vanilla/using-covalues/filestreams#reading-from-filestreams) documentation.

Since FileStream objects are also CoValues, they must be loaded before use. To simplify loading, if you want to load the binary data saved as Original, you can use the `loadImage` function.

<CodeGroup>
```ts twoslash
declare const imageDefinitionOrId: string;
// ---cut---
import { loadImage } from "jazz-tools/media";

const image = await loadImage(imageDefinitionOrId);
if(image === null) {
  throw new Error("Image not found");
}

const img = document.createElement("img");
img.width = image.width;
img.height = image.height;
img.src = URL.createObjectURL(image.image.toBlob()!);
img.onload = () => URL.revokeObjectURL(img.src);
```
</CodeGroup>

If the image was generated with progressive loading, and you want to access the best-fit resolution, use `loadImageBySize`. It will load the image of the best resolution that fits the wanted width and height.

<CodeGroup>
```ts twoslash
declare const imageDefinitionOrId: string;
// ---cut---
import { loadImageBySize } from "jazz-tools/media";

const image = await loadImageBySize(imageDefinitionOrId, 600, 600); // 600x600

if(image) {
  console.log({
    width: image.width,
    height: image.height,
    image: image.image,
  });
}
```
</CodeGroup>


If want to dynamically listen to the _loaded_ resolution that best fits the wanted width and height, you can use the `subscribe` and the `highestResAvailable` function.

<CodeGroup>
```ts
import { ImageDefinition } from "jazz-tools";
// function highestResAvailable(image: ImageDefinition, wantedWidth: number, wantedHeight: number): FileStream | null
import { highestResAvailable } from "jazz-tools/media";

const image = await ImageDefinition.load(imageId, {
  resolve: { resolutions: true },
});

if(image === null) {
  throw new Error("Image not found");
}

const img = document.createElement("img");
img.width = 600;
img.height = 600;

// start with the placeholder
if(image.placeholderDataURL) {
  img.src = image.placeholderDataURL;
}

// then listen to the image changes
image.$jazz.subscribe({}, (image) => {
  const bestImage = highestResAvailable(image, 600, 600);

  if(bestImage) {
    // bestImage is again a FileStream
    const blob = bestImage.image.toBlob();
    if(blob) {
      const url = URL.createObjectURL(blob);
      img.src = url;
      img.onload = () => URL.revokeObjectURL(url);
    }
  }
});
```
</CodeGroup>

### Best Practices

- **Set image sizes** when possible to avoid layout shifts
- **Use placeholders** (like LQIP - Low Quality Image Placeholders) for instant rendering
- **Prioritize loading** the resolution appropriate for the current viewport
- **Consider device pixel ratio** (window.devicePixelRatio) for high-DPI displays
- **Always call URL.revokeObjectURL** after the image loads to prevent memory leaks

## Image manipulation custom implementation

To manipulate the images (like placeholders, resizing, etc.), `createImage()` uses different implementations depending on the environment. Currently, the image manipulation is supported on browser and react-native environments.

On the browser, the image manipulation is done using the `canvas` API. If you want to use a custom implementation, you can use the `createImageFactory` function in order create your own `createImage` function and use your preferred image manipulation library.

<CodeGroup>
```ts
import { createImageFactory } from "jazz-tools/media";

const createImage = createImageFactory({
    createFileStreamFromSource: async (source, owner) => {
        // ...
    },
    getImageSize: async (image) => {
        // ...
    },
    getPlaceholderBase64: async (image) => {
        // ...
    },
    resize: async (image, width, height) => {
        // ...
    },
});
```
</CodeGroup>
