export const metadata = {
    description: "How to use JazzRPC to communicate with Server Workers using experimental_defineRequest."
};

import { Alert, CodeGroup } from "@/components/forMdx";

# JazzRPC

JazzRPC is the most straightforward and complete way to securely communicate with Server Workers. It works well with any framework or runtime that supports standard Request and Response objects, can be scaled horizontally, and puts clients and workers in direct communication.

## Setting up JazzRPC

### Defining request schemas

Use `experimental_defineRequest` to define your API schema:

<CodeGroup>
```ts bookEventTicket.ts#Basic
```
</CodeGroup>

### Setting up the Server Worker

We need to start a Server Worker instance that will be able to sync data with the sync server, and handle the requests.

<CodeGroup>
```ts jazzServer.ts#Basic
```
</CodeGroup>

## Handling JazzRPC requests on the server

### Creating API routes

Create API routes to handle the defined RPC requests. Here's an example using Next.js API routes:

<CodeGroup>
```ts server.ts#Basic
```
</CodeGroup>

## Making requests from the client

### Using the defined API

Make requests from the client using the defined API:

<CodeGroup>
```ts client.ts
```
</CodeGroup>

## Error handling

### Server-side error handling

Use `JazzRequestError` to return proper HTTP error responses:

<CodeGroup>
```ts server.ts#ErrorHandling
```
</CodeGroup>

<Alert variant="info" className="mt-4" title="Note">
  To ensure that the limit is correctly enforced, the handler should be deployed in a single worker instance (e.g. a single Cloudflare DurableObject).

  Details on how to deploy a single instance Worker are available in the [Deployment patterns](/docs/server-side/deployment#deployment-patterns) section.
</Alert>

### Client-side error handling

Handle errors on the client side:

<CodeGroup>
```ts client.ts#ErrorHandling
```
</CodeGroup>

<Alert variant="info" className="mt-4" title="Note">
  The `experimental_defineRequest` API is still experimental and may change in future versions. For production applications, consider the stability implications.
</Alert>

## Security safeguards provided by JazzRPC

JazzRPC includes several built-in security measures to protect against common attacks:

### Cryptographic Authentication
- **Digital Signatures**: Each RPC is cryptographically signed using the sender's private key
- **Signature Verification**: The server verifies the signature using the sender's public key to ensure message authenticity and to identify the sender account
- **Tamper Protection**: Any modification to the request payload will invalidate the signature

### Replay Attack Prevention
- **Unique Message IDs**: Each RPC has a unique identifier (`co_z${string}`)
- **Duplicate Detection**: incoming messages ids are tracked to prevent replay attacks
- **Message Expiration**: RPCs expire after 60 seconds to provide additional protection

These safeguards ensure that JazzRPC requests are secure, authenticated, and protected against common attack vectors while maintaining the simplicity of standard HTTP communication.

## See also

- [Deployment patterns](/docs/server-side/deployment#deployment-patterns) for guidance on single-instance vs. multi-region deployments.
