import { Alert, CodeGroup, ContentByFramework, FileName, ReactLogo, SvelteLogo, TabbedCodeGroup, TabbedCodeGroupItem } from "@/components/forMdx";
import RunDevServer from '@/components/docs/snippets/RunDevServer.mdx'
import StuckCTA from '@/components/docs/snippets/StuckCTA.mdx'

export const metadata = {
  description: "Add server-side rendering to your Jazz app."
};

# Add Server-Side Rendering to your App

This guide will take your simple client-side app to the next level by showing you how to create a server-rendered page to publish your data to the world.

<Alert variant="info" className="mt-4 flex gap-2 items-center">
  If you haven't gone through the [front-end Quickstart](/docs/quickstart), you might find this guide a bit confusing. If you're looking for a quick reference, you might find [this page](/docs/project-setup#ssr-integration) more helpful!
</Alert>

## Creating an agent
For Jazz to access data on the server, we need to create an SSR agent, which is effectively a read-only user which can access public data stored in Jazz.

We can create this user using the `createSSRJazzAgent` function. In this example, we'll create a new file and export the agent, which allows us to import and use the same agent in multiple pages.

<ContentByFramework framework="react">
<FileName>app/jazzSSR.ts</FileName>
</ContentByFramework>
<ContentByFramework framework="svelte">
<FileName>src/lib/jazzSSR.ts</FileName>
</ContentByFramework>
<CodeGroup className="mt-4 [&_span]:[tab-size:2]" preferWrap>
```tsx
import { createSSRJazzAgent } from "jazz-tools/ssr";

export const jazzSSR = createSSRJazzAgent({
  peer: "wss://cloud.jazz.tools/",
});
```
</CodeGroup>

## Telling Jazz to use the SSR agent

Normally, Jazz expects a logged in user (or an anonymous user) to be accessing data. We can use the `enableSSR` setting to tell Jazz that this may not be the case, and the data on the page may be being accessed by an agent.

<ContentByFramework framework="react">
<FileName>app/components/JazzWrapper.tsx</FileName>
</ContentByFramework>
<ContentByFramework framework="svelte">
<FileName>src/routes/+layout.svelte</FileName>
</ContentByFramework>

<TabbedCodeGroup savedPreferenceKey="framework" id="enable-ssr">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
"use client";
import { JazzReactProvider } from "jazz-tools/react";
import { JazzFestAccount } from "@/app/schema";

const apiKey = process.env.NEXT_PUBLIC_JAZZ_API_KEY;

export function JazzWrapper({ children }: { children: React.ReactNode }) {
  return (
    <JazzReactProvider
      sync={{ peer: `wss://cloud.jazz.tools/?key=${apiKey}` }}
      AccountSchema={JazzFestAccount}
      {/* [!code ++:1] */}
      enableSSR
    >
      {children}
    </JazzReactProvider>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { JazzSvelteProvider } from "jazz-tools/svelte";
  import { apiKey } from "$lib/apiKey";

  let { children } = $props();
  const sync = { peer: `wss://cloud.jazz.tools/?key=${apiKey}` };
</script>

<!--[!code --:1]-->
<JazzSvelteProvider {sync}>
<!--[!code ++:1]-->
<JazzSvelteProvider {sync} enableSSR>
  {@render children?.()}
</JazzSvelteProvider>
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

## Making your data public

By default, when you create data in Jazz, it's private and only accessible to the account that created it. 

However, the SSR agent is credential-less and unauthenticated, so it can only read data which has been made public. Although Jazz allows you to define [complex, role-based permissions](/docs/permissions-and-sharing/overview), here, we'll focus on making the CoValues public.

<FileName>app/schema.ts</FileName>
<CodeGroup preferWrap>
```ts
import { co, z } from "jazz-tools";

export const Band = co.map({
  name: z.string(), // Zod primitive type
})
// [!code ++:3]
  .withMigration(band => {
    band.$jazz.owner.makePublic()
  });

export const Festival = co.list(Band)
  .withMigration(festival => festival.$jazz.owner.makePublic());

export const JazzFestAccountRoot = co.map({
  myFestival: Festival,
});

export const JazzFestAccount = co
  .account({
    root: JazzFestAccountRoot,
    profile: co.profile(),
  })
  .withMigration((account) => {
    if (!account.$jazz.has('root')) {
      account.$jazz.set('root', {
        myFestival: [],
      });
      // [!code ++:1]
      account.root?.myFestival?.$jazz.owner.makePublic();
    }
  });
```
</CodeGroup>

## Creating a server-rendered page

Now let's set up a page which will be read by the agent we created earlier, and rendered fully on the server.

<ContentByFramework framework="react">
<FileName>app/festival/[festivalId]/page.tsx</FileName>
</ContentByFramework>
<ContentByFramework framework="svelte">
<FileName>src/routes/festival/[festivalId]/+page.svelte</FileName>
</ContentByFramework>

<TabbedCodeGroup savedPreferenceKey="framework" id="add-wrapper">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
import { jazzSSR } from "@/app/jazzSSR";
import { Festival } from "@/app/schema";

export default async function ServerSidePage(props: {
  params: { festivalId: string };
}) {
  const { festivalId } = await props.params;
  const festival = await Festival.load(festivalId, {
    loadAs: jazzSSR,
    resolve: {
      $each: {
        $onError: null,
      },
    },
  });
  
  return (
    <main>
      <h1>ðŸŽª Server-rendered Festival {festivalId}</h1>

      <ul>
        {festival?.filter(Boolean).map((band) => {
          if (!band) return null;
          return <li key={band.$jazz.id}>ðŸŽ¶ {band.name}</li>;
        })}
      </ul>
    </main>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { jazzSSR } from "$lib/jazzSSR";
  import { Festival } from "$lib/schema";
  import { page } from '$app/state';

	const festivalId = $derived(page.params.festivalId);

  const festival = $derived(Festival.load(festivalId, {
    loadAs: jazzSSR,
    resolve: {
      $each: {
        $onError: null,
      },
    },
  }));
</script>

<main>
  <h1>ðŸŽª Server-rendered Festival {festivalId}</h1>
  <ul>
    {#await festival then festival}
      {#each festival?.filter(Boolean) || [] as band (band.$jazz.id)} 
        <li>ðŸŽ¶ {band.name}</li>;
      {/each}
    {/await}
  </ul>
</main>
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

**Note**: `filter(Boolean)` allows us to remove any bands which have resolved to `null` during the loading process&hairsp;â€”&hairsp;this is often the case when the SSR agent tries to load a CoValue where the permissions are not set to public.

<ContentByFramework framework="react">
<Alert variant="info" className="mt-4">
  TypeScript might not recognise that `params` is a promise. This is a new feature in Next.js 15, which you can [read more about here](https://nextjs.org/docs/messages/sync-dynamic-apis).
</Alert>
</ContentByFramework>

## Linking to your server-rendered page

The last step is to link to your server-rendered page from your `Festival` component so that you can find it easily!

<ContentByFramework framework="react">
<FileName>app/components/Festival.tsx</FileName>
</ContentByFramework>
<ContentByFramework framework="svelte">
<FileName>lib/components/Festival.svelte</FileName>
</ContentByFramework>

<TabbedCodeGroup savedPreferenceKey="framework" id="link-to-page">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx
"use client";
import { useAccount } from "jazz-tools/react";
// [!code ++:1]
import Link from "next/link";
import { JazzFestAccount } from "@/app/schema";

export function Festival() {
  const { me } = useAccount(JazzFestAccount, {
    resolve: { root: { myFestival: true } },
  });
  if (!me) return null; // not loaded yet
  return (
    <>
      <ul>
        {me?.root.myFestival.map(
          (band) => band && <li key={band.$jazz.id}>{band.name}</li>,
        )}
      </ul>
      {/* [!code ++:3] */}
      <Link href={`/festival/${me.root.myFestival.$jazz.id}`}>
        Go to my Server-Rendered Festival Page!
      </Link>
    </>
  );
}
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte
<script lang="ts">
  import { AccountCoState } from "jazz-tools/svelte";
  import { JazzFestAccount } from "$lib/schema";
  const me = new AccountCoState(JazzFestAccount, { 
    resolve: { root: { myFestival: true } } 
  });
</script>

<ul>
  {#each me.current?.root.myFestival || [] as band}
    <li>{band?.name}</li>
  {/each}
</ul>
<!-- [!code ++:3] -->
<a href={`/festival/${me.root.myFestival.$jazz.id}`}>
  Go to my Server-Rendered Festival Page!
</a>
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

## Start your app
Let's fire up your app and see if it works!

<RunDevServer />

If everything's going according to plan, your app will load with the home page. You can click the link to your server-rendered page to see your data - fully rendered on the server!

**Congratulations! ðŸŽ‰** You've now set up server-side rendering in your React app. You can use this same pattern to render any page on the server. 

### Not working?
- Did you add `enableSSR` to the provider?
- Did you add `loadAs: jazzSSR` to `Festival.load`?
- Did you add the migrations to make the data public?

<StuckCTA />

## Next steps
- Learn more about how to [manage complex permissions](/docs/permissions-and-sharing/overview) using groups and roles
- Dive deeper into the collaborative data structures we call [CoValues](/docs/core-concepts/covalues/overview)
- Learn more about migrations in the [accounts and migrations docs](/docs/core-concepts/schemas/accounts-and-migrations)