import { Alert, CodeGroup, TabbedCodeGroup, ReactSnippet, SvelteSnippet, RNSnippet, ExpoSnippet, VanillaSnippet, TabbedCodeGroupItem, SvelteLogo, ReactLogo, RNLogo, ExpoLogo } from "@/components/forMdx";
export const metadata = { title: "Integrating with Existing Auth Methods", description: "Learn how to integrate Jazz with existing authentication methods." };

# Integrating with Existing Auth Methods

You can integrate Jazz with an existing auth method by giving each of your users a Jazz account which is linked to their existing user identity.

We will use a server worker to create Jazz accounts for your existing users, and persist the IDs and secrets for the Jazz users in your existing database.

Once this is done, you can retrieve and decrypt Jazz credentials when a user logs in, and then authenticate the client using the Jazz account ID and secret from the database.

## Creating Jazz Accounts

You should [set up a server worker](/docs/server-side/setup#generating-credentials), which will be responsible for creating Jazz accounts for your existing users. This worker:

1. Creates Jazz accounts
2. Extracts the ID and secret for the Jazz user
3. Encrypts the secret securely
4. Stores the ID and encrypted secret in your existing database

In production you should avoid creating accounts for users that already have them, and ensure that failures are handled gracefully.

It's also worth noting that you should check that your account schema is set up properly first, in order to ensure that the accounts get created correctly with the profile and root. If you wish to have centralised admin access to the user's root, you should add your server worker as an admin during the migration.

<FileName>schema.ts</FileName>
<CodeGroup>
```ts
import { co, z } from 'jazz-tools';
import { PUBLIC_JAZZ_WORKER_ACCOUNT } from "$env/static/public";

const MyAppAccountRoot = co.map({
  someMap: co.map({})
})
export const MyAppAccount = co.account({
  root: MyAppAccountRoot,
  profile: co.profile({})
}).withMigration((account, creationProps?: { name: string }) => {
  if (!account.$jazz.has("root")) {
    // Load the worker
    const worker = co.account().load(PUBLIC_JAZZ_WORKER_ACCOUNT);
    const group = Group.create();
    // Add it as a member of a group
    Group.addMember(worker, 'admin');
    // Create the root using the group to grant your server worker admin access on the user's account root.
    const myRoot = MyAppAccountRoot.create({
      someMap: {}
    }, group);

    account.$jazz.set("root", myRoot);
  }
});
```
</CodeGroup>


<Alert variant="info" tip="Security Note" className="mt-4">
  Account secrets and IDs are immutable, and are the only credentials needed to access a Jazz user's data. Don't store the secret in plaintext. If a Jazz secret is lost, the account cannot be recovered. You will need to issue a new Jazz account.
</Alert>

{/* TODO: Make this framework friendly */}
<CodeGroup preferWrap className="mt-4">
```ts
import { MyAppAccount } from "./schema";
import { startWorker } from "jazz-tools/worker";
import { PUBLIC_JAZZ_WORKER_ACCOUNT } from "$env/static/public";
import { JAZZ_WORKER_SECRET } from "$env/static/private";

const { worker } = await startWorker({
  accountID: PUBLIC_JAZZ_WORKER_ACCOUNT,
  accountSecret: JAZZ_WORKER_SECRET,
});

// Get all users from your existing database
const allUsers = await db.query.users.findMany();

for (const user of allUsers) {
  const account = await MyAppAccount.createAs(worker, { creationProps: { name: user.name } });
  const accountID = account.$jazz.id;
  const accountSecret = account.$jazz.localNode.getCurrentAgent().agentSecret;
  const encryptedSecret = await encrypt(accountSecret); // use your implementation here
  // Persist the Jazz account ID and secret in your existing database
  await db.query.users.update({
    where: { id: user.id },
    data: {
      jazzAccountID: accountID,
      jazzAccountSecret: encryptedSecret
    }
  });
}
```
</CodeGroup>

## Using your existing authentication system

Now that your users all have Jazz accounts, you can authenticate them using your original authentication system, and have them fetch their Jazz account ID and secret from your database.

<TabbedCodeGroup default="react" savedPreferenceKey="framework" id="auth-using-context">
<ReactSnippet preferWrap>
```tsx
import { useJazzContext } from "jazz-tools/react";

export function Auth() {
  const context = useJazzContext();

  async function handleSubmit(e) {
    e.preventDefault();

    const formData = new FormData(e.target);
    const username = formData.get("username");
    const password = formData.get("password");

    // Whatever your existing auth system is
    const myOldAppUser = await myApp.logIn(username, password);
    const accountID = myOldAppUser.jazzAccountID;
    // If you've stored this in an encrypted form, make sure to decrypt it first
    const accountSecret = myOldAppUser.jazzAccountSecret;

    await context.authenticate({
      accountID,
      accountSecret,
      provider: "my-old-app-auth", // Use any string here to identify your authentication provider. This avoids Jazz considering your users unauthenticated.
    });

    // The Jazz session is now authenticated!
 }

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" type="text" placeholder="Username" required />
      <input name="password" type="password" placeholder="Password" required />
      <button type="submit">Log In</button>
    </form>
  );
}
```
</ReactSnippet>
<SvelteSnippet preferWrap>
```svelte
<script lang="ts">
  import { getJazzContext } from 'jazz-tools/svelte';
  const context = getJazzContext();

  function logIn(username: string, password: string) {
    // Whatever your existing auth system is
    const myOldAppUser = myApp.logIn(username, password);
    const accountID = myOldAppUser.jazzAccountID;
    // If you've stored this in an encrypted form, make sure to decrypt it first
    const accountSecret = myOldAppUser.jazzAccountSecret;
    context.current.authenticate({ accountID, accountSecret });
    // The Jazz session is now authenticated!
  }
</script>
```
</SvelteSnippet>
<RNSnippet preferWrap>
```tsx
import { useJazzContext } from "jazz-tools/react-native";

export function Auth() {
  const context = useJazzContext();

  async function handleSubmit(e) {
    e.preventDefault();

    const formData = new FormData(e.target);
    const username = formData.get("username");
    const password = formData.get("password");

    // Whatever your existing auth system is
    const myOldAppUser = await myApp.logIn(username, password);
    const accountID = myOldAppUser.jazzAccountID;
    // If you've stored this in an encrypted form, make sure to decrypt it first
    const accountSecret = myOldAppUser.jazzAccountSecret;

    await context.authenticate({
      accountID,
      accountSecret,
      provider: "my-old-app-auth", // Use any string here to identify your authentication provider. This avoids Jazz considering your users unauthenticated.
    });

    // The Jazz session is now authenticated!
 }

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" type="text" placeholder="Username" required />
      <input name="password" type="password" placeholder="Password" required />
      <button type="submit">Log In</button>
    </form>
  );
}
```
</RNSnippet>
<ExpoSnippet preferWrap>
```tsx
import { useJazzContext } from "jazz-tools/expo";

export function Auth() {
  const context = useJazzContext();

  async function handleSubmit(e) {
    e.preventDefault();

    const formData = new FormData(e.target);
    const username = formData.get("username");
    const password = formData.get("password");

    // Whatever your existing auth system is
    const myOldAppUser = await myApp.logIn(username, password);
    const accountID = myOldAppUser.jazzAccountID;
    // If you've stored this in an encrypted form, make sure to decrypt it first
    const accountSecret = myOldAppUser.jazzAccountSecret;

    await context.authenticate({
      accountID,
      accountSecret,
      provider: "my-old-app-auth", // Use any string here to identify your authentication provider. This avoids Jazz considering your users unauthenticated.
    });

    // The Jazz session is now authenticated!
 }

  return (
    <form onSubmit={handleSubmit}>
      <input name="username" type="text" placeholder="Username" required />
      <input name="password" type="password" placeholder="Password" required />
      <button type="submit">Log In</button>
    </form>
  );
}
```
</ExpoSnippet>
</TabbedCodeGroup>

Check the [accounts and migrations](/docs/core-concepts/schemas/accounts-and-migrations) documentation to learn more about how you can make sure that the Jazz accounts contain all the fields you need.
