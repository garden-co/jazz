import { Alert, CodeGroup, ContentByFramework, FileName, ReactLogo, SvelteLogo, TabbedCodeGroup, TabbedCodeGroupItem, VanillaLogo } from "@/components/forMdx";

export const metadata = {
  description: "Learn how to subscribe to CoValues, specify loading depths, and handle loading states and inaccessible data."
};

# Subscriptions & Deep Loading

Jazz's Collaborative Values (such as [CoMaps](/docs/core-concepts/covalues/comaps) or [CoLists](/docs/core-concepts/covalues/colists)) are reactive. You can subscribe to them to automatically receive updates whenever they change, either locally or remotely.

You can also use subscriptions to load CoValues *deeply* by resolving nested values. You can specify exactly how much data you want to resolve and handle loading states and errors.

You can load and subscribe to CoValues in one of two ways:

- **shallowly**&hairsp;—&hairsp;all of the primitive fields are available (such as strings, numbers, dates), but the references to other CoValues are not loaded
- **deeply**&hairsp;—&hairsp;some or all of the referenced CoValues have been loaded

<Alert variant="info" title="Tip">
  Jazz automatically deduplicates loading. If you subscribe to the same CoValue multiple times in your app, Jazz will only fetch it once. That means you don’t need to deeply load a CoValue *just in case* a child component might need its data, and you don’t have to worry about tracking every possible field your app needs in a top-level query. Instead, pass the CoValue ID to the child component and subscribe there&hairsp;—&hairsp;Jazz will only load what that component actually needs.
</Alert>

## Subscription Hooks

On your front-end, using a subscription hook is the easiest way to manage your subscriptions. The subscription and related clean-up is handled automatically, and you can use your data like any other piece of state in your app.

### Subscribe to CoValues
<ContentByFramework framework={["react", "react-native", "react-native-expo"]}>
The `useCoState` hook allows you to reactively subscribe to CoValues in your React components. It will subscribe to updates when the component mounts and unsubscribe when it unmounts, ensuring your UI stays in sync and avoiding memory leaks.
</ContentByFramework>
<ContentByFramework framework="svelte">
The `CoState` class allows you to reactively subscribe to CoValues in your Svelte components. It will subscribe to updates when the component mounts and unsubscribe when it unmounts, ensuring your UI stays in sync and avoiding memory leaks.
</ContentByFramework>

<TabbedCodeGroup id="usecostate" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx ProjectView.tsx#Basic
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte ProjectView.svelte
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>
**Note:** If you don't need to load a CoValue's references, you can choose to load it *shallowly* by omitting the resolve query.

### Subscribe to the current user's account

<ContentByFramework framework="react">
`useAccount` is similar to `useCoState`, but it returns the current user's account. You can use this at the top level of your app to subscribe to the current user's [account profile and root](/docs/core-concepts/schemas/accounts-and-migrations#covalues-as-a-graph-of-data-rooted-in-accounts).
</ContentByFramework>
<ContentByFramework framework="svelte">
`AccountCoState` is similar to `CoState`, but it returns the current user's account. You can use this at the top level of your app to subscribe to the current user's [account profile and root](/docs/core-concepts/schemas/accounts-and-migrations#covalues-as-a-graph-of-data-rooted-in-accounts).
</ContentByFramework>

<TabbedCodeGroup id="useaccount" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx ProjectList.tsx
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte ProjectList.svelte
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

### Loading States

When you load or subscribe to a CoValue through a hook (or directly), it can be either:

- **Loaded** → The CoValue has been successfully loaded and all its data is available
- **Not Loaded** → The CoValue is not yet available

You can use the `$isLoaded` field to check whether a CoValue is loaded. For more detailed information about why a CoValue is not loaded, you can check `$jazz.loadingState`:

- `"loading"` → The CoValue is still being fetched
- `"unauthorized"` → The current user doesn't have permission to access this CoValue
- `"unavailable"` → The CoValue couldn't be found or an error (e.g. a network timeout) occurred while loading

See the examples above for practical demonstrations of how to handle these three states in your application.

<ContentByFramework framework={["react", "react-native", "react-native-expo"]}>
### Suspense Hooks [!framework=react,react-native,react-native-expo]

`useSuspenseCoState` and `useSuspenseAccount` are the suspense-enabled counterparts for `useCoState` and `useAccount`. They integrate with React's Suspense API by suspending component rendering while the requested value loads. 

Once the component renders successfully, all of the data requested is guaranteed to be loaded and accessible. In case the requested data **can't** be loaded, the hook will throw an error during rendering.

To handle the various loading states, instead of checking `$isLoaded` or `$jazz.loadingState`, these hooks should be combined with `<Suspense>` and error boundaries.

<CodeGroup preferWrap>
```tsx ProjectView.tsx#Suspense 
```
</CodeGroup>

#### Use Suspense with Error Boundaries [!framework=react,react-native,react-native-expo]

 An error boundary serves as a fallback for unrecoverable errors you cannot handle gracefully during rendering. If errors [can be handled locally](#loading-errors) in the component&hairsp;—&hairsp;for example, with `$onError: 'catch'` in a resolve query&hairsp;—&hairsp;it's generally better to do so. 
 
 As a rule of thumb, it’s best to wrap only your routes or major components in error boundaries.
 
When using an error boundary, you can handle errors thrown by the hooks by displaying a custom error message or UI. Jazz provides you with a `getJazzErrorType` helper which you can use in `getDerivedStateFromError` to allow you to determine what caused the error (for example, the CoValue may be unavailable, or the user may not have the appropriate permissions to access it).

[Check out an example error boundary here](https://github.com/garden-co/jazz/blob/main/examples/music-player/src/components/ErrorBoundary.tsx), or read more about them in the [React documentation](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary).
</ContentByFramework>

## Deep Loading

When you're working with related CoValues (like tasks in a project), you often need to load nested references as well as the top-level CoValue.

This is particularly the case when working with [CoMaps](/docs/core-concepts/covalues/comaps) that refer to other CoValues or [CoLists](/docs/core-concepts/covalues/colists) of CoValues. You can use `resolve` queries to tell Jazz what data you need to use.

### Using Resolve Queries

A `resolve` query tells Jazz how deeply to load data for your app to use. We can use `true` to tell Jazz to shallowly load the tasks list here. Note that this does *not* cause the tasks themselves to load, just the CoList that holds the tasks.

<CodeGroup>
```ts ResolveQueries.ts#Basic
```
</CodeGroup>

We can use an `$each` expression to tell Jazz to load the items in a list.

<CodeGroup>
```ts ResolveQueries.ts#Each
```
</CodeGroup>
We can also build a query that *deeply resolves* to multiple levels:

<CodeGroup>
```ts ResolveQueries.ts#Deep
```
</CodeGroup>

<Alert title="Always load data explicitly" variant="warning" className="my-4">
If you access a reference that wasn't included in your `resolve` query, you may find that it is already loaded, potentially because some other part of your app has already loaded it. **You should not rely on this**.

Expecting data to be there which is not explicitly included in your `resolve` query can lead to subtle, hard-to-diagnose bugs. Always include every nested CoValue you need to access in your `resolve` query.
</Alert>

### Where To Use Resolve Queries

The syntax for resolve queries is shared throughout Jazz. As well as using them in `load` and `subscribe` method calls, you can pass a resolve query to a front-end hook.

<TabbedCodeGroup id="resolve" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx ProjectView.tsx#ShallowLoad

```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte ShallowLoad.svelte
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

You can also specify resolve queries at the schema level, using the `.resolved()` method. These queries will be used when loading CoValues from that schema (if no resolve query is provided by the user) and in types defined with [co.loaded](/docs/core-concepts/subscription-and-loading#type-safety-with-coloaded).

<CodeGroup preferWrap>
```ts index.ts#ResolvedHelper
```
</CodeGroup>

It is possible that in more complex cases, TypeScript cannot accurately infer types with circular references. For example, below, attempting to resolve `Project` on `Task` will in turn force `Project` to resolve `tasks`, which refers back to `Task`. This will result in an error.

<CodeGroup preferWrap>
```ts broken-schema.ts#BrokenSchema
```
</CodeGroup>

In cases where you come across this, you can create a shallowly-loaded version of the schema which avoids loading the circular references.

<CodeGroup preferWrap>
```ts fixed-schema.ts#FixedSchema
```
</CodeGroup>


## Loading Errors

A load operation will be successful **only** if all references requested (both optional and required) could be successfully loaded. If any reference cannot be loaded, the entire load operation will return a not-loaded CoValue to avoid potential inconsistencies.

<CodeGroup preferWrap>
```ts ResolveQueries.ts#Unauthorized
```
</CodeGroup>

This is also true if **any** element of a list is inaccessible, even if all the others can be loaded.

<CodeGroup preferWrap>
```ts ResolveQueries.ts#NoCatch
```
</CodeGroup>

Loading will be successful if all requested references are loaded. Non-requested references may or may not be available.

<CodeGroup preferWrap>
```ts ResolveQueries.ts#ShallowNoCatch
```
</CodeGroup>

### Catching loading errors

We can use `$onError` to handle cases where some data you have requested is inaccessible, similar to a `try...catch` block in your query.

For example, in case of a `project` (which the user can access) with three `task` items:

<table>
  <thead>
    <tr>
      <th>Task</th>
      <th>User can access <code>task</code>?</th>
      <th>User can access <code>task.description</code>?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>✅</td>
      <td>✅</td>
    </tr>
    <tr>
      <td>1</td>
      <td>✅</td>
      <td>❌</td>
    </tr>
    <tr>
      <td>2</td>
      <td>❌</td>
      <td>❌</td>
    </tr>
  </tbody>
</table>

#### Scenario 1: Skip Inaccessible List Items

If some of your list items may not be accessible, you can skip loading them by specifying `$onError: 'catch'`. Inaccessible items will be not-loaded CoValues, while accessible items load properly.
<CodeGroup preferWrap>
```ts ResolveQueries.ts#SkipInaccessible
```
</CodeGroup>
#### Scenario 2: Handling Inaccessible Nested References

An `$onError` applies only in the block where it's defined. If you need to handle multiple potential levels of error, you can nest `$onError` handlers.

This load will fail, because the `$onError` is defined only for the `task.description`, not for failures in loading the `task` itself.

<CodeGroup preferWrap>
```ts ResolveQueries.ts#NestedInaccessible
```
</CodeGroup>
We can fix this by adding handlers at both levels

<CodeGroup preferWrap>
```ts ResolveQueries.ts#MultipleCatch
```
</CodeGroup>

## Type safety with co.loaded

You can tell your application how deeply your data is loaded by using the `co.loaded` type.

The `co.loaded` type is especially useful when passing data between components, because it allows TypeScript to check at compile time whether data your application depends is properly loaded. The second argument lets you pass a `resolve` query to specify how deeply your data is loaded.

<TabbedCodeGroup id="coloaded" default="react" savedPreferenceKey="framework">
<TabbedCodeGroupItem label="Vanilla" value="vanilla" icon={<VanillaLogo />} preferWrap>
```ts core-concepts/subscription-and-loading/vanilla.ts
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="React" value="react" icon={<ReactLogo />} preferWrap>
```tsx TaskList.tsx
```
</TabbedCodeGroupItem>
<TabbedCodeGroupItem label="Svelte" value="svelte" icon={<SvelteLogo />} preferWrap>
```svelte TaskList.svelte
```
</TabbedCodeGroupItem>
</TabbedCodeGroup>

You can pass a `resolve` query of any complexity to `co.loaded`.

## Manual subscriptions

If you have a CoValue's ID, you can subscribe to it anywhere in your code using `CoValue.subscribe()`.

**Note:** Manual subscriptions are best suited for vanilla JavaScript&hairsp;—&hairsp;for example in server-side code or tests. Inside front-end components, we recommend using a subscription hook.

<CodeGroup preferWrap>
```ts index.ts#ManualSubscription
```
</CodeGroup>

You can also subscribe to an existing CoValue instance using the `$jazz.subscribe` method.

<CodeGroup preferWrap>
```ts index.ts#SubscriptionInstanceMethod
```
</CodeGroup>

### Error handling for manual subscriptions
You can pass an `onError` handler as an option to your subscription. This handler will run reactively whenever the CoValue you're subscribing to is inaccessible&hairsp;—&hairsp;for example, when the CoValue is unavailable (not found or network timeout) or when you do not have the appropriate permissions to read it. You can check `$jazz.loadingState` to determine the specific reason.

<CodeGroup preferWrap>
```ts error-handling-in-manual.ts#ErrorHandling
```
</CodeGroup>

<ContentByFramework framework={["react", "react-native", "react-native-expo"]}>

## Selectors [!framework=react,react-native,react-native-expo]
Sometimes, you only need to react to changes in specific parts of a CoValue. In those cases, you can provide a `select` function to specify what data you are interested in,
and an optional `equalityFn` option to control re-renders.

- `select`: extract the fields you care about
- `equalityFn`: (optional) control when data should be considered equal

<CodeGroup>
```tsx ProjectView.tsx#Selector
```
</CodeGroup>

By default, the return values of the select function will be compared using `Object.is`, but you can use the `equalityFn` to add your own logic.

You can also use `useAccount` in the same way, to subscribe to only the changes in a user's account you are interested in.

<CodeGroup>
```tsx ProjectView.tsx#UseAccountWithSelector
```
</CodeGroup>
</ContentByFramework>

### Avoiding Expensive Selectors

Selector functions optimise re-renders by only updating React state if the underlying CoValue has changed in a way that you care about. 
  
However, the selector function itself still runs on every CoValue update, even if your `equalityFn` returns `true` and your component does not re-render. Because of this, you should **avoid doing expensive computation inside a selector**.

For expensive operations, use a lightweight selector which only tracks the minimum necessary to identify when the dependencies change, and run the expensive operations separately, wrapped in a `useMemo` hook. 

This way, React can [batch state updates efficiently](https://react.dev/learn/queueing-a-series-of-state-updates) and only recompute the expensive memoised operation if the dependencies have changed.

<CodeGroup>
```tsx ProjectView.tsx#ExpensiveSelector
```
</CodeGroup>

## Ensuring data is loaded

In most cases, you'll have specified the depth of data you need in a `resolve` query when you first load or subscribe to a CoValue. However, sometimes you might have a CoValue instance which is not loaded deeply enough, or you're not sure how deeply loaded it is. In this case, you need to make sure data is loaded before proceeding with an operation. The `$jazz.ensureLoaded` method lets you guarantee that a CoValue and its referenced data are loaded to a specific depth (i.e. with nested references resolved):

<CodeGroup preferWrap>
```ts index.ts#EnsureLoaded
```
</CodeGroup>

This can be useful if you have a shallowly loaded CoValue instance, and would like to load its references deeply.

<ContentByFramework framework={["react", "react-native", "react-native-expo"]}>

## Loading multiple CoValues at the same time [!framework=react,react-native,react-native-expo]

When you need to load multiple CoValues dynamically (for example, when implementing pagination or loading a variable number of CoValues), React's Rules of Hooks can be challenging.
Since hooks can't be called conditionally or inside loops, you're forced to create a separate component for each CoValue you want to load.

The `useCoStates` and `useSuspenseCoStates` hooks solve this by accepting an array of CoValue IDs and returning the corresponding CoValues.
This allows you to load multiple CoValues in a single component.

- **`useCoStates`** — Returns `MaybeLoaded` CoValues, similar to `useCoState`. You should check `$isLoaded` before accessing the data.
- **`useSuspenseCoStates`** — Returns `Loaded` CoValues, similar to `useSuspenseCoState`. Use this with React Suspense boundaries.

Both hooks support the same options as their single-value counterparts, including `resolve` queries, `select` functions, and `equalityFn`.

<CodeGroup>
```tsx ProjectView.tsx#ProjectViewWithPagination
```
</CodeGroup>
</ContentByFramework>

## Best practices

- Load exactly what you need. Start shallow and add your nested references with care.
- Always check `$isLoaded` before accessing CoValue data. Use `$jazz.loadingState` for more detailed information.
- Use `$onError: 'catch'` at each level of your query that can fail to handle inaccessible data gracefully.
<ContentByFramework framework="react">
- Use selectors and an `equalityFn` to prevent unnecessary re-renders.
</ContentByFramework>
- Never rely on data being present unless it is requested in your `resolve` query.
