import { CodeGroup } from '@/components/forMdx'

export const metadata = { title: "Jazz 0.12.0 - Deeply resolved data" };

# Jazz 0.12.0 - Deeply resolved data

Jazz 0.12.0 makes it easier and safer to load nested data. You can now specify exactly which nested data you want to load, and Jazz will check permissions and handle missing data gracefully. This helps catch errors earlier during development and makes your code more reliable.

## What's new?

- New resolve API for a more type-safe deep loading
- A single, consistent load option for all loading methods
- Improved permission checks on deep loading
- Easier type safety with the `Resolved` type helper

## Breaking changes

### New Resolve API

We're introducing a new resolve API for deep loading, more friendly to TypeScript, IDE autocompletion and LLMs.

**Major changes:**

1. Functions and hooks for loading now take the resolve query as an explicit nested `resolve` prop
2. Shallowly loading a collection is now done with `true` instead of `[]` or `{}`

<CodeGroup>
```tsx
// Before
const { me } = useAccount({ root: { friends: [] } }); // [!code --]

// After
const { me } = useAccount({ // [!code ++]
  resolve: { root: { friends: true } } // [!code ++]
}); // [!code ++]
```
</CodeGroup>

3. For collections, resolving items deeply is now done with a special `$each` key.

For a `CoList`:

<CodeGroup>
```tsx
class ListOfTasks extends CoList.Of(co.ref(Task)) {}

// Before
const tasks = useCoState(ListOfTasks, id, [{}]); // [!code --]

// After
const tasks = useCoState(ListOfTasks, id, { resolve: { $each: true } }); // [!code ++]
```
</CodeGroup>

For a `CoMap.Record`:

<CodeGroup>
```tsx
class UsersByUsername extends CoMap.Record(co.ref(MyAppAccount)) {}

// Before
const usersByUsername = useCoState(UsersByUsername, id, [{}]); // [!code --]

// After
const usersByUsername = useCoState(UsersByUsername, id, { // [!code ++]
  resolve: { $each: true } // [!code ++]
}); // [!code ++]
```
</CodeGroup>

Nested loading &mdash; note how it's now less terse, but more readable and auto-complete friendly:

<CodeGroup>
```tsx
// Before
const tasksWithAssigneesAndTheirOrgs = useCoState(ListOfTasks, id, [{ // [!code --]
  assignees: [{ org: {}}]} // [!code --]
]); // [!code --]

// After
const tasksWithAssigneesAndTheirOrgs = useCoState(ListOfTasks, id, { // [!code ++]
  resolve: { // [!code ++]
    $each: { // [!code ++]
      assignees: { // [!code ++]
        $each: { org: true } // [!code ++]
      } // [!code ++]
    } // [!code ++]
  } // [!code ++]
}); // [!code ++]
```
</CodeGroup>

### A single, consistent load option

The new API works across all loading methods, and separating out the resolve query means
other options with default values are easier to manage, for example: loading a value as a specific account instead of using the implicit current account:

<CodeGroup>
```ts
// Before
Playlist.load(id, otherAccount, { // [!code --]
  tracks: [], // [!code --]
}); // [!code --]

// After
Playlist.load(id, { // [!code ++]
  loadAs: otherAccount, // [!code ++]
  resolve: { tracks: true } // [!code ++]
}); // [!code ++]
```
</CodeGroup>

### Improved permission checks on deep loading

Now `useCoState` will return `null` when the current user lacks permissions to load requested data.

Previously, `useCoState` would return `undefined` if the current user lacked permissions, making it hard to tell if the value is loading or if it's missing.

Now `undefined` means that the value is definitely loading, and `null` means that the value is temporarily missing.

We also have implemented a more granular permission checking, where if an *optional* CoValue cannot be accessed, `useCoState` will return the data stripped of that CoValue.

**Note:** The state handling around loading and error states will become more detailed and easy-to-handle in future releases, so this is just a small step towards consistency.

<CodeGroup>
{/* prettier-ignore */}
```tsx
class ListOfTracks extends CoList.Of(co.optional.ref(Track)) {}
// Before (ambiguous states)
const value = useCoState(ListOfTracks, id, [{}]); // [!code --]
if (value === undefined) return <div>Loading or access denied</div>; // [!code --]
if (value === null) return <div>Not found</div>; // [!code --]

// After
const value = useCoState(ListOfTracks, id, { resolve: { $each: true } }); // [!code ++]
if (value === undefined) return <div>Loading...</div>; // [!code ++]
if (value === null) return <div>Not found or access denied</div>; // [!code ++]

// This will only show tracks that we have access to and that are loaded.
return tracks.map(track => track && <MusicTrack track={track} />);
```
</CodeGroup>

## New Features

### The `Resolved` type helper

The new `Resolved` type can be used to define what kind of deeply loaded data you expect in your parameters, using the same resolve query syntax as the new loading APIs:

<CodeGroup>
```ts
type PlaylistResolved = Resolved<Playlist, {
  tracks: { $each: true }
}>;

function TrackListComponent({ playlist }: { playlist: PlaylistResolved }) {
  // Safe access to resolved tracks
  return playlist.tracks.map(track => /* ... */);
}
```
</CodeGroup>
