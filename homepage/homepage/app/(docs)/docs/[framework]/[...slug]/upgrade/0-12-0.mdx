import { CodeGroup } from '@/components/forMdx'

export const metadata = { title: "Jazz 0.12.0 - Deeply resolved data" };

# Jazz 0.12.0 - Deeply resolved data

<h2 className="not-prose text-sm text-stone-600 dark:text-stone-400 mb-5 pb-2 border-b">
  20 March 2025
</h2>

<div>
  Jazz 0.12.0 makes it easier and safer to load nested data. You can now specify exactly which nested data you want to load, and Jazz will check permissions and handle missing data gracefully. This helps catch errors earlier during development and makes your code more reliable.

  <h3>What's new?</h3>
  - New resolve API for a more type-safe deep loading
  - A single, consistent load option for all loading methods
  - Improved permission checks on deep loading
  - Easier type safety with the `Resolved` type helper
</div>

<h3>New Resolve API</h3>
<div>
  We're introducing a new resolve API for deep loading, more friendly to TypeScript, IDE autocompletion and LLMs.

  **Major changes:**

  1. Functions and hooks for loading now take the resolve query as an explicit nested `resolve` prop
  2. Shallowly loading a container-like value is now done with `true` instead of `[]` or `{}`

      <CodeGroup>
      ```tsx
      // Before
      const { me } = useAccount({ root: { friends: [] } }); // *bin*

      // After
      const { me } = useAccount({ // *add*
        resolve: { root: { friends: true } } // *add*
      }); // *add*
      ```
      </CodeGroup>

  3. For container-like values, resolving items deeply is now done with a special `$each` key.

      For a `CoList`:

      <CodeGroup>
      ```tsx
      class ListOfTasks extends CoList.Of(co.ref(Task)) {}

      // Before
      const tasks = useCoState(ListOfTasks, id, [{}]); // *bin*

      // After
      const tasks = useCoState(ListOfTasks, id, { resolve: { $each: true } }); // *add*
      ```
      </CodeGroup>

      For a `CoMap.Record`:

      <CodeGroup>
      ```tsx
      class UsersByUsername extends CoMap.Record(co.ref(MyAppAccount)) {}

      // Before
      const usersByUsername = useCoState(UsersByUsername, id, [{}]); // *bin*

      // After
      const usersByUsername = useCoState(UsersByUsername, id, { // *add*
        resolve: { $each: true } // *add*
      }); // *add*
      ```
      </CodeGroup>

      Nested loading &mdash; note how it's now less terse, but more readable and auto-complete friendly:

      <CodeGroup>
      ```tsx
      // Before
      const tasksWithAssigneesAndTheirOrgs = useCoState(ListOfTasks, id, [{ // *bin*
        assignees: [{ org: {}}]} // *bin*
      ]); // *bin*

      // After
      const tasksWithAssigneesAndTheirOrgs = useCoState(ListOfTasks, id, { // *add*
        resolve: { // *add*
          $each: {
            assignees: { // *add*
              $each: { org: true } // *add*
            } // *add*
          } // *add*
        } // *add*
      }); // *add*
      ```
      </CodeGroup>

<h3>A single, consistent load option</h3>

The new API works across all loading methods, and separating out the resolve query means
other options with default values are easier to manage, for example loading a value as a specific account instead of using the implicit current account:

<CodeGroup>
```ts
// Before
Playlist.load(id, otherAccount, { // *bin*
  tracks: [], // *bin*
}); // *bin*

// After
Playlist.load(id, { // *add*
  loadAs: otherAccount, // *add*
  resolve: { tracks: true } // *add*
}); // *add*
```
</CodeGroup>
</div>

<h3>Improved permission checks on deep loading</h3>
<div>
  Now `useCoState` will return `null` when the current user lacks permissions to load requested data.

  Previously, `useCoState` would return `undefined` if the current user lacked permissions, making it hard to tell if the value is loading or if it's missing.

  Now `undefined` means that the value is definitely loading, and `null` means that the value is temporarily missing.

  We also have implemented a more granular permission checking, where if an *optional* CoValue cannot be accessed, `useCoState` will return the data stripped of that CoValue.

  **Note:** The state handling around loading and error states will become more detailed and easy-to-handle in future releases, so this is just a small step towards consistency.
<CodeGroup>
{/* prettier-ignore */}
```tsx
class ListOfTracks extends CoList.Of(co.optional.ref(Track)) {}
// Before (ambiguous states)
const value = useCoState(ListOfTracks, id, [{}]); // *bin*
if (value === undefined) return <div>Loading or access denied</div>; // *bin*
if (value === null) return <div>Not found</div>; // *bin*

// After
const value = useCoState(ListOfTracks, id, { resolve: { $each: true } }); // *add*
if (value === undefined) return <div>Loading...</div>; // *add*
if (value === null) return <div>Not found or access denied</div>; // *add*

// This will only show tracks that we have access to and that are loaded.
return tracks.map(track => track && <MusicTrack track={track} />);
```
</CodeGroup>
</div>

<h3>The `Resolved` type helper</h3>
<div>
  The new `Resolved` type can be used to define what kind of deeply loaded data you expect in your parameters,
  using the same resolve query syntax as the new loading APIs:

  <CodeGroup>
{/* prettier-ignore */}
```ts
type PlaylistResolved = Resolved<Playlist, {
  tracks: { $each: true }
}>;

function TrackListComponent({ playlist }: { playlist: PlaylistResolved }) {
  // Safe access to resolved tracks
  return playlist.tracks.map(track => /* ... */);
}
```
</CodeGroup>
</div>
