import { CodeGroup } from "@/components/forMdx";

export const metadata = { title: "Metadata & time-travel" };

# Metadata & time-travel

CoValues have a lot of useful metadata attached to them, much of which is helpful for debugging and understanding the history of a CoValue.

`CoValue._raw` gives you access to the internal state of a CoValue, from which a lot of useful information can be derived.

`CoValue._edits` gives you access to the edit history of a CoValue.

## Working with Edit History Metadata

CoValues track who made each change and when. Every edit has metadata attached to it:

<CodeGroup>
```ts
class GardenTask extends CoMap {
  title = co.string;
  description = co.string;
  progress = co.literal("not started", "in progress", "completed");
  area = co.literal("vegetables", "fruit", "herbs", "flowers");
}

const task = GardenTask.create({
  title: "Plant spring vegetables",
  description: "Plant peas, carrots, and lettuce",
  progress: "not started",
  area: "vegetables",
});

// Change the progress
task.progress = ("in progress");

// Get the full edit history for a field
for (const edit of task._raw.editsAt("progress")) {
  console.log({
    author: edit.by,        // Account/agent that made the change
    timestamp: edit.at,     // When the change happened 
    value: edit.value,      // Value of the change
    tx: edit.tx,            // Transaction ID
  });
}
```
</CodeGroup>

### Common Patterns

With knowledge of the edit history, you can build all sorts of useful things.

#### Audit Log

Getting all the changes to a CoValue in order allows you to build an audit log:

<CodeGroup>
```ts
function getAuditLog(task: GardenTask) {
  const changes = [];
  
  for (const field of Object.keys(task)) {
    for (const edit of task._raw.editsAt(field)) {
      changes.push({
        field,
        ...edit,
        timestamp: edit.at.toISOString()
      });
    }
  }
  
  // Sort by timestamp
  return changes.sort((a, b) => 
    b.timestamp.localeCompare(a.timestamp)
  );
}
```
</CodeGroup>

All changes are tracked automatically - this history is a core feature of CoValues. Use it to understand how your data evolved over time.

#### Activity Feeds

Activity feeds are a great way to see all the changes to a CoValue over time:

<CodeGroup>
```ts
function getRecentActivity(task: GardenTask) {
  const activity = [];
  const hourAgo = new Date(Date.now() - 3600000);
  
  for (const edit of task._raw.editsAt("progress")) {
    if (edit.at > hourAgo) {
      activity.push({
        field: edit.field,
        value: edit.value,
        by: edit.by,
      });
    } 
  }
  
  return activity.sort((a, b) => b.at - a.at);
}
```
</CodeGroup>

## Edit History & Time Travel

CoValues track their entire history of changes. You can see who changed what and when, or even view past states:

<CodeGroup> 
```ts
class GardenTask extends CoMap {
  title = co.string;
  description = co.string;
  progress = co.literal("not started", "in progress", "completed");
  area = co.literal("vegetables", "fruit", "herbs", "flowers");
}

// Create a new task
const task = GardenTask.create(
  {
    title: "Plant spring vegetables",
    description: "Plant peas, carrots, and lettuce",
    progress: "not started",
    area: "vegetables",
  },
);

task.progress = "in progress";

// See all edits for a field
for (const edit of task._raw.editsAt("progress")) {
  console.log(edit.at);       // When the change happened
  console.log(edit.value);    // Value of the change
  console.log(edit.by);       // Account that made the change
}

// Get a specific edit by index
const previousEdit = task._raw.nthEditAt("progress", 1); // Second most recent

```
</CodeGroup>

## Time Travel

Looking into the past can help you understand how things changed - perfect for audit logs, debugging, or showing user activity:

<CodeGroup>
```ts
class Project extends CoMap {
  location = co.string;
  status = co.literal("active", "offline", "unknown");
  lastSignal = co.Date;
}

// See when a tracker went offline
function findFailurePoint(tracker: MotionTracker) {
  for (const edit of tracker._raw.editsAt("status")) {
    if (edit.value === "offline") {
      // What else changed around this time?
      const contextState = tracker._raw.atTime(edit.at);
      console.log({
        failureTime: edit.at,
        lastKnownSignal: contextState.lastSignal,
        reportedBy: edit.by
      });
    }
  }
}
```
</CodeGroup>

### Common Use Cases

Activity feeds:

<CodeGroup>
```ts
function getRecentActivity(colony: Colony) {
  const activity = [];
  const hourAgo = new Date(Date.now() - 3600000);
  
  for (const field of colony.fields()) {
    for (const edit of colony._raw.editsAt(field)) {
      if (edit.at > hourAgo) {
        activity.push({
          type: 'field_change',
          field,
          value: edit.value,
          by: edit.by,
          at: edit.at
        });
      }
    }
  }
  
  return activity.sort((a, b) => b.at - a.at);
}
```
</CodeGroup>

Debugging state changes:

<CodeGroup>
```ts
// Find out when a door was last sealed
function checkDoorHistory(airlock: Airlock) {
  const pastStates = [];
  
  // Check every minute for the last hour
  for (let mins = 0; mins < 60; mins++) {
    const timePoint = new Date(Date.now() - mins * 60000).getTime();
    const state = airlock._raw.atTime(timePoint);
    pastStates.push({
      time: timePoint,
      sealed: state.sealed,
      pressure: state.pressure
    });
  }
  
  return pastStates;
}
```
</CodeGroup>

### Best Practices

- Cache historical queries if you're displaying them in UI
- Be specific about time ranges you care about
- Remember that accessing history requires loading the CoValue
- Consider using timestamps from your data rather than scanning all edits

Time travel is great for understanding how you got here, but keep queries focused on the range of time that matters to your use case.