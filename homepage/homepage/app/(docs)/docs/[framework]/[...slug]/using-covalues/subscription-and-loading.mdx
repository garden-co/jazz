import { CodeGroup, ContentByFramework } from "@/components/forMdx";

export const metadata = { title: "Subscriptions & Deep Loading" };

# Subscriptions & Deep Loading

Jazz's Collaborative Values (such as [CoMaps](/docs/using-covalues/comaps) or [CoLists](/docs/using-covalues/colists)) work like reactive state. By subscribing to them, you can react to both local and remote updates. This is the main way to consume data in your application.

Subscriptions also take care of loading CoValues that are not yet loaded locally and can do so *deeply* &mdash; by resolving nested CoValues. To make use of this, we'll show you how to specify the depth of data you need with resolve queries.

With each update you can also handle loading states and inaccessible CoValues.

## Manual subscriptions

You can subscribe to a CoValue from anywhere in your code (if you have its ID) by using `CoValue.subscribe()`.

<ContentByFramework framework="vanilla">
If you're using React in your project, check out our [React hooks](/docs/react/using-covalues/subscription-and-loading#subscription-hooks) which provide a more streamlined experience with automatic subscription management.
</ContentByFramework>

<ContentByFramework framework={["react", "react-native"]}>
**Note:** Unless you're using vanilla JavaScript, this is only used outside of React components - for example in server-side code or in tests. See the section below for convenient subscription *hooks* that you typically use in React.
</ContentByFramework>

<CodeGroup>
```ts
class Task extends CoMap {
  title = co.string;
  description = co.string;
  status = co.literal("todo", "in-progress", "completed");
  assignedTo = co.optional.string;
}

// ...

// Subscribe to a Task by ID
const unsubscribe = Task.subscribe(taskId, (updatedTask) => {
  console.log("Task updated:", updatedTask.title);
  console.log("New status:", updatedTask.status);
});

// Clean up when you're done
unsubscribe();

```
</CodeGroup>

If you already have a CoValue instance, you can subscribe to it by calling its `subscribe` method.

<CodeGroup>
```ts
const task = Task.create({
  title: "Cut the grass",
  // ...
});

const unsubscribe = task.subscribe((updatedTask) => {
  console.log("Task updated:", updatedTask.title);
});

// Clean up when you're done
unsubscribe();
```
</CodeGroup>

<ContentByFramework framework={["react", "react-native"]}>
## Subscription hooks

Jazz provides a `useCoState` hook that provides a convenient way to subscribe to CoValues and handle loading states:

<CodeGroup>
```tsx
function GardenPlanner({ projectId }: { projectId: ID<Project> }) {
  // Subscribe to a project and its tasks
  const project = useCoState(Project, projectId, {
    resolve: {
      tasks: true,
    },
  });

  if (!project) {
    return project === null
      ? "Project not found or not accessible"
      : "Loading project ...";
  }

  return (
    <div>
      <h1>{project.name}</h1>
      <TaskList tasks={project.tasks} />
    </div>
  );
}

function TaskList({ tasks }: { tasks: Task[] }) {
  return (
    <ul>
      {tasks.map((task) => (
        <li key={task.id}>
          <span>{task.title}</span>
          <span>{task.status}</span>
        </li>
      ))}
    </ul>
  );
}
```
</CodeGroup>

The `useCoState` hook handles subscribing when the component mounts and unsubscribing when it unmounts, making it easy to keep your UI in sync with the underlying data.
</ContentByFramework>

## Loading States and Permission Checking

When subscribing to or loading a CoValue, you need to handle three possible states:

- `undefined`: The initial loading state, indicating the value is being fetched
- `null`: The CoValue was not found or is not accessible (e.g., due to permissions)
- `Value`: The successfully loaded CoValue instance

This allows you to handle loading, error, and success states in your application:

<CodeGroup>
```ts
Task.subscribe(taskId, (task) => {
  if (task === undefined) {
    console.log("Task is loading...");
  } else if (task === null) {
    console.log("Task not found or not accessible");
  } else {
    console.log("Task loaded:", task.title);
  }
});
```
</CodeGroup>

## Deep Loading

When working with related CoValues (like tasks in a project), you often need to load not just the top-level object but also its nested references. This is especially important when working with [CoMaps](/docs/using-covalues/comaps) that contain references to other CoValues or with [CoLists](/docs/using-covalues/colists) that contain multiple items. Jazz provides a flexible mechanism for specifying exactly how much of the object graph to load.

### Resolve queries

Resolve queries let you declare exactly which references to load and how deep to go using the `resolve` property:

<CodeGroup>
```ts
class Project extends CoMap {
  name = co.string;
  tasks = co.ref(ListOfTasks);
}

class Task extends CoMap {
  title = co.string;
  subtasks = co.ref(ListOfTasks);
  assignee = co.optional.ref(TeamMember);
}

class ListOfTasks extends CoList.Of(co.ref(Task)) {}

// Load just the project, not its references
const project = await Project.load(projectId);
if (!project) { throw new Error("Project not found or not accessible"); }

// string - primitive fields are always loaded
project.name;
// undefined | null | ListOfTasks - non-requested references might not be loaded, or inaccessible
project.tasks;

// Load the project and shallowly load its list of tasks
const projectWithTasksShallow = await Project.load(projectId, {
  resolve: {
    tasks: true
  }
});
if (!projectWithTasksShallow) { throw new Error("Project or required references not found or not accessible"); }

// ListOfTasks - shallowly loaded
projectWithTasksShallow.tasks;
// number - length of the list
projectWithTasksShallow.tasks.length;
// undefined | null | Task - items might not be loaded, or inaccessible
projectWithTasksShallow.tasks[0];

// Load the project and its tasks
const projectWithTasks = await Project.load(projectId, {
  resolve: {
    tasks: {
      $each: true
    }
  }
});
if (!projectWithTasks) { throw new Error("Project or required references not found or not accessible"); }

// ListOfTasks - fully loaded
projectWithTasks.tasks;
// Task - fully loaded
projectWithTasks.tasks[0];
// string - primitive fields are always loaded
projectWithTasks.tasks[0].title;
// undefined | null | ListOfTasks - subtasks might not be loaded, or inaccessible
projectWithTasks.tasks[0].subtasks;

// Load the project, its tasks, and their subtasks
const projectDeep = await Project.load(projectId, {
  resolve: {
    tasks: {
      $each: {
        subtasks: {
          $each: true
        },
        assignee: true
      }
    }
  }
});
if (!projectDeep) { throw new Error("Project or required references not found or not accessible"); }

// string - primitive fields are always loaded
projectDeep.tasks[0].subtasks[0].title;
// undefined | null | TeamMember - since assignee is optional:
//   TeamMember - set and definitely loaded
//   null - set but unavailable/inaccessible
//   undefined - not set, or loading (in case of subscription)
projectDeep.tasks[0].assignee;
```
</CodeGroup>

The resolve query defines which parts of the graph you want to load, making it intuitive to express complex loading patterns.

### Loading states and permissions in collections and optional references



## Type Safety with Resolved Type

Jazz provides the `Resolved` type to help you define and enforce the structure of deeply loaded data in your application. This makes it easier to ensure that components receive the data they expect with proper TypeScript validation.

The `Resolved` type is especially useful when passing data between components, as it guarantees that all necessary nested data has been loaded:

<ContentByFramework framework="react">
<CodeGroup>
```ts
// Define a type that includes resolved nested data
type ProjectWithTasks = Resolved<Project, {
  tasks: { $each: true }
}>;

// Component that expects a fully resolved project
function TaskList({ project }: { project: ProjectWithTasks }) {
  // TypeScript knows tasks are loaded, so this is type-safe
  return (
    <ul>
      {project.tasks.map(task => (
        <li key={task.id}>{task.title}</li>
      ))}
    </ul>
  );
}

// For more complex resolutions
type FullyLoadedProject = Resolved<Project, {
  tasks: {
    $each: {
      subtasks: true,
      assignee: true
    }
  },
  owner: true
}>;

// Function that requires deeply resolved data
function processProject(project: FullyLoadedProject) {
  // Safe access to all resolved properties
  console.log(`Project ${project.name} owned by ${project.owner.name}`);

  project.tasks.forEach(task => {
    console.log(`Task: ${task.title}, Assigned to: ${task.assignee?.name}`);
    console.log(`Subtasks: ${task.subtasks.length}`);
  });
}
```
</CodeGroup>
</ContentByFramework>

<ContentByFramework framework="vanilla">
<CodeGroup>
```ts
// Define a type that includes resolved nested data
type ProjectWithTasks = Resolved<Project, {
  tasks: true
}>;

// Function that expects resolved data
async function taskList({project}: {project: ProjectWithTasks}) {
  // TypeScript knows tasks are loaded, so this is type-safe
  return project.tasks
    .filter(task => task !== null)
    .map(task => task.title)
    .join(`\n - `);
}

// For more complex resolutions
type FullyLoadedProject = Resolved<Project, {
  tasks: {
    $each: {
      title: true,
      subtasks: true,
      assignee: true
    }
  },
  owner: true
}>;

// Function that requires deeply resolved data
function processProject(project: FullyLoadedProject) {
  // Safe access to all resolved properties
  console.log(`Project ${project.name} owned by ${project.owner.name}`);

  project.tasks.forEach(task => {
    console.log(`Task: ${task.title}, Assigned to: ${task.assignee?.name}`);
    console.log(`Subtasks: ${task.subtasks.length}`);
  });
}
```
</CodeGroup>
</ContentByFramework>

Using the `Resolved` type helps catch errors at compile time rather than runtime, ensuring that your components and functions receive data with the proper resolution depth. This is especially useful for larger applications where data is passed between many components.

## Ensuring Data is Loaded

Sometimes you need to make sure data is loaded before proceeding with an operation. The `ensureLoaded` method lets you guarantee that a CoValue and its referenced data are loaded to a specific depth:

<CodeGroup>
```ts
async function completeAllTasks(projectId: ID<Project>) {
  // Ensure the project is loaded
  const project = await Project.load(projectId, { resolve: {} });
  if (!project) return;

  // Ensure tasks are loaded
  const loadedProject = await project.ensureLoaded({
    resolve: {
      tasks: true
    }
  });

  // Now we can safely access and modify tasks
  loadedProject.tasks.forEach(task => {
    task.status = "completed";
  });
}
```
</CodeGroup>

## Performance Considerations

Resolution depth is directly related to performance. Loading too much data can slow down your application, while loading too little can lead to unnecessary auto-loading delays. Finding the right balance is crucial for a responsive user experience.

Here are some practical guidelines:

- **Load only what you need** for the current view or operation
- **Preload data** that will be needed soon to improve perceived performance
- Use **caching** to avoid reloading data that hasn't changed
- **Be explicit** about loading patterns in performance-critical code

<CodeGroup>
```ts
// Bad: Loading everything deeply
const project = await Project.load(projectId, {
  resolve: {
    tasks: {
      $each: {
        subtasks: {
          $each: {
            comments: {
              $each: true
            }
          }
        }
      }
    },
    members: {
      $each: true
    },
    resources: {
      $each: true
    }
  }
});

// Better: Loading only what's needed for the current view
const project = await Project.load(projectId, {
  resolve: {
    tasks: true  // Just load the tasks shallowly
  }
});

// Later, when a task is selected:
const task = await Task.load(selectedTaskId, {
  resolve: {
    subtasks: true  // Now load its subtasks
  }
});
```
</CodeGroup>

## Using the Load Cache

By default, Jazz maintains a cache of loaded CoValues to avoid unnecessary network requests. This means that if you've already loaded a CoValue, subsequent load requests will use the cached version unless you explicitly request a refresh.

<CodeGroup>
```ts
// First load: fetches from network or local storage
const project = await Project.load(projectId, { resolve: {} });

// Later loads: uses cached version if available
const sameProject = await Project.load(projectId, { resolve: {} });
```
</CodeGroup>



## Best Practices

1. **Be explicit about resolution depths**: Always specify exactly what you need
2. **Clean up subscriptions**: Always store and call the unsubscribe function when you're done
3. **Handle all loading states**: Check for undefined (loading), null (not found), and success states
4. **Use framework integrations**: They handle subscription lifecycle automatically
5. **Balance depth and performance**: Load only what you need for the current view
6. **Take advantage of auto-loading**: For simpler use cases, rely on automatic loading of nested references
7. **Use the Resolved type**: Add compile-time type safety for components that require specific resolution patterns
