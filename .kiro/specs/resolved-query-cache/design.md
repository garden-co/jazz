# Design Document: Resolved Query Cache

## Overview

This design document describes the implementation of a cache system for resolved queries in the Jazz framework. The cache system tracks CoValue data through subscription scopes and stores it efficiently using cache keys. The StorageAPI manages the cache when the underlying driver supports caching, enabling faster query resolution and reduced network traffic.

The cache operates by:
1. Generating cache keys from resolve queries and root CoValue IDs in SubscriptionScope
2. Propagating cache keys through the subscription hierarchy
3. Tracking cache keys in CoValueCore as dependencies are resolved
4. Warming up cached data when loading CoValues
5. Updating cache buckets when storing CoValues

## Architecture

The cache system spans multiple layers of the Jazz architecture:

```
SubscriptionScope (jazz-tools)
    ↓ cache key generation & propagation
CoValueCoreSubscription (jazz-tools)
    ↓ cache key passing
LocalNode (cojson)
    ↓ cache key tracking
CoValueCore (cojson)
    ↓ dependency cache key propagation
StorageAPI (cojson)
    ↓ cache operations
Driver (implementation-specific)
```

### Key Components

- **SubscriptionScope**: Manages subscriptions and generates cache keys for cacheable scopes
- **CoValueCoreSubscription**: Bridges SubscriptionScope and LocalNode, passing cache keys
- **LocalNode**: Coordinates CoValue loading and passes cache keys to storage
- **CoValueCore**: Tracks cache keys and propagates them to dependencies
- **StorageAPI**: Manages cache operations (load/store) when driver supports caching
- **Driver**: Underlying storage implementation that may support caching

## Components and Interfaces

### SubscriptionScope Cache Key Generation

```typescript
class SubscriptionScope<D extends CoValue> {
  cacheKey?: string;
  private markedAsCacheable: boolean = false;
  
  // Generate cache key from resolve query, root CoValue ID, and account ID
  private generateCacheKey(
    resolveQuery: RefsToResolve<D>,
    rootId: ID<D>,
    accountId: ID<Account>
  ): string;
  
  // Mark this scope as cacheable
  markAsCacheable(): void {
    this.markedAsCacheable = true;
  }
  
  // Check if this scope is cacheable (marked as cacheable AND current account is not a guest)
  isCacheable(): boolean {
    if (!this.markedAsCacheable) {
      return false;
    }
    
    const id = this.node.getCurrentAccountOrAgentID();
    return !isAgentId(id);
  }
}
```

The cache key is generated by:
1. Serializing the resolve query to a stable string representation
2. Combining it with the root CoValue ID
3. Including the account ID to ensure account-specific caching
4. Hashing the result to create a unique identifier

**Caching Restrictions:**
- Caching is only enabled for non-guest accounts
- Guest accounts have temporary access patterns that don't benefit from caching
- Different accounts may have different permissions to access CoValues
- Cache entries must be isolated per account to prevent unauthorized data access
- Account-specific caching ensures that cached data respects permission boundaries

### Cache Key Propagation

```typescript
class SubscriptionScope<D extends CoValue> {
  // When creating child scopes, propagate the cache key
  private createChildScope(
    id: string,
    descriptor: RefEncoded<any>,
    query: RefsToResolve<any>
  ): SubscriptionScope<CoValue> {
    const child = new SubscriptionScope(
      this.node,
      query,
      id as ID<any>,
      descriptor,
      this.skipRetry,
      this.bestEffortResolution,
      this.unstable_branch,
      this.cacheKey // propagate cache key to child
    );
    return child;
  }
  
  // Get account ID from the node
  private getAccountId(): ID<Account> {
    return this.node.getCurrentAccountOrAgentID();
  }
}
```

### CoValueCoreSubscription Cache Key Handling

```typescript
class CoValueCoreSubscription {
  constructor(
    localNode: LocalNode,
    id: string,
    listener: (value: RawCoValue | typeof CoValueLoadingState.UNAVAILABLE) => void,
    skipRetry?: boolean,
    branch?: BranchDefinition,
    cacheKey?: string // new parameter
  );
  
  // Pass cache key to LocalNode when loading
  private loadCoValue(): void;
}
```

### LocalNode Cache Integration

```typescript
class LocalNode {
  // Load CoValue with optional cache key
  loadCoValueCore(
    id: RawCoID,
    cacheKey?: string,
    skipRetry?: boolean
  ): Promise<CoValueCore>;
  
  // Store CoValue with cache keys embedded in NewContentMessage
  store(
    msg: NewContentMessage,
    correctionCallback: CorrectionCallback
  ): Promise<void> {
    // Embed cache keys from CoValueCore into the message before storing
    const coValue = this.getCoValue(msg.id);
    if (coValue && coValue.getCacheKeys().size > 0) {
      msg.cacheKeys = Array.from(coValue.getCacheKeys());
    }
    return this.storage.store(msg, correctionCallback);
  }
  
  // Pass cache key to CoValueCore for tracking
  private trackCacheKey(
    coValue: CoValueCore,
    cacheKey: string
  ): void;
}
```

### CoValueCore Cache Key Tracking

```typescript
class CoValueCore {
  private cacheKeys: Set<string> = new Set();
  private dependencies: Set<RawCoID> = new Set();
  
  // Add cache key to this CoValue and propagate to all existing dependents
  addCacheKey(cacheKey: string): void {
    this.cacheKeys.add(cacheKey);
    
    // Propagate the new cache key to all existing available dependencies
    for (const dependencyId of this.dependencies) {
      const dependency = this.node.getCoValue(dependencyId);
      if (dependency.isAvailable()) {
        dependency.addCacheKey(cacheKey);
      }
    }
  }
  
  // When adding dependencies, propagate cache keys
  addDependency(dependencyId: RawCoID): void {
    this.dependencies.add(dependencyId);
    
    const dependency = this.node.getCoValue(dependencyId);
    if (dependency.isAvailable()) {
      // Propagate all cache keys to the dependency
      for (const cacheKey of this.cacheKeys) {
        dependency.addCacheKey(cacheKey);
      }
    }
  }
  
  // Get all cache keys for this CoValue
  getCacheKeys(): Set<string>;
}
```

### StorageAPI Cache Operations

```typescript
interface StorageAPI {
  // Check if driver supports caching
  supportsCaching(): boolean;
  
  // Load cache bucket for a cache key
  loadCache(cacheKey: string): Promise<void>;
  
  // Load CoValue with optional cache key for cache warming
  load(
    id: string, 
    callback: (data: NewContentMessage) => void, 
    done: (found: boolean) => void,
    cacheKey?: string
  ): Promise<void>;
  
  // Store CoValue - cache keys are embedded in the NewContentMessage
  // When message contains cache keys, also update cache buckets
  store(
    msg: NewContentMessage, 
    correctionCallback: CorrectionCallback
  ): Promise<void>;
}
```

### Driver Cache Support

```typescript
interface DBClientInterfaceAsync {
  // Check if this driver supports caching
  supportsCaching(): boolean;
  
  // Warm up cache bucket by loading all CoValues into memory
  // This is a warmup function that doesn't return content
  loadCacheBucket(cacheKey: string): Promise<void>;
  
  // Add CoValue to cache bucket
  addToCacheBucket(cacheKey: string, coValueId: string): Promise<void>;
  
  // Existing methods...
}
```

## Data Models

### Cache Key Structure

```typescript
type CacheKey = string; // Hash of resolve query + root CoValue ID + account ID

interface CacheKeyComponents {
  resolveQuery: string; // Serialized resolve query
  rootCoValueId: string; // Root CoValue ID
  accountId: string; // Account ID for permission isolation
}
```

### NewContentMessage with Cache Keys

```typescript
interface NewContentMessage {
  // Existing fields...
  cacheKeys?: CacheKey[]; // Optional list of cache keys this message belongs to
}
```



## Correctness Properties


*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*

### Property 1: Driver caching capability detection
*For any* driver, when the StorageAPI initializes with that driver, the StorageAPI should correctly identify whether the driver supports caching capabilities
**Validates: Requirements 1.1**

### Property 2: Cache operation delegation with caching support
*For any* cache operation and driver that supports caching, when the cache operation is requested, the StorageAPI should delegate the operation to the driver
**Validates: Requirements 1.2**

### Property 3: Graceful cache operation handling without caching support
*For any* cache operation and driver that does not support caching, when the cache operation is requested, the StorageAPI should handle the request without errors and continue normal operation
**Validates: Requirements 1.3**

### Property 4: Cache key generation for cacheable scopes
*For any* SubscriptionScope with a resolve query, root CoValue ID, and account ID, when the scope is marked as cacheable, a cache key should be generated
**Validates: Requirements 2.1**

### Property 5: Cache key uniqueness
*For any* two combinations of resolve queries, root CoValue IDs, and account IDs, if the combinations are different, the generated cache keys should be different; if the combinations are identical, the generated cache keys should be identical
**Validates: Requirements 2.2**

### Property 6: No cache key for non-cacheable scopes
*For any* SubscriptionScope that is not marked as cacheable, no cache key should be generated
**Validates: Requirements 2.3**

### Property 6a: Cacheable status validation
*For any* SubscriptionScope, isCacheable() should return true only if the scope is marked as cacheable AND the current account is not a guest
**Validates: Requirements 2.1, 2.3**

### Property 7: Cache key propagation to children
*For any* root SubscriptionScope with a cache key, when child SubscriptionScopes are created, all children should have the same cache key as the parent
**Validates: Requirements 3.1, 3.2**

### Property 8: No cache key propagation without parent key
*For any* SubscriptionScope without a cache key, when child SubscriptionScopes are created, the children should not have cache keys
**Validates: Requirements 3.3**

### Property 9: Cache key passing to CoValueCoreSubscription
*For any* SubscriptionScope with a cache key, when a CoValueCoreSubscription is created, the cache key should be passed to the CoValueCoreSubscription
**Validates: Requirements 4.1**

### Property 10: Cache key passing to LocalNode
*For any* CoValueCoreSubscription with a cache key, when loading a CoValue, the cache key should be passed to LocalNode
**Validates: Requirements 4.2**

### Property 11: No cache key passing without scope key
*For any* SubscriptionScope without a cache key, when a CoValueCoreSubscription is created, no cache key should be passed
**Validates: Requirements 4.3**

### Property 12: Cache key passing to storage layer
*For any* LocalNode loading a CoValue with a cache key, the cache key should be passed to the storage layer
**Validates: Requirements 5.1**

### Property 13: Cache key tracking in CoValueCore
*For any* CoValue loaded with a cache key, the CoValueCore should track the cache key
**Validates: Requirements 5.2**

### Property 14: Cache warming on load
*For any* storage layer receiving a cache key during CoValue loading, loadCache should be called with the cache key
**Validates: Requirements 5.3**

### Property 15: Cache bucket warmup
*For any* cache key with an associated cache bucket, when loadCache is called, all CoValues in the cache bucket should be warmed up in memory
**Validates: Requirements 6.1**

### Property 16: Cached data availability after warmup
*For any* cache bucket warmed up via loadCache, the cached CoValues should be available for subsequent operations with improved performance
**Validates: Requirements 6.2**

### Property 17: Empty cache bucket handling
*For any* cache key without an associated cache bucket, when loadCache is called, it should complete without errors and without loading any data
**Validates: Requirements 6.3**

### Property 18: Cache key propagation to dependencies
*For any* CoValue with cache keys, when an available dependency is added, the dependency should receive all cache keys from the parent CoValue
**Validates: Requirements 7.1, 7.2**

### Property 19: No cache key propagation to unavailable dependencies
*For any* CoValue with cache keys, when an unavailable dependency is added, the dependency should not receive cache keys
**Validates: Requirements 7.3**

### Property 20: Cache keys embedded in stored messages
*For any* CoValue with cache keys, when the CoValue is stored, the NewContentMessage should contain the cache keys in its cacheKeys field
**Validates: Requirements 8.1**

### Property 21: Cache bucket update on store
*For any* NewContentMessage with cache keys, when store is called, addToCacheBucket should be called for each cache key
**Validates: Requirements 8.2**

### Property 22: No cache keys in messages without cache
*For any* CoValue without cache keys, when the CoValue is stored, the NewContentMessage should not contain cache keys
**Validates: Requirements 8.3**

### Property 23: Account ID inclusion in cache keys
*For any* cache key generation, the generated cache key should include the account ID as a component
**Validates: Requirements 9.1**

### Property 24: Account isolation in cache keys
*For any* two identical queries from different accounts, the generated cache keys should be different
**Validates: Requirements 9.2**

### Property 25: Account-specific cache access
*For any* cache access operation, only data cached under the current account's cache keys should be returned
**Validates: Requirements 9.3**

### Property 26: Cache key propagation to existing dependents
*For any* CoValue with existing dependencies, when a new cache key is added via addCacheKey, all available dependencies should receive the new cache key
**Validates: Requirements 7.1, 7.2**

## Error Handling

The cache system is designed to be resilient and non-critical. Any gaps in the cache can be filled from the network or storage, so cache consistency is not strictly required.

### Cache as Performance Optimization

The cache serves as a performance optimization layer. If cache operations fail or data is missing:
- The system continues normal operation by loading from network/storage
- No data loss occurs
- No correctness issues arise

### Graceful Degradation

When cache operations encounter errors:
1. Log the error for monitoring purposes
2. Continue with normal loading/storage operations
3. Skip the failed cache operation without blocking the request




## IndexedDB Driver Cache Implementation

### Overview

The IndexedDB driver will implement caching by storing NewContentMessage data in a dedicated object store for each cache key. This allows efficient retrieval and updating of cached CoValues.

**Note**: The IndexedDB cache implementation will be initially feature-flagged. This allows for extensive internal testing before enabling in production environments.

### IndexedDB Schema

```typescript
interface CacheStoreSchema {
  // Store name: `cache_${cacheKey}`
  // Key: coValueId (string)
  // Value: CacheEntry
}

interface CacheEntry {
  coValueId: string;
  messages: NewContentMessage[]; // Array of content messages for this CoValue
  lastUpdated: number; // Timestamp of last update
}
```

### Store Structure

For each cache key, create a dedicated object store:
- Store name: `cache_${cacheKey}` (sanitized for IndexedDB naming)
- Primary key: `coValueId`
- Index: None required (primary key provides direct lookup)

### Cache Operations

#### Loading Cache Bucket (Warmup)

```typescript
async loadCacheBucket(cacheKey: string): Promise<void> {
  const storeName = `cache_${sanitizeCacheKey(cacheKey)}`;
  const db = await this.getDatabase();
  
  // Check if store exists
  if (!db.objectStoreNames.contains(storeName)) {
    return; // No cache bucket exists, nothing to warm up
  }
  
  const transaction = db.transaction(storeName, 'readonly');
  const store = transaction.objectStore(storeName);
  const allEntries = await store.getAll();
  
  // Warm up cache by loading all entries into the regular storage system
  for (const entry of allEntries) {
    for (const message of entry.messages) {
      // Load each message into the regular storage cache/memory
      this.warmupMessage(message);
    }
  }
}

// Helper method to warm up individual messages
private warmupMessage(message: NewContentMessage): void {
  // Implementation depends on the specific driver's caching strategy
  // This could involve loading into memory cache, preparing for quick access, etc.
}
```

#### Storing to Cache Bucket

```typescript
async addToCacheBucket(
  cacheKey: string,
  coValueId: string,
  message: NewContentMessage
): Promise<void> {
  const storeName = `cache_${sanitizeCacheKey(cacheKey)}`;
  const db = await this.getDatabase();
  
  // Create store if it doesn't exist (requires version upgrade)
  if (!db.objectStoreNames.contains(storeName)) {
    await this.createCacheStore(storeName);
  }
  
  const transaction = db.transaction(storeName, 'readwrite');
  const store = transaction.objectStore(storeName);
  
  // Get existing entry or create new one
  const existing = await store.get(coValueId);
  
  if (existing) {
    // Merge new message with existing messages
    existing.messages.push(message);
    existing.lastUpdated = Date.now();
    await store.put(existing);
  } else {
    // Create new entry
    const entry: CacheEntry = {
      coValueId,
      messages: [message],
      lastUpdated: Date.now(),
    };
    await store.put(entry);
  }
  
  await transaction.complete;
}
```

#### Creating Cache Store

```typescript
async createCacheStore(storeName: string): Promise<void> {
  const db = await this.getDatabase();
  const currentVersion = db.version;
  
  db.close();
  
  // Reopen with incremented version to add new store
  const request = indexedDB.open(this.dbName, currentVersion + 1);
  
  request.onupgradeneeded = (event) => {
    const db = event.target.result;
    if (!db.objectStoreNames.contains(storeName)) {
      db.createObjectStore(storeName, { keyPath: 'coValueId' });
    }
  };
  
  await new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
```

### Message Merging Strategy

When storing new content messages for a CoValue that already exists in the cache:

1. **Append Strategy**: Append new messages to the existing array
2. **Deduplication**: Check for duplicate messages based on message content hash
3. **Ordering**: Maintain chronological order of messages

```typescript
function mergeMessages(
  existing: NewContentMessage[],
  newMessage: NewContentMessage
): NewContentMessage[] {
  // Check if message already exists (by comparing content)
  const isDuplicate = existing.some(msg => 
    messagesAreEqual(msg, newMessage)
  );
  
  if (isDuplicate) {
    return existing;
  }
  
  // Append new message
  return [...existing, newMessage];
}
```

### Cache Key Sanitization

IndexedDB store names have restrictions, so cache keys must be sanitized:

```typescript
function sanitizeCacheKey(cacheKey: string): string {
  // Replace invalid characters with underscores
  // IndexedDB store names can't contain certain characters
  return cacheKey.replace(/[^a-zA-Z0-9_]/g, '_');
}
```

### Future Improvements

The current design uses a simple append-based approach. Future optimizations could include:

#### Two-Store Architecture

1. **Compressed Store**: A single giant serialized Map that's compressed with gzip
   - Store name: `cache_${cacheKey}_compressed`
   - Contains the full state of all CoValues in the cache bucket
   - Periodically rebuilt from WAL
   - Provides fast bulk loading

2. **WAL (Write-Ahead Log) Store**: Where updates are appended
   - Store name: `cache_${cacheKey}_wal`
   - Contains incremental updates since last compression
   - Provides fast writes
   - Periodically merged into compressed store

#### Compaction Strategy

```typescript
interface CompactionStrategy {
  // Trigger compaction when WAL exceeds threshold
  walSizeThreshold: number; // bytes
  
  // Trigger compaction when WAL has too many entries
  walEntryThreshold: number; // count
  
  // Minimum time between compactions
  minCompactionInterval: number; // milliseconds
}

async compactCache(cacheKey: string): Promise<void> {
  // 1. Load all entries from WAL
  // 2. Load compressed store (if exists)
  // 3. Merge WAL entries into compressed data
  // 4. Compress merged data with gzip
  // 5. Write to compressed store
  // 6. Clear WAL
}
```

This two-store approach would provide:
- **Fast writes**: Append to WAL without decompression
- **Fast bulk reads**: Load compressed store once
- **Efficient storage**: Compression reduces disk usage
- **Incremental updates**: WAL captures recent changes

### Performance Characteristics

Current implementation:
- **Write**: O(1) per message (append to array)
- **Read**: O(n) where n is number of CoValues in cache bucket
- **Storage**: Linear with number of messages

With future two-store optimization:
- **Write**: O(1) to WAL
- **Read**: O(1) for compressed store + O(m) for WAL where m is WAL size
- **Storage**: Compressed size + WAL size (significantly smaller)
