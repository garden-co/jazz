<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jazz Sync Server Metrics Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
      min-height: 100vh;
    }

    h1 {
      text-align: center;
      margin-bottom: 24px;
      color: #58a6ff;
      font-size: 1.8rem;
      font-weight: 600;
    }

    .dashboard {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .card-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 16px;
    }

    .card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
    }

    .card-title {
      font-size: 0.85rem;
      color: #8b949e;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .card-value {
      font-size: 2rem;
      font-weight: 600;
      color: #58a6ff;
    }

    .card-sub {
      font-size: 0.9rem;
      color: #8b949e;
      margin-top: 4px;
    }

    .chart-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
    }

    .chart-card h3 {
      font-size: 1rem;
      color: #c9d1d9;
      margin-bottom: 12px;
      font-weight: 500;
    }

    .chart-container {
      position: relative;
      height: 200px;
    }

    .status {
      text-align: center;
      font-size: 0.8rem;
      color: #8b949e;
      margin-top: 16px;
    }

    .status-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3fb950;
      margin-right: 6px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .error {
      color: #f85149;
    }

    .error .status-dot {
      background: #f85149;
      animation: none;
    }
  </style>
</head>
<body>
  <h1>Jazz Sync Server Metrics Dashboard</h1>
  
  <div class="dashboard">
    <div class="card-row">
      <div class="card">
        <div class="card-title">Peers Connected</div>
        <div class="card-value" id="peers">-</div>
      </div>
      <div class="card">
        <div class="card-title">CoValues Loaded</div>
        <div class="card-value" id="covalues-available">-</div>
        <div class="card-sub">
          <span id="covalues-loading">loading: -</span> | 
          <span id="covalues-unknown">unknown: -</span>
        </div>
      </div>
      <div class="card">
        <div class="card-title">Ingress</div>
        <div class="card-value" id="ingress">-</div>
      </div>
      <div class="card">
        <div class="card-title">Egress</div>
        <div class="card-value" id="egress">-</div>
      </div>
    </div>

    <div class="chart-card">
      <h3>Incoming Message Queue (by peerRole)</h3>
      <div class="chart-container">
        <canvas id="incomingChart"></canvas>
      </div>
    </div>

    <div class="chart-card">
      <h3>Outgoing Message Queue (by priority)</h3>
      <div class="chart-container">
        <canvas id="outgoingChart"></canvas>
      </div>
    </div>

    <div class="chart-card">
      <h3>Storage Streaming Queue (by priority)</h3>
      <div class="chart-container">
        <canvas id="storageChart"></canvas>
      </div>
    </div>

    <div class="chart-card">
      <h3>Transaction Size Histogram</h3>
      <div class="chart-container">
        <canvas id="histogramChart"></canvas>
      </div>
    </div>
  </div>

  <div class="status" id="status">
    <span class="status-dot"></span>
    Connecting...
  </div>

  <script>
    // Prometheus text format parser
    function parsePrometheus(text) {
      const metrics = {};
      const lines = text.split('\n');
      
      for (const line of lines) {
        if (line.startsWith('#') || line.trim() === '') continue;
        
        // Parse metric line: metric_name{label="value"} value
        const match = line.match(/^([a-zA-Z_:][a-zA-Z0-9_:]*)((?:\{[^}]*\})?)?\s+(.+)$/);
        if (!match) continue;
        
        const [, name, labelsStr, valueStr] = match;
        const value = parseFloat(valueStr);
        
        // Parse labels
        const labels = {};
        if (labelsStr) {
          const labelMatch = labelsStr.slice(1, -1).matchAll(/([a-zA-Z_][a-zA-Z0-9_]*)="([^"]*)"/g);
          for (const [, key, val] of labelMatch) {
            labels[key] = val;
          }
        }
        
        if (!metrics[name]) {
          metrics[name] = [];
        }
        metrics[name].push({ labels, value });
      }
      
      return metrics;
    }

    // Format bytes to human readable
    function formatBytes(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Chart.js default configuration
    const chartDefaults = {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      plugins: {
        legend: {
          labels: { color: '#8b949e', font: { size: 11 } }
        }
      },
      scales: {
        x: {
          grid: { color: '#30363d' },
          ticks: { color: '#8b949e', maxTicksLimit: 10 }
        },
        y: {
          grid: { color: '#30363d' },
          ticks: { color: '#8b949e' },
          beginAtZero: true
        }
      }
    };

    // Colors for chart lines
    const colors = {
      pushed: { client: '#58a6ff', server: '#3fb950' },
      pulled: { client: '#a371f7', server: '#f0883e' },
      priority: {
        0: { pushed: '#58a6ff', pulled: '#a371f7' },
        3: { pushed: '#3fb950', pulled: '#f0883e' },
        6: { pushed: '#f85149', pulled: '#ffa657' }
      }
    };

    // Data storage for time series (last 60 points) - stores delta (pushed - pulled)
    const MAX_POINTS = 60;
    const timeLabels = [];
    const incomingData = {
      client: [],
      server: []
    };
    const outgoingData = {
      p0: [],
      p3: [],
      p6: []
    };
    const storageData = {
      p0: [],
      p3: [],
      p6: []
    };

    // Initialize charts
    const incomingChart = new Chart(document.getElementById('incomingChart'), {
      type: 'line',
      data: {
        labels: timeLabels,
        datasets: [
          { label: 'client backlog', data: incomingData.client, borderColor: colors.pushed.client, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 },
          { label: 'server backlog', data: incomingData.server, borderColor: colors.pushed.server, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 }
        ]
      },
      options: chartDefaults
    });

    const outgoingChart = new Chart(document.getElementById('outgoingChart'), {
      type: 'line',
      data: {
        labels: timeLabels,
        datasets: [
          { label: 'priority 0 backlog', data: outgoingData.p0, borderColor: colors.priority[0].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 },
          { label: 'priority 3 backlog', data: outgoingData.p3, borderColor: colors.priority[3].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 },
          { label: 'priority 6 backlog', data: outgoingData.p6, borderColor: colors.priority[6].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 }
        ]
      },
      options: chartDefaults
    });

    const storageChart = new Chart(document.getElementById('storageChart'), {
      type: 'line',
      data: {
        labels: timeLabels,
        datasets: [
          { label: 'priority 0 backlog', data: storageData.p0, borderColor: colors.priority[0].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 },
          { label: 'priority 3 backlog', data: storageData.p3, borderColor: colors.priority[3].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 },
          { label: 'priority 6 backlog', data: storageData.p6, borderColor: colors.priority[6].pushed, backgroundColor: 'transparent', tension: 0.3, pointRadius: 0 }
        ]
      },
      options: chartDefaults
    });

    const histogramChart = new Chart(document.getElementById('histogramChart'), {
      type: 'bar',
      data: {
        labels: [],
        datasets: [{
          label: 'Count',
          data: [],
          backgroundColor: '#58a6ff',
          borderColor: '#58a6ff',
          borderWidth: 1
        }]
      },
      options: {
        ...chartDefaults,
        plugins: {
          legend: { display: false }
        }
      }
    });

    // Helper to get metric value by labels (returns first match)
    function getMetricValue(metrics, name, labels = {}) {
      const entries = metrics[name] || [];
      for (const entry of entries) {
        let match = true;
        for (const [key, val] of Object.entries(labels)) {
          if (entry.labels[key] !== val) {
            match = false;
            break;
          }
        }
        if (match) return entry.value;
      }
      return 0;
    }

    // Helper to sum metric values across all matching entries
    function sumMetricValues(metrics, name, labels = {}) {
      const entries = metrics[name] || [];
      let sum = 0;
      for (const entry of entries) {
        let match = true;
        for (const [key, val] of Object.entries(labels)) {
          if (entry.labels[key] !== val) {
            match = false;
            break;
          }
        }
        if (match) sum += entry.value;
      }
      return sum;
    }

    // Update dashboard with new metrics
    function updateDashboard(metrics) {
      // Update gauge cards - sum peers across all roles
      const peers = sumMetricValues(metrics, 'jazz_peers');
      document.getElementById('peers').textContent = peers;

      const covaluesAvailable = getMetricValue(metrics, 'jazz_covalues_loaded', { state: 'available' });
      const covaluesLoading = getMetricValue(metrics, 'jazz_covalues_loaded', { state: 'loading' });
      const covaluesUnknown = getMetricValue(metrics, 'jazz_covalues_loaded', { state: 'unknown' });
      document.getElementById('covalues-available').textContent = covaluesAvailable;
      document.getElementById('covalues-loading').textContent = `loading: ${covaluesLoading}`;
      document.getElementById('covalues-unknown').textContent = `unknown: ${covaluesUnknown}`;

      // Update usage cards
      const ingress = getMetricValue(metrics, 'jazz_usage_ingress_total');
      const egress = getMetricValue(metrics, 'jazz_usage_egress_total');
      document.getElementById('ingress').textContent = formatBytes(ingress);
      document.getElementById('egress').textContent = formatBytes(egress);

      // Add time label
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
      timeLabels.push(timeStr);
      if (timeLabels.length > MAX_POINTS) timeLabels.shift();

      // Update incoming queue data (delta = pushed - pulled = backlog)
      const clientPushed = getMetricValue(metrics, 'jazz_messagequeue_incoming_pushed_total', { peerRole: 'client' });
      const clientPulled = getMetricValue(metrics, 'jazz_messagequeue_incoming_pulled_total', { peerRole: 'client' });
      const serverPushed = getMetricValue(metrics, 'jazz_messagequeue_incoming_pushed_total', { peerRole: 'server' });
      const serverPulled = getMetricValue(metrics, 'jazz_messagequeue_incoming_pulled_total', { peerRole: 'server' });
      incomingData.client.push(clientPushed - clientPulled);
      incomingData.server.push(serverPushed - serverPulled);
      for (const arr of Object.values(incomingData)) {
        if (arr.length > MAX_POINTS) arr.shift();
      }

      // Update outgoing queue data (delta = pushed - pulled = backlog)
      const out0Pushed = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pushed_total', { priority: '0' });
      const out0Pulled = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pulled_total', { priority: '0' });
      const out3Pushed = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pushed_total', { priority: '3' });
      const out3Pulled = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pulled_total', { priority: '3' });
      const out6Pushed = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pushed_total', { priority: '6' });
      const out6Pulled = sumMetricValues(metrics, 'jazz_messagequeue_outgoing_pulled_total', { priority: '6' });
      outgoingData.p0.push(out0Pushed - out0Pulled);
      outgoingData.p3.push(out3Pushed - out3Pulled);
      outgoingData.p6.push(out6Pushed - out6Pulled);
      for (const arr of Object.values(outgoingData)) {
        if (arr.length > MAX_POINTS) arr.shift();
      }

      // Update storage streaming queue data (delta = pushed - pulled = backlog)
      const stor0Pushed = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pushed_total', { priority: '0' });
      const stor0Pulled = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pulled_total', { priority: '0' });
      const stor3Pushed = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pushed_total', { priority: '3' });
      const stor3Pulled = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pulled_total', { priority: '3' });
      const stor6Pushed = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pushed_total', { priority: '6' });
      const stor6Pulled = getMetricValue(metrics, 'jazz_messagequeue_storage_streaming_pulled_total', { priority: '6' });
      storageData.p0.push(stor0Pushed - stor0Pulled);
      storageData.p3.push(stor3Pushed - stor3Pulled);
      storageData.p6.push(stor6Pushed - stor6Pulled);
      for (const arr of Object.values(storageData)) {
        if (arr.length > MAX_POINTS) arr.shift();
      }

      // Update time series charts
      incomingChart.update();
      outgoingChart.update();
      storageChart.update();

      // Update histogram
      const histogramEntries = (metrics['jazz_transactions_size_bucket'] || [])
        .filter(e => e.labels.le !== '+Inf')
        .sort((a, b) => parseFloat(a.labels.le) - parseFloat(b.labels.le));
      
      if (histogramEntries.length > 0) {
        const bucketLabels = histogramEntries.map(e => `â‰¤${e.labels.le}`);
        const bucketCounts = [];
        
        // Convert cumulative counts to per-bucket counts
        for (let i = 0; i < histogramEntries.length; i++) {
          const current = histogramEntries[i].value;
          const previous = i > 0 ? histogramEntries[i - 1].value : 0;
          bucketCounts.push(current - previous);
        }
        
        histogramChart.data.labels = bucketLabels;
        histogramChart.data.datasets[0].data = bucketCounts;
        histogramChart.update();
      }
    }

    // Fetch metrics and update dashboard
    async function fetchMetrics() {
      try {
        const response = await fetch('/api/metrics');
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const text = await response.text();
        const metrics = parsePrometheus(text);
        updateDashboard(metrics);
        
        const statusEl = document.getElementById('status');
        statusEl.className = 'status';
        statusEl.innerHTML = '<span class="status-dot"></span>Last updated: ' + new Date().toLocaleTimeString();
      } catch (error) {
        const statusEl = document.getElementById('status');
        statusEl.className = 'status error';
        statusEl.innerHTML = '<span class="status-dot"></span>Error: ' + error.message;
      }
    }

    // Initial fetch and set up auto-refresh
    fetchMetrics();
    setInterval(fetchMetrics, 2000);
  </script>
</body>
</html>
