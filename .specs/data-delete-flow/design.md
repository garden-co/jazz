# Design: Data Delete Flow for CoValues

## Overview

This design implements a secure, efficient data deletion flow for coValues that allows users to self-serve data deletion. The solution uses unencrypted delete transactions with specific metadata, immediate sync blocking, and eventual physical deletion through batch processing. Deleted coValues leave cryptographic tombstones that prevent data resurrection while enabling efficient cleanup.

**Important Constraint**: Account and Group coValues cannot be deleted. This is required to keep the tombstone permissions verifiable.

The design leverages existing transaction validation mechanisms, adding delete-specific checks in `tryAddTransactions`, and implements sync restrictions to prevent deleted content from propagating while allowing delete operations to sync.

## Backward compatibility (wire protocol + mixed-version peers)

This design is intended to be rolled out without introducing new message types or changing the shape of existing sync messages (`load`, `known`, `content`, `done`). Instead, we change *semantics* for deleted coValues while remaining compatible with older peers.

Key points:

- **No protocol versioning required**: delete is represented as an ordinary unencrypted (`trusting`) transaction with meta `{ deleted: true }`, and a dedicated delete session ID (`${accountOrAgentID}_session_z${random}_deleted`, generated by `crypto.newDeleteSessionID(...)`).
- **Mixed-version safety**:
  - New peers must **not accept** or **re-propagate** historical content for a deleted coValue (they only accept/sync the tombstone).
  - Old peers may continue to send historical content. New peers handle this by **ignoring** non-delete sessions for deleted coValues (see “Sync message behavior” below). This avoids resurrection even when older peers don’t understand deletion.
- **Sync quenching (“stop syncing knownState”)**: when interacting with older peers, we prevent them from continuously trying to upload historical sessions by responding with a `known` message that merges our current knownState with the peer’s knownState (`stopSyncingKnownStateMessage(peerKnownState)`), so the sender believes we already have what it has (even if we intentionally dropped it due to deletion).

## Architecture / Components

### 1. Delete API Method

**Location**: `packages/cojson/src/coValueCore/coValueCore.ts`

**Changes**:
- Add method `deleteCoValue()` to `CoValueCore`:
  - Checks that the coValue is not an Account or Group (throws error if it is)
  - Checks that the current account has admin permissions on the coValue
  - Throws error if not admin
  - Creates delete transaction with meta `{ deleted: true }`
  - Uses a dedicated delete session (suffix `_deleted`, generated by `crypto.newDeleteSessionID(node.getCurrentAccountOrAgentID())`)

**Key Logic (final implementation)**:
```typescript
/**
 * Creates a delete marker transaction for this CoValue and sets the coValue as deleted
 *
 * Constraints:
 * - Account and Group CoValues cannot be deleted.
 * - Only admins can delete a coValue.
 */
deleteCoValue() {
  if (!this.verified) {
    throw new Error("Cannot delete coValue without verified state");
  }

  if (this.isGroupOrAccount()) {
    throw new Error("Cannot delete Group or Account coValues");
  }

  if (this.isDeleted) {
    throw new Error("CoValue is already deleted");
  }

  // Enforce admin-only permissions for values owned by groups
  const group = this.safeGetGroup();
  if (group) {
    const role = group.myRole();
    if (role !== "admin") {
      throw new Error("Only admins can delete coValues");
    }
  }

  // Creates a trusting {deleted:true} transaction.
  // The delete session ID is generated inside makeTransaction().
  this.makeTransaction([], "trusting", { deleted: true });
}
```

### 2. Delete Transaction Creation

**Location**: `packages/cojson/src/coValueCore/coValueCore.ts` - `makeTransaction()`

**Changes (final implementation)**:
- `makeTransaction()` does **not** accept a `sessionID` override.
- If `meta?.deleted === true`, `makeTransaction()` switches to a dedicated delete session ID generated via `crypto.newDeleteSessionID(node.getCurrentAccountOrAgentID())`.
- Delete-marker detection requires delete sessions to be `_deleted` sessions and the transaction to be `trusting` with meta `{ deleted: true }`.

**Rationale for Special Delete Session**:
The dedicated delete session ID (`*_deleted`, generated by `crypto.newDeleteSessionID(...)`) is used to sync a compact “tombstone marker” without carrying any history. By using a dedicated session for delete transactions, the system can:
- Easily identify delete operations by session ID pattern
- Sync only the delete marker without carrying any history
- Maintain a clean separation between regular transactions and delete operations

**Key Logic (final implementation)**:
```typescript
makeTransaction(
  changes: JsonValue[],
  privacy: "private" | "trusting",
  meta?: JsonObject,
  madeAt?: number,
): boolean {
  if (!this.verified) {
    throw new Error(
      "CoValueCore: makeTransaction called on coValue without verified state",
    );
  }

  if (this.isDeleted) {
    throw new Error("Cannot make transaction on a deleted coValue");
  }

  const isDeleted = meta?.deleted;

  // This is an ugly hack to get a unique but stable session ID for editing the current account
  let sessionID =
    this.verified.header.meta?.type === "account"
      ? (this.node.currentSessionID.replace(
          this.node.getCurrentAgent().id,
          this.node.getCurrentAgent().currentAgentID(),
        ) as SessionID)
      : this.node.currentSessionID;

  if (isDeleted) {
    sessionID = this.crypto.newDeleteSessionID(
      this.node.getCurrentAccountOrAgentID(),
    );
  }

  // ... create trusting/private transaction ...

  if (isDeleted) {
    this.#markAsDeleted();
  }

  // ... notify + sync ...
}
```

**Delete session ID helper (final implementation)**:
```typescript
newDeleteSessionID(accountID: RawAccountID | AgentID): SessionID {
  return `${this.newRandomSessionID(accountID)}_deleted`;
}
```

### 3. Delete Transaction Validation in tryAddTransactions

**Location**: `packages/cojson/src/coValueCore/coValueCore.ts` - `tryAddTransactions()`

**Changes**:
- When ingesting delete-session content, detect delete marker transactions and validate permissions before accepting the delete marker
- Only parse transaction meta if sessionID ends with `_deleted` (optimization)
- Validate that delete transaction author has admin permissions
- Mark coValue as deleted if valid delete transaction found
- Store delete state for sync blocking

**Key Logic (final implementation)**:
```typescript
tryAddTransactions(
  sessionID: SessionID,
  newTransactions: Transaction[],
  newSignature: Signature,
  skipVerify: boolean = false,
) {
  // sync should never try to add transactions to a deleted coValue
  // (this is an additional safety check in case `tryAddTransactions` is called directly)
  if (this.isDeleted && !isDeletedSessionID(sessionID)) {
    return {
      type: "CoValueDeleted",
      id: this.id,
      error: new Error("Cannot add transactions to a deleted coValue"),
    } as const;
  }

  // ... resolve signerID unless skipVerify ...
  // ... require verified state ...

  // Detect + validate delete marker transactions during ingestion
  const deleteTransaction = isDeletedSessionID(sessionID)
    ? newTransactions.find((tx) => this.#isDeleteMarkerTransaction(tx))
    : undefined;

  if (!skipVerify && deleteTransaction) {
    const author = accountOrAgentIDfromSessionID(sessionID);
    const permission = this.#canAuthorDeleteCoValueAtTime(
      author,
      deleteTransaction.madeAt,
    );

    if (!permission.ok) {
      return {
        type: "DeleteTransactionRejected",
        id: this.id,
        sessionID,
        author,
        reason: permission.reason,
        error: new Error(permission.message),
      } as const;
    }
  }

  try {
    this.verified.tryAddTransactions(
      sessionID,
      signerID,
      newTransactions,
      newSignature,
      skipVerify,
    );

    // Mark deleted state when a delete marker transaction is accepted.
    // - In skipVerify mode (storage shards), we accept + mark without permission checks.
    // - In verify mode, we only reach here if the delete permission check passed.
    if (deleteTransaction && !this.isGroupOrAccount()) {
      this.#markAsDeleted();
    }

    this.processNewTransactions();
    this.scheduleNotifyUpdate();
    this.invalidateDependants();
  } catch (e) {
    return { type: "InvalidSignature", id: this.id, error: e } as const;
  }
}
```

### 4. Delete Permission Validation

**Location**: `packages/cojson/src/coValueCore/coValueCore.ts` - `#canAuthorDeleteCoValueAtTime(...)`

**Changes**:
- Check that transaction author had admin permissions on `tx.madeAt` when meta contains `{ deleted: true }`
- Reject delete transactions from non-admin accounts

**Key Logic (final implementation)**:
```typescript
#isDeleteMarkerTransaction(tx: Transaction): boolean {
  if (tx.privacy !== "trusting") return false;
  if (!tx.meta) return false;
  const meta = safeParseJSON(tx.meta);
  return meta?.deleted === true;
}

#canAuthorDeleteCoValueAtTime(
  author: RawAccountID | AgentID,
  madeAt: number,
):
  | { ok: true }
  | {
      ok: false;
      reason: "NotAdmin" | "CoValueNotDeletable" | "CannotVerifyPermissions";
      message: string;
    } {
  if (!this.verified) {
    return {
      ok: false,
      reason: "CannotVerifyPermissions",
      message: "Cannot verify delete permissions without verified state",
    };
  }

  if (this.isGroupOrAccount()) {
    return {
      ok: false,
      reason: "CoValueNotDeletable",
      message: "Cannot delete Group or Account coValues",
    };
  }

  const group = this.safeGetGroup();
  if (!group) {
    return {
      ok: false,
      reason: "CannotVerifyPermissions",
      message:
        "Cannot verify delete permissions for coValues not owned by a group",
    };
  }

  const role = group.atTime(madeAt).roleOfInternal(author);
  if (role !== "admin") {
    return {
      ok: false,
      reason: "NotAdmin",
      message: "Delete transaction rejected: author is not an admin",
    };
  }

  return { ok: true };
}
```

### 5. CoValue Deleted State Tracking

**Location**: `packages/cojson/src/coValueCore/coValueCore.ts` and `packages/cojson/src/coValueCore/verifiedState.ts`

**Changes (final implementation)**:
- `CoValueCore` tracks a single flag: `public isDeleted: boolean`.
- Deleted state is mirrored down into `VerifiedState`/`SessionMap` via `markAsDeleted()`, which:
  - prevents non-delete sessions from being appended/sent, and
  - rewrites `knownState()` to report **only delete sessions** (tombstone-only knownState).

**Key Logic (final implementation)**:
```typescript
// In CoValueCore
public isDeleted: boolean = false;

#markAsDeleted() {
  this.isDeleted = true;
  this.verified?.markAsDeleted();
}

// In VerifiedState
markAsDeleted() {
  this.isDeleted = true;
  this.sessions.markAsDeleted();
}

// In SessionMap
markAsDeleted() {
  this.isDeleted = true;

  // Report only deleted sessions in knownState.
  this.knownState = { id: this.id, header: true, sessions: {} };
  this.knownStateWithStreaming = undefined;
  this.streamingKnownState = undefined;
  this.invalidateKnownStateCache();

  for (const [sessionID, sessionLog] of this.sessions.entries()) {
    if (!isDeletedSessionID(sessionID)) continue;
    this.knownState.sessions[sessionID] = sessionLog.transactions.length;
  }
}
```

### 6. Immediate Sync Blocking

**Location**: `packages/cojson/src/sync.ts` - `SyncManager.handleNewContent()` and `SyncManager.syncLocalTransaction()`

**Changes**:
- Before syncing content, check if coValue is deleted
- If deleted, only allow syncing the delete session/transaction (tombstone)
- Block all other content from syncing

**Key Logic (final implementation)**:
```typescript
// In SyncManager.handleNewContent(...) (inbound filtering)
for (const [sessionID, newContentForSession] of getSessionEntriesFromContentMessage(msg)) {
  if (coValue.isDeleted && !isDeletedSessionID(sessionID)) {
    continue;
  }

  // ... compute newTransactions and tryAddTransactions ...

  // If we just learned the coValue is deleted while processing this message,
  // drop any previously accumulated non-delete sessions and keep only tombstone content.
  if (!wasAlreadyDeleted && coValue.isDeleted) {
    wasAlreadyDeleted = true;
    validNewContent.new = {};
  }

  validNewContent.new[sessionID] = newContentForSession;
}

// In SyncManager.sendNewContent(...) (outbound quenching)
if (!newContentPieces && !peer.toldKnownState.has(id)) {
  if (coValue.isDeleted) {
    this.trySendToPeer(
      peer,
      coValue.stopSyncingKnownStateMessage(peer.getKnownState(id)),
    );
  } else {
    this.trySendToPeer(peer, {
      action: "known",
      ...coValue.knownStateWithStreaming(),
    });
  }
}
```

### 6.1 Sync message behavior for deleted CoValues (responses + quenching)

This section defines exactly how existing sync message handlers behave once a coValue is marked as deleted (i.e. `isDeleted === true`).

#### Terminology / constants

- **Delete session**: any session ID where `isDeletedSessionID(sessionID) === true` (suffix `_deleted`).
- **Delete transaction count**: `knownState.sessions[deletedSessionID]` (typically `1`).
- **Quenching**: `stopSyncingKnownStateMessage(peerKnownState)` merges the peer’s knownState sessions into ours so older peers stop trying to upload historical sessions we intentionally ignore.

#### `load` message

Requirement: for a deleted coValue, the `load` response must:

- send **tombstone-only content** (header + delete session(s))
- ensure older peers stop trying to upload historical sessions we ignore

Behavior (final implementation):

- `sendNewContent(...)` uses `coValue.newContentSince(peer.getOptimisticKnownState(id))`.
  - `VerifiedState.newContentSince(...)` filters out non-delete sessions when `verified.isDeleted === true`.
- If there’s no new content to send and we haven’t yet told knownState:
  - we send `coValue.stopSyncingKnownStateMessage(peer.getKnownState(id))` to “quench” uploads from older peers.

Rationale:

- The explicit delete session counter allows a peer that is missing the tombstone to request/receive it.
- The `stopSyncingKnownStateMessage(peerKnownState)` merge prevents older peers that still have historical sessions from repeatedly trying to upload them after deletion.

#### `content` message

- For deleted coValues, only `content.new[sessionID]` where `sessionID.endsWith("_deleted")` is accepted/applied/stored.
- Any other `content.new` session entries MUST be ignored (and must not be stored or forwarded).
- If the incoming `content` contains `header`, it may be accepted if needed to complete the tombstone (header must remain available for verification).

#### `known` message

- For deleted coValues, the local `knownState()` is rewritten to contain **only delete sessions** (via `SessionMap.markAsDeleted()`), so sync completion naturally becomes delete-session-only.

#### `done` message

No special behavior required. It remains a transport-level signal.

### 6.2 `waitForSync` semantics for deleted CoValues

`waitForSync()` uses `coValue.knownState()` as the target. Once deleted, `knownState()` contains only delete sessions, so `waitForSync()` naturally waits only for the tombstone to be uploaded/stored and does not wait for historical sessions.

### 7. DBClient Deleted CoValue Tracking

**Location**: `packages/cojson/src/storage/types.ts` and DBClient implementations

**Changes**:
- DBClient needs to track deleted coValues to enable quick scanning for batch delete operations
- When a delete transaction is stored, mark the coValue as deleted in the database
- This allows efficient querying of all deleted coValues without scanning all coValues

**Key Logic (final implementation)**:
```typescript
// In StorageAPI interface (types.ts)
export interface StorageAPI {
  markCoValueAsDeleted(id: RawCoID): void;

  enableDeletedCoValuesErasure(): void;

  eraseAllDeletedCoValues(): Promise<void>;

  // ... load/store/knownState/waitForSync/close ...
}

// In DBClient interface (types.ts)
export interface DBClientInterfaceAsync {
  // ... existing methods ...

  markCoValueAsDeleted(id: RawCoID): Promise<unknown>;
  markCoValueDeletionDone(id: RawCoID): Promise<unknown>;
  getAllCoValuesWaitingForDelete(): Promise<RawCoID[]>;
}

export interface DBClientInterfaceSync {
  // ... existing methods ...

  markCoValueAsDeleted(id: RawCoID): unknown;
  markCoValueDeletionDone(id: RawCoID): unknown;
  getAllCoValuesWaitingForDelete(): RawCoID[];
}

// Physical deletion primitive lives on the storage transaction interfaces:
export interface DBTransactionInterfaceSync {
  eraseCoValueButKeepTombstone(coValueID: RawCoID): unknown;
  markCoValueDeletionDone(id: RawCoID): unknown;
}

export interface DBTransactionInterfaceAsync {
  eraseCoValueButKeepTombstone(coValueID: RawCoID): Promise<unknown>;
  markCoValueDeletionDone(id: RawCoID): Promise<unknown>;
}
```

**Implementation Notes (by adapter)**:

The repository currently has three DBClient implementations:

- SQLite (sync): `packages/cojson/src/storage/sqlite/client.ts` (`SQLiteClient`)
- SQLite (async): `packages/cojson/src/storage/sqliteAsync/client.ts` (`SQLiteClientAsync`)
- IndexedDB (async): `packages/cojson-storage-indexeddb/src/idbClient.ts` (`IDBClient`)

Additionally, these packages provide **SQLite drivers** that reuse the same SQLite storage implementation and therefore inherit the SQLite behavior below:

- `packages/cojson-storage-sqlite` (better-sqlite3 driver)
- `packages/cojson-storage-do-sqlite` (Cloudflare Durable Object SQLite driver)

#### 7.1 SQLite family (sync + async)

**Schema**

The SQLite schema is managed by `packages/cojson/src/storage/sqlite/sqliteMigrations.ts` (used by both `getSqliteStorage` and `getSqliteStorageAsync`).

Migration (final implementation):

```sql
CREATE TABLE IF NOT EXISTS deletedCoValues (
  coValueID TEXT PRIMARY KEY,
  status TEXT NOT NULL DEFAULT 'pending'
) WITHOUT ROWID;
```

**Implementation: `markCoValueAsDeleted(coValueID)` (final implementation)**

```sql
INSERT INTO deletedCoValues (coValueID) VALUES (?)
ON CONFLICT(coValueID) DO NOTHING;
```
**Implementation: `markCoValueDeletionDone(coValueID)` (final implementation)**

```sql
INSERT INTO deletedCoValues (coValueID, status) VALUES (?, 'done')
ON CONFLICT(coValueID) DO UPDATE SET status='done';
```


Notes:
- the storage write path already has `msg.id` (`RawCoID`); store that directly.

**Implementation: `getAllCoValuesWaitingForDelete()`**

```sql
SELECT coValueID AS id
FROM deletedCoValues
WHERE status = 'pending';
```

#### 7.2 IndexedDB (cojson-storage-indexeddb)

**Schema**

The IndexedDB schema is defined in `packages/cojson-storage-indexeddb/src/idbNode.ts` (inside `onupgradeneeded`).

Final implementation uses `indexedDB.open(name, 6)` and introduces:

- `deletedCoValues` store with `keyPath: "coValueID"` and index `deletedCoValuesByStatus` on `status`.

**Implementation: `markCoValueAsDeleted(coValueID)` (final implementation)**

`put` `{ coValueID, status: "pending" }` into the `deletedCoValues` store (idempotent via key).

**Implementation: `getAllCoValuesWaitingForDelete()`**

Read `getAll()` from the `deletedCoValues` store and return the `coValueID` field from each row where `status === "pending"`.

### 8. Storage API Batch Delete

**Location**: `packages/cojson/src/storage/storageSync.ts` and `packages/cojson/src/storage/storageAsync.ts`

**Changes**:
- Storage API should expose a method to delete all deleted coValues
- This method uses the DBClient's `getAllCoValuesWaitingForDelete()` to get the list
- For each deleted coValue, perform physical deletion while preserving tombstone

#### 8.1 When to run `eraseAllDeletedCoValues()`

**Background**: delete transactions provide immediate sync blocking (privacy + safety). Physical deletion is purely a **space-reclamation** step and can run later, in the background.

`deletedCoValues` is treated as a **work queue**: entries are enqueued as `status: "pending"`, then flipped to `status: "done"` once the coValue has been physically erased (tombstone preserved). (An implementation may optionally delete `done` entries later for compaction.)

**Default triggers**

- **After a delete is stored**:
  - schedule a near-future cleanup run (throttled), e.g. “run within the next minute”.
  - rationale: keeps queues short without doing heavy work synchronously in the user’s delete flow.

**Opt-in activation**

The physical erasure scheduler is **optional** and must be activated on `LocalNode`.

- If not activated, delete transactions still provide immediate sync blocking (tombstones), and `deletedCoValues` still acts as a work queue, but no background erasure runs are scheduled.
- When activated, the scheduler begins draining queued entries using the triggers above.

**Scheduler component**

The scheduling logic lives in a dedicated class (inside `cojson`), owned and orchestrated by the StorageAPI implementations:

- `DeletedCoValuesEraserScheduler`
  - schedules throttled runs after enqueue (does not push the run further into the future as more deletes arrive)
  - (optional) can schedule a one-shot startup drain via `scheduleStartupDrain()`, but this must be invoked explicitly by the caller
  - enforces a simple re-entrancy guard (only one drain run in-flight per storage instance)
  - can reschedule a follow-up run if more queue work remains

**Concurrency / locking**
- The operation should be guarded so only one eraser runs per database at a time.
  - sqlite: the DB is accessed only by a single process, use an in-memory “currently erasing” flag to avoid re-entrancy.
  - IndexedDB: rely on the single `readwrite` transaction semantics; also use an in-memory “currently erasing” flag to avoid re-entrancy in the same tab.

**Time budgeting**

There is no batching-by-count (`maxCoValuesPerRun`).

- **Sync storage (`StorageApiSync`)**: use a strict `maxDurationMs = 100ms` per scheduled run to avoid blocking the main thread.
- **Async storage (`StorageApiAsync`)**: no max-time budgeting; when scheduled, it drains the queue to completion.

If a budget-limited run stops early and queue entries remain, the scheduler should schedule a follow-up run soon (e.g. ~1s) until the queue is drained.

**Key Logic (final implementation)**:
```typescript
// StorageApiAsync: drains queue to completion
async eraseAllDeletedCoValues(): Promise<void> {
  const deletedCoValueIDs = await this.dbClient.getAllCoValuesWaitingForDelete();
  
  for (const coValueID of deletedCoValueIDs) {
    await this.dbClient.transaction(async (tx) => {
      await tx.eraseCoValueButKeepTombstone(coValueID);
      await tx.markCoValueDeletionDone(coValueID);
    });
  }
}

// StorageApiSync: budgeted (does not block main thread)
async eraseAllDeletedCoValues(): Promise<void> {
  this.eraseDeletedCoValuesOnceBudgeted();
}
```

### 9. DB Deleted CoValue Extraction

**Location**: DBClient implementations (`packages/cojson/src/storage/sqlite/client.ts`, `packages/cojson/src/storage/sqliteAsync/client.ts`, `packages/cojson-storage-indexeddb/src/idbClient.ts`)

**Changes**:
- DBClient should expose a method to enumerate pending deleted coValue IDs
- This enables efficient batch processing without loading all coValues into memory
- The method should return only the IDs, not full coValue data

**Key Logic (final implementation)**:
```typescript
export interface DBClientInterfaceSync {
  getAllCoValuesWaitingForDelete(): RawCoID[];
}

export interface DBClientInterfaceAsync {
  getAllCoValuesWaitingForDelete(): Promise<RawCoID[]>;
}
```

### 10. Delete Tombstone

**Location**: `packages/cojson/src/storage/storageSync.ts` and `packages/cojson/src/storage/storageAsync.ts`

**Changes**:
- When storing delete transaction, ensure tombstone is preserved
- Tombstone consists of: delete transaction + delete session + coValue header
- Even after physical deletion, tombstone remains

#### 10.1 Physical deletion primitive: erase all content but keep tombstone

This section defines the **storage-level primitive** used by batch deletion (section 8) to reclaim space while keeping a cryptographic tombstone.

**Goal**: remove all persisted history for a deleted coValue while preserving:

- the `coValues` row (header), and
- all sessions matching the delete-session pattern (`*_deleted$`) and their transactions/signatures.

Everything else for that coValue is physically deleted.

**Important properties**

- **Idempotent**: running it multiple times is safe.
- **Crash-safe**: must run inside a single storage transaction so we never end up with “half deleted” state.
- **Conservative on tombstone**: it keeps the full delete session(s). (Each delete session is expected to contain only the delete transaction, but storage doesn’t rely on that assumption.)

**Preconditions**

- The coValue is already marked deleted (has a valid delete transaction) and is present in the `deletedCoValues` marker structure (section 7).

**Postconditions**

- Non-delete sessions for that coValue are removed from:
  - `sessions`
  - `transactions`
  - `signatureAfter`
- Delete session(s) and the header remain, so the tombstone is still loadable/syncable.

##### 10.1.1 SQLite family (sync + async)

The SQLite storage schema is:

- `coValues(rowID, id, header, ...)`
- `sessions(rowID, coValue, sessionID, ...)`
- `transactions(ses, idx, tx, ...)` where `ses` is `sessions.rowID`
- `signatureAfter(ses, idx, signature, ...)` where `ses` is `sessions.rowID`

**Primitive signature (conceptual)**

- `eraseCoValueButKeepTombstone(coValueID: RawCoID): void | Promise<void>`

**Algorithm (single SQL transaction)**

0. Resolve `coValueRowID` (from `coValues`) for the given `coValueID`.

```sql
SELECT rowID FROM coValues WHERE id = ?;
```

1. Identify non-delete sessions:

```sql
SELECT rowID
FROM sessions
WHERE coValue = ?
  AND sessionID NOT LIKE '%_deleted';
```

2. Delete all rows for those sessions:

```sql
DELETE FROM transactions
WHERE ses IN (
  SELECT rowID FROM sessions
  WHERE coValue = ?
    AND sessionID NOT LIKE '%_deleted'
);

DELETE FROM signatureAfter
WHERE ses IN (
  SELECT rowID FROM sessions
  WHERE coValue = ?
    AND sessionID NOT LIKE '%_deleted'
);

DELETE FROM sessions
WHERE coValue = ?
  AND sessionID NOT LIKE '%_deleted';
```

`deletedCoValues` is treated as a **work queue**, mark the row as `done` so the batch job won’t repeatedly re-process already-erased coValues:

```sql
UPDATE deletedCoValues SET status = 'done' WHERE coValueID = ?;
```

##### 10.1.2 IndexedDB (cojson-storage-indexeddb)

The IndexedDB storage uses these stores:

- `coValues` (keyPath `rowID`) — keep
- `sessions` (keyPath `rowID`, indexed by `sessionsByCoValue`) — delete non-delete sessions
- `transactions` (keyPath `["ses","idx"]`) — delete for non-delete sessions
- `signatureAfter` (keyPath `["ses","idx"]`) — delete for non-delete sessions
- `deletedCoValues` (keyPath `coValueID`) — status-tracked queue semantics (see below)

**Primitive signature (conceptual)**

- `eraseCoValueButKeepTombstone(coValueID: RawCoID): Promise<void>`

**Algorithm (single IndexedDB readwrite transaction spanning all stores above)**

0. Resolve `coValueRowID` (from `coValues`) for the given `coValueID`.
1. Load all sessions for the coValue via the `sessionsByCoValue` index.
2. Partition them into:
   - keep: `sessionID.endsWith("_deleted")`
   - delete: everything else
3. For each session in the delete set:
   - delete all `transactions` keys in range `IDBKeyRange.bound([ses, 0], [ses, +∞])` (cursor delete)
   - delete all `signatureAfter` keys in the same `ses` range (cursor delete)
   - delete the `sessions` row by its `rowID`
4. Queue semantics for `deletedCoValues`:
   - set status to `done` (e.g. `deletedCoValues.put({ coValueID, status: "done" })`)
   - (optional) later compaction can delete `done` entries.

**Key Logic (pseudocode)**

```typescript
// Conceptual pseudocode inside one IDB transaction:
const coValueRowID = await resolveRowIDFromCoValuesById(coValueID);
const allSessions = await sessionsByCoValue.getAll(coValueRowID);
const sessionsToDelete = allSessions.filter((s) => !s.sessionID.endsWith("_deleted"));

for (const s of sessionsToDelete) {
  // delete txs for ses = s.rowID
  await deleteAllByPrefix(transactionsStore, [s.rowID]); // cursor over IDBKeyRange.bound([ses, 0], [ses, INF])
  await deleteAllByPrefix(signatureAfterStore, [s.rowID]);
  await sessionsStore.delete(s.rowID);
}

await deletedCoValuesStore.put({ coValueID, status: "done" });
```


### 11. Storage Shard Handling (skipVerify: true)

**Location**: `packages/cojson/src/storage/storageSync.ts` and `packages/cojson/src/storage/storageAsync.ts`

**Changes**:
- Storage shards with `skipVerify: true` don't verify delete transactions
- But they still delete the value and block sync

## Data Models

### Delete Transaction Metadata

```typescript
type DeleteTransactionMeta = {
  deleted: true;
};

type DeletedSessionID = `${SessionID}_deleted`;
```

### CoValue Deleted State

```typescript
type CoValueDeletedState = {
  isDeleted: boolean;
};
```

### `jazz-tools` subscription loading state for deleted CoValues

When consuming CoValues via `jazz-tools` subscriptions / loaders, deleted CoValues are surfaced as a **NotLoaded** value with:

- `value.$jazz.loadingState === "deleted"` (`CoValueLoadingState.DELETED`)

This state is treated like other terminal loading error states (`"unavailable"`, `"unauthorized"`):

- it propagates through the subscription tree like other NotLoaded errors
- `loadCoValue(...)` resolves (does not hang) when the root CoValue is deleted
- userland can handle it via the loading state (and optionally an `onDeleted` callback)


## Error Handling / Testing Strategy

### Error Cases

1. **Account or Group Delete Attempt**:
   - If trying to delete an Account or Group coValue
   - **Handling**: Throw error immediately before creating transaction
   - **Test**: Attempt delete on Account or Group, verify error thrown

2. **Non-Admin Delete Attempt**:
   - If non-admin tries to call `deleteCoValue()`
   - **Handling**: Throw error immediately before creating transaction
   - **Test**: Attempt delete as non-admin, verify error thrown

3. **Invalid Delete Transaction**:
   - If delete transaction from non-admin is received
   - **Handling**: Mark transaction as invalid in `determineValidTransactions()`
   - **Test**: Send delete transaction from non-admin, verify rejection

4. **Delete on Already Deleted CoValue**:
   - If trying to delete an already deleted coValue
   - **Handling**: Allow (idempotent) or reject with error
   - **Test**: Attempt delete on already deleted coValue

5. **Sync Blocking Failure**:
   - If sync blocking doesn't work correctly
   - **Handling**: Ensure deleted coValues can only sync delete session
   - **Test**: Try to sync non-delete content from deleted coValue, verify blocking

### Testing Strategy

1. **Unit Tests**:
   - `deleteCoValue()` - verify Account/Group check, admin check and transaction creation
   - `tryAddTransactions()` - verify delete detection and state marking
   - `determineValidTransactions()` - verify delete permission validation
   - Sync blocking logic - verify only delete session syncs
   - Tombstone storage - verify tombstone preservation
   - `DBClient.markCoValueAsDeleted()` - verify deleted coValues are tracked
   - `DBClient.getAllCoValuesWaitingForDelete()` - verify correct IDs are returned
   - `StorageAPI.eraseAllDeletedCoValues()` - verify batch deletion

2. **Integration Tests**:
   - End-to-end delete flow: Create coValue, delete it, verify state
   - Account deletion: Delete account, verify deletion state
   - Sync blocking: Delete coValue, try to sync, verify blocking
   - Batch delete: Multiple deletes, verify DBClient tracking and Storage API batch deletion
   - Tombstone: Delete coValue, physically delete, verify tombstone

3. **Edge Case Tests**:
   - Delete during active sync: Ensure no race conditions
   - Multiple delete transactions: Handle idempotency
   - Delete on large coValues: Verify performance
   - Storage shard deletes: Verify tombstone preservation
   - Concurrent deletes: Ensure consistency

4. **Stress Tests**:
   - Many coValues deleted simultaneously
   - Large accounts with many coValues
   - Rapid delete/sync operations
   - Storage performance with many tombstones

