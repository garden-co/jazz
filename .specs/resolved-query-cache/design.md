# Design Document: Resolved Query Cache

## Overview

This design document describes the implementation of a cache system for resolved queries in the Jazz framework. The cache system tracks CoValue data through subscription scopes and stores it efficiently using cache keys. The StorageAPI manages the cache when the underlying driver supports caching, enabling faster query resolution and reduced network traffic.

The cache operates by:
1. Generating cache keys from resolve queries and root CoValue IDs in SubscriptionScope
2. Propagating cache keys through the subscription hierarchy
3. Tracking cache keys in CoValueCore as dependencies are resolved
4. Warming up cached data when loading CoValues
5. Tagging CoValues with cacheKeys when updating or storing them

The caching optimizations are managed only ad DBDriver level, the rest of the architecture only tracks the cacheKeys and hints the DBDriver
that a CoValue is part of a "cache page"

The implementation of the cache page and what's in there depends on the driver implementation, because the performance there is tied to the storage model used.

## Architecture

The cache system spans multiple layers of the Jazz architecture:

```
SubscriptionScope (jazz-tools)
    ↓ cache key generation & propagation
CoValueCoreSubscription (jazz-tools)
    ↓ cache key passing
LocalNode (cojson)
    ↓ cache key tracking
CoValueCore (cojson)
    ↓ dependency cache key propagation
StorageAPI (cojson)
    ↓ cache operations
Driver (implementation-specific)
```

### Key Components

- **SubscriptionScope**: Manages subscriptions and generates cache keys for cacheable scopes
- **CoValueCoreSubscription**: Bridges SubscriptionScope and LocalNode, passing cache keys
- **LocalNode**: Coordinates CoValue loading and passes cache keys to storage
- **CoValueCore**: Tracks cache keys and propagates them to dependencies
- **StorageAPI**: Manages cache operations (load/store) when driver supports caching
- **Driver**: Underlying storage implementation that may support caching

## Components and Interfaces

### SubscriptionScope Cache Key Generation

```typescript
class SubscriptionScope<D extends CoValue> {
  cacheKey?: string;
  private cacheable: boolean;
  
  constructor(
    // ... existing parameters ...
    cacheable: boolean = false // new parameter to mark scope as cacheable
  ) {
    this.cacheable = cacheable;
    // ... rest of constructor ...
  }
  
  // Generate cache key from resolve query, root CoValue ID, and account ID
  // Uses shortHash which is compatible with IndexedDB store names
  private generateCacheKey(
    resolveQuery: RefsToResolve<D>,
    rootId: ID<D>,
    accountId: ID<Account>
  ): string;
  
  // Check if this scope is cacheable (marked as cacheable via constructor AND current account is not a guest)
  isCacheable(): boolean {
    if (!this.cacheable) {
      return false;
    }
    
    const id = this.node.getCurrentAccountOrAgentID();
    return !isAgentId(id);
  }
}
```

The cache key is generated by:
1. Serializing the resolve query to a stable string representation
2. Combining it with the root CoValue ID
3. Including the account ID to ensure account-specific caching
4. Using shortHash to create a unique identifier that is compatible with IndexedDB store names

**Caching Restrictions:**
- Caching is only enabled for non-guest accounts
- Guest accounts have temporary access patterns that don't benefit from caching
- Different accounts may have different permissions to access CoValues
- Cache entries must be isolated per account to prevent unauthorized data access
- Account-specific caching ensures that cached data respects permission boundaries

### Cache Key Propagation

```typescript
class SubscriptionScope<D extends CoValue> {
  // When creating child scopes, propagate the cache key and cacheable flag
  private createChildScope(
    id: string,
    descriptor: RefEncoded<any>,
    query: RefsToResolve<any>
  ): SubscriptionScope<CoValue> {
    const child = new SubscriptionScope(
      this.node,
      query,
      id as ID<any>,
      descriptor,
      this.skipRetry,
      this.bestEffortResolution,
      this.unstable_branch,
      undefined, // calleer stack
      this.cacheable, // propagate cacheable flag to child
      this.cacheKey // propagate cache key to child
    );
    return child;
  }
  
  // Get account ID from the node
  private getAccountId(): ID<Account> {
    return this.node.getCurrentAccountOrAgentID();
  }
}
```

### CoValueCoreSubscription Cache Key Handling

```typescript
class CoValueCoreSubscription {
  constructor(
    localNode: LocalNode,
    id: string,
    listener: (value: RawCoValue | typeof CoValueLoadingState.UNAVAILABLE) => void,
    skipRetry?: boolean,
    branch?: BranchDefinition,
    cacheKey?: string // new parameter
  );
  
  // Pass cache key to LocalNode when loading
  private loadCoValue(): void;
}
```

### LocalNode Cache Integration

```typescript
class LocalNode {
  // Load CoValue with optional cache key
  loadCoValueCore(
    id: RawCoID,
    cacheKey?: string,
    skipRetry?: boolean
  ): Promise<CoValueCore>;
  
  // Store CoValue with cache keys embedded in NewContentMessage
  store(
    msg: NewContentMessage,
    correctionCallback: CorrectionCallback
  ): Promise<void> {
    // Embed cache keys from CoValueCore into the message before storing
    const coValue = this.getCoValue(msg.id);
    if (coValue && coValue.getCacheKeys().size > 0) {
      msg.cacheKeys = coValue.getCacheKeys();
    }
    return this.storage.store(msg, correctionCallback);
  }
}
```

### CoValueCore Cache Key Tracking

```typescript
class CoValueCore {
  private cacheKeys: Set<string> = new Set();
  private dependencies: Set<RawCoID> = new Set();
  
  // Add cache key to this CoValue and propagate to all existing dependents
  addCacheKey(cacheKey: string): void {
    if (this.cacheKeys.has(cacheKey)) return;

    this.cacheKeys.add(cacheKey);
    
    // Propagate the new cache key to all existing available dependencies
    for (const dependencyId of this.dependencies) {
      const dependency = this.node.getCoValue(dependencyId);
      if (dependency.isAvailable()) {
        dependency.addCacheKey(cacheKey);
      }
    }
  }
  
  // When adding dependencies, propagate cache keys
  addDependency(dependencyId: RawCoID): void {
    
    //.. check if the dependency is already added

    // Propagate all cache keys to the dependency
    for (const cacheKey of this.cacheKeys) {
      dependency.addCacheKey(cacheKey);
    }
  }
  
  // Get all cache keys for this CoValue
  getCacheKeys(): Set<string>;
}
```

### StorageAPI Cache Operations

```typescript
interface StorageAPI {
  // Load CoValue with optional cache key for cache warming
  load(
    id: string, 
    callback: (data: NewContentMessage) => void, 
    done: (found: boolean) => void,
    cacheKey?: string
  ): Promise<void>;
  
  // Store CoValue - cache keys are embedded in the NewContentMessage
  // When message contains cache keys, also update cache buckets
  store(
    msg: NewContentMessage, 
    correctionCallback: CorrectionCallback
  ): Promise<void>;
}
```

### Storage CoValue Data Structures

The cache system enhances the existing storage data structures to support caching. The existing `CoValueRow` and `TransactionRow` types are upgraded with cache-related fields:

```typescript
export type CoValueRow = {
  id: RawCoID;
  header: CoValueHeader;
  cacheKeys: string[];
  sessions: Record<SessionID, {
    uid?: number; // For backward compat, new sessions uid is going to be coValueId + sessionID
    lastIdx: number;
    lastSignature: Signature;
    bytesSinceLastSignature?: number;
    signatures: Record<number, Signature>
  }>;
};

export type TransactionRow = {
  ses: number | string;
  idx: number;
  tx: Transaction;
};
```

**CoValueRow** (enhanced) represents a CoValue with caching support:
- `id`: The CoValue identifier
- `header`: The CoValue header containing metadata
- `cacheKeys`: Array of cache keys this CoValue belongs to (allows a CoValue to be in multiple cache buckets)
- `sessions`: Record of session information with:
  - `uid`: Optional unique identifier (for backward compatibility)
  - `lastIdx`: Last transaction index in this session
  - `lastSignature`: Last signature in this session
  - `bytesSinceLastSignature`: Optional byte count since last signature
  - `signatures`: Record of signatures by transaction index

**TransactionRow** (enhanced) represents a transaction with flexible session identification:
- `ses`: Session identifier (number or string, supporting both legacy numeric IDs and new string-based IDs)
- `idx`: Transaction index
- `tx`: The transaction data

These types are defined in `packages/cojson/src/storage/types.ts` and are used by storage implementations to store and retrieve data in a faster way compared with the current types.

### Driver Cache Support

The DBClientInterface must match the following interface, and we must migrate the Storage to use this new API

```typescript
export interface DBClientInterfaceAsync {
  getCoValue(
    coValueId: string,
    cacheKey?: string, // triggers a cache page load
  ): Promise<CoValueRow | undefined> | undefined;

  getSessionTransactions(
    sessionRowId: number | string,
    fromIdx: number,
    toIdx: number,
  ): Promise<TransactionRow[]>;

  transaction(
    callback: (tx: DBTransactionInterfaceAsync) => Promise<unknown>,
  ): Promise<unknown>;
}

export interface DBTransactionInterfaceAsync {
  updateCoValue(
    id: string,
    data: CoValueRow, // CacheKeys are already provided here
  ): Promise<CoValueRow | undefined>;

  addTransaction(
    sessionRowID: number | string,
    idx: number,
    newTransaction: Transaction,
  ): Promise<number> | undefined | unknown;
}
```

This changes how StorageAsync and StorageSync operates and the breaking change must be handled in all the Driver implementations.

## Data Models

### Cache Key Structure

```typescript
type CacheKey = string; // Hash of resolve query + root CoValue ID + account ID

interface CacheKeyComponents {
  resolveQuery: string; // Serialized resolve query
  rootCoValueId: string; // Root CoValue ID
  accountId: string; // Account ID for permission isolation
}
```

### NewContentMessage with Cache Keys

```typescript
interface NewContentMessage {
  // Existing fields...
  cacheKeys?: Iterable<CacheKey>; // Optional list of cache keys this message belongs to
}
```

**First Iteration Scope**: In the first iteration, only the retrieval of `CoValueRow` will be optimized for caching. Transaction retrieval optimization will be deferred to future iterations.
